@c -*-texinfo-*-
@c This is part of the SXEmacs Lisp Reference Manual.
@c Copyright (C) 1990, 1991, 1992, 1993, 1994 Free Software Foundation, Inc.
@c Copyright (C) 2005 Sebastian Freundt <hroptatyr@sxemacs.org>
@c See the file lispref.texi for copying conditions.
@setfilename ../../info/windows.info

@node Windows, Frames, Buffers, Top
@chapter Windows

  This chapter describes most of the functions and variables related to
Emacs windows.  See @ref{Display}, for information on how text is
displayed in windows.

@menu
* Basic Windows::               Basic information on using windows.
* Splitting Windows::           Splitting one window into two windows.
* Deleting Windows::            Deleting a window gives its space to other
                                  windows.
* Selecting Windows::           The selected window is the one that you edit
                                  in.
* Cyclic Window Ordering::      Moving around the existing windows.
* Buffers and Windows::         Each window displays the contents of a buffer.
* Displaying Buffers::          Higher-lever functions for displaying a buffer
                                  and choosing a window for it.
* Choosing Window::             How to choose a window for displaying a buffer.
* Window Point::                Each window has its own location of point.
* Window Start::                The display-start position controls which text
                                  is on-screen in the window.
* Vertical Scrolling::          Moving text up and down in the window.
* Horizontal Scrolling::        Moving text sideways on the window.
* Size of Window::              Accessing the size of a window.
* Position of Window::          Accessing the position of a window.
* Resizing Windows::            Changing the size of a window.
* Window Configurations::       Saving and restoring the state of the screen.
* Window Configuration Hook::   Running code when the window configuration
                                  changes.
@end menu


@node Basic Windows
@section Basic Concepts of Emacs Windows
@cindex window
@cindex selected window

  A @dfn{window} in SXEmacs is the physical area of the screen in which a
buffer is displayed.  The term is also used to refer to a Lisp object that
represents that screen area in SXEmacs Lisp.  It should be
clear from the context which is meant.

  SXEmacs groups windows into frames.  A frame represents an area of
screen available for SXEmacs to use.  Each frame always contains at least
one window, but you can subdivide it vertically or horizontally into
multiple nonoverlapping SXEmacs windows.

  In each frame, at any time, one and only one window is designated as
@dfn{selected within the frame}.  The frame's cursor appears in that
window.  At any time, one frame is the selected frame; and the window
selected within that frame is @dfn{the selected window}.  The selected
window's buffer is usually the current buffer (except when
@code{set-buffer} has been used).  @xref{Current Buffer}.

  For practical purposes, a window exists only while it is displayed in
a frame.  Once removed from the frame, the window is effectively deleted
and should not be used, @emph{even though there may still be references
to it} from other Lisp objects.  Restoring a saved window configuration
is the only way for a window no longer on the screen to come back to
life.  (@xref{Deleting Windows}.)

  Each window has the following attributes:

@itemize @bullet
@item
containing frame

@item
window height

@item
window width

@item
window edges with respect to the frame or screen

@item
the buffer it displays

@item
position within the buffer at the upper left of the window

@item
amount of horizontal scrolling, in columns

@item
point

@item
the mark

@item
how recently the window was selected
@end itemize

@cindex multiple windows
  Users create multiple windows so they can look at several buffers at
once.  Lisp libraries use multiple windows for a variety of reasons, but
most often to display related information.  In Rmail, for example, you
can move through a summary buffer in one window while the other window
shows messages one at a time as they are reached.

  The meaning of ``window'' in SXEmacs is similar to what it means in the
context of general-purpose window systems such as X, but not identical.
The X Window System places X windows on the screen; SXEmacs uses one or
more X windows as frames, and subdivides them into
SXEmacs windows.  When you use SXEmacs on a character-only terminal, 
SXEmacs treats the whole terminal screen as one frame.

@cindex terminal frame
@cindex frame of terminal
@cindex tiled windows
  Most window systems support arbitrarily located overlapping windows.
In contrast, SXEmacs windows are @dfn{tiled}; they never overlap, and
together they fill the whole screen or frame.  Because of the way
in which SXEmacs creates new windows and resizes them, you can't create
every conceivable tiling of windows on an SXEmacs frame.  @xref{Splitting
Windows}, and @ref{Size of Window}.

  @xref{Display}, for information on how the contents of the
window's buffer are displayed in the window.

@defun windowp object
  This function returns @code{t} if @var{object} is a window.
@end defun


@node Splitting Windows
@section Splitting Windows
@cindex splitting windows
@cindex window splitting

  The functions described here are the primitives used to split a window
into two windows.  Two higher level functions sometimes split a window,
but not always: @code{pop-to-buffer} and @code{display-buffer}
(@pxref{Displaying Buffers}).

  The functions described here do not accept a buffer as an argument.
The two ``halves'' of the split window initially display the same buffer
previously visible in the window that was split.

@defun one-window-p &optional nomini which-frames which-devices
This function returns non-@code{nil} if there is only one window.  The
argument @var{nomini}, if non-@code{nil}, means don't count the
minibuffer even if it is active; otherwise, the minibuffer window is
included, if active, in the total number of windows which is compared
against one.

The remaining arguments controls which set of windows are counted, as
with @code{next-window}.
@end defun

@deffn Command split-window &optional window size horizontal
This function splits @var{window} into two windows.  The original
window @var{window} remains the selected window, but occupies only
part of its former screen area.  The rest is occupied by a newly created
window which is returned as the value of this function.

  If @var{horizontal} is non-@code{nil}, then @var{window} splits into
two side by side windows.  The original window @var{window} keeps the
leftmost @var{size} columns, and gives the rest of the columns to the
new window.  Otherwise, it splits into windows one above the other, and
@var{window} keeps the upper @var{size} lines and gives the rest of the
lines to the new window.  The original window is therefore the
left-hand or upper of the two, and the new window is the right-hand or
lower.

  If @var{window} is omitted or @code{nil}, then the selected window is
split.  If @var{size} is omitted or @code{nil}, then @var{window} is
divided evenly into two parts.  (If there is an odd line, it is
allocated to the new window.)  When @code{split-window} is called
interactively, all its arguments are @code{nil}.

  The following example starts with one window on a frame that is 50
lines high by 80 columns wide; then the window is split.

@smallexample
@group
(setq w (selected-window))
     @result{} #<window 8 on windows.texi>
(window-edges)          ; @r{Edges in order:}
     @result{} (0 0 80 50)     ;   @r{left--top--right--bottom}
@end group

@group
;; @r{Returns window created}
(setq w2 (split-window w 15))
     @result{} #<window 28 on windows.texi>
@end group
@group
(window-edges w2)
     @result{} (0 15 80 50)    ; @r{Bottom window;}
                        ;   @r{top is line 15}
@end group
@group
(window-edges w)
     @result{} (0 0 80 15)     ; @r{Top window}
@end group
@end smallexample

The frame looks like this:

@smallexample
@group
         __________
        |          |  line 0
        |    w     |
        |__________|
        |          |  line 15
        |    w2    |
        |__________|
                      line 50
 column 0   column 80
@end group
@end smallexample

Next, the top window is split horizontally:

@smallexample
@group
(setq w3 (split-window w 35 t))
     @result{} #<window 32 on windows.texi>
@end group
@group
(window-edges w3)
     @result{} (35 0 80 15)  ; @r{Left edge at column 35}
@end group
@group
(window-edges w)
     @result{} (0 0 35 15)   ; @r{Right edge at column 35}
@end group
@group
(window-edges w2)
     @result{} (0 15 80 50)  ; @r{Bottom window unchanged}
@end group
@end smallexample

@need 3000
Now, the screen looks like this:

@smallexample
@group
     column 35
         __________
        |   |      |  line 0
        | w |  w3  |
        |___|______|
        |          |  line 15
        |    w2    |
        |__________|
                      line 50
 column 0   column 80
@end group
@end smallexample

Normally, SXEmacs indicates the border between two side-by-side windows
with a scroll bar (@pxref{X Frame Properties,Scroll Bars}) or @samp{|}
characters.  The display table can specify alternative border
characters; see @ref{Display Tables}.
@end deffn

@deffn Command split-window-vertically &optional size
This function splits the selected window into two windows, one above
the other, leaving the selected window with @var{size} lines.

This function is simply an interface to @code{split-window}.
Here is the complete function definition for it:

@smallexample
@group
(defun split-window-vertically (&optional arg)
  "Split current window into two windows, one above the other."
  (interactive "P")
  (split-window nil (and arg (prefix-numeric-value arg))))
@end group
@end smallexample
@end deffn

@deffn Command split-window-horizontally &optional size
This function splits the selected window into two windows
side-by-side, leaving the selected window with @var{size} columns.

This function is simply an interface to @code{split-window}.  Here is
the complete definition for @code{split-window-horizontally} (except for
part of the documentation string):

@smallexample
@group
(defun split-window-horizontally (&optional arg)
  "Split selected window into two windows, side by side..."
  (interactive "P")
  (split-window nil (and arg (prefix-numeric-value arg)) t))
@end group
@end smallexample
@end deffn


@node Deleting Windows
@section Deleting Windows
@cindex deleting windows

A window remains visible on its frame unless you @dfn{delete} it by
calling certain functions that delete windows.  A deleted window cannot
appear on the screen, but continues to exist as a Lisp object until
there are no references to it.  There is no way to cancel the deletion
of a window aside from restoring a saved window configuration
(@pxref{Window Configurations}).  Restoring a window configuration also
deletes any windows that aren't part of that configuration.

  When you delete a window, the space it took up is given to one
adjacent sibling.  (In Emacs version 18, the space was divided evenly
among all the siblings.)

@c Emacs 19 feature
@defun window-live-p window
This function returns @code{nil} if @var{window} is deleted, and
@code{t} otherwise.

@strong{Warning:} Erroneous information or fatal errors may result from
using a deleted window as if it were live.
@end defun

@deffn Command delete-window &optional window force
This function removes @var{window} from the display.  If @var{window} is
omitted, then the selected window is deleted. If window is the only one
on its frame, the frame is deleted as well.

Normally, you cannot delete the last non-minibuffer-only frame (you must
use @code{save-buffers-kill-emacs} or @code{kill-emacs}); an error is
signaled instead.  However, if optional second argument @var{force} is
non-@code{nil}, you can delete the last frame. (This will automatically
call @code{save-buffers-kill-emacs}.)

This function returns @code{nil}.

When @code{delete-window} is called interactively, the selected window
is deleted.
@end deffn

@deffn Command delete-other-windows &optional window
This function makes @var{window} the only window on its frame, by
deleting the other windows in that frame.  If @var{window} is omitted or
@code{nil}, then the selected window is used by default.

The result is @code{nil}.
@end deffn

@deffn Command delete-windows-on buffer &optional which-frames which-devices
This function deletes all windows showing @var{buffer}.  If there are
no windows showing @var{buffer}, it does nothing.

@code{delete-windows-on} operates frame by frame.  If a frame has
several windows showing different buffers, then those showing
@var{buffer} are removed, and the others expand to fill the space.  If
all windows in some frame are showing @var{buffer} (including the case
where there is only one window), then the frame reverts to having a
single window showing another buffer chosen with @code{other-buffer}.
@xref{The Buffer List}.

The argument @var{which-frames} controls which frames to operate on:

@table @asis
@item @code{nil}
Delete all windows showing @var{buffer} in any frame.

@item @code{t}
Delete only windows showing @var{buffer} in the selected frame.

@item @code{visible}
Delete all windows showing @var{buffer} in any visible frame.

@item @code{0}
Delete all windows showing @var{buffer} in any visible frame.

@item @var{frame}
If it is a frame, delete all windows showing @var{buffer} in that frame.
@end table

@strong{Warning:} This is similar to, but not identical to, the meaning
of the @var{which-frames} argument to @code{next-window}; the meanings
of @code{nil} and @code{t} are reversed.

The optional argument @var{which-devices} further clarifies on which
devices to search for frames as specified by @var{which-frames}.
This value is only meaningful if @var{which-frames} is not @code{t}.

@table @asis
@item @code{nil}
Consider all devices on the selected console.

@item @var{device}
Consider only the one device @var{device}.

@item @var{console}
Consider all devices on @var{console}.

@item @var{device-type}
Consider all devices with device type @var{device-type}.

@item @code{window-system}
Consider all devices on window system consoles.

@item anything else
Consider all devices without restriction.
@end table

This function always returns @code{nil}.
@end deffn


@node Selecting Windows
@section Selecting Windows
@cindex selecting windows

  When a window is selected, the buffer in the window becomes the current
buffer, and the cursor will appear in it.

@defun selected-window &optional device
This function returns the selected window.  This is the window in
which the cursor appears and to which many commands apply.  Each
separate device can have its own selected window, which is remembered
as focus changes from device to device.  Optional argument @var{device}
specifies which device to return the selected window for, and defaults
to the selected device.
@end defun

@defun select-window window &optional norecord
This function makes @var{window} the selected window.  The cursor then
appears in @var{window} (on redisplay).  The buffer being displayed in
@var{window} is immediately designated the current buffer.

If optional argument @var{norecord} is non-@code{nil} then the global
and per-frame buffer orderings are not modified, as by the function
@code{record-buffer}.

The return value is @var{window}.

@example
@group
(setq w (next-window))
(select-window w)
     @result{} #<window 65 on windows.texi>
@end group
@end example
@end defun

@defspec save-selected-window forms@dots{}
This special form records the selected window, executes @var{forms} in
sequence, then restores the earlier selected window.  It does not save
or restore anything about the sizes, arrangement or contents of windows;
therefore, if the @var{forms} change them, the changes are permanent.
@end defspec

@cindex finding windows
  The following functions choose one of the windows on the screen,
offering various criteria for the choice.

@defun get-lru-window &optional which-frames which-devices
This function returns the window least recently ``used'' (that is,
selected).  The selected window is always the most recently used window.

The selected window can be the least recently used window if it is the
only window.  A newly created window becomes the least recently used
window until it is selected.  A minibuffer window is never a candidate.

By default, only the windows in the selected frame are considered.
The optional argument @var{which-frames} changes this behavior.
Here are the possible values and their meanings:

@table @asis
@item @code{nil}
Consider all the windows in the selected windows's frame, plus the
minibuffer used by that frame even if it lies in some other frame.

@item @code{t}
Consider all windows in all existing frames.

@item @code{visible}
Consider all windows in all visible frames.  (To get useful results, you
must ensure @var{window} is in a visible frame.)

@item @code{0}
Consider all windows in all visible or iconified frames.

@item @var{frame}
Consider all windows on frame @var{frame}.

@item anything else
Consider precisely the windows in the selected window's frame, and no others.
@end table

The optional argument @var{which-devices} further clarifies on which
devices to search for frames as specified by @var{which-frames}.
This value is only meaningful if @var{which-frames} is non-@code{nil}.

@table @asis
@item @code{nil}
Consider all devices on the selected console.

@item @var{device}
Consider only the one device @var{device}.

@item @var{console}
Consider all devices on @var{console}.

@item @var{device-type}
Consider all devices with device type @var{device-type}.

@item @code{window-system}
Consider all devices on window system consoles.

@item anything else
Consider all devices without restriction.
@end table

@end defun

@defun get-largest-window &optional which-frames which-devices
This function returns the window with the largest area (height times
width).  If there are no side-by-side windows, then this is the window
with the most lines.  A minibuffer window is never a candidate.

If there are two windows of the same size, then the function returns
the window that is first in the cyclic ordering of windows (see
following section), starting from the selected window.

The remaining arguments control which set of windows are considered.
See @code{next-window}, above.
@end defun


@node Cyclic Window Ordering
@section Cyclic Ordering of Windows
@cindex cyclic ordering of windows
@cindex ordering of windows, cyclic
@cindex window ordering, cyclic

  When you use the command @kbd{C-x o} (@code{other-window}) to select
the next window, it moves through all the windows on the screen in a
specific cyclic order.  For any given configuration of windows, this
order never varies.  It is called the @dfn{cyclic ordering of windows}.

  This ordering generally goes from top to bottom, and from left to
right.  But it may go down first or go right first, depending on the
order in which the windows were split.

  If the first split was vertical (into windows one above each other),
and then the subwindows were split horizontally, then the ordering is
left to right in the top of the frame, and then left to right in the
next lower part of the frame, and so on.  If the first split was
horizontal, the ordering is top to bottom in the left part, and so on.
In general, within each set of siblings at any level in the window tree,
the order is left to right, or top to bottom.

@defun next-window &optional window minibuf which-frames which-devices
@cindex minibuffer window
This function returns the window following @var{window} in the cyclic
ordering of windows.  This is the window that @kbd{C-x o} would select
if typed when @var{window} is selected.  If @var{window} is the only
window visible, then this function returns @var{window}.  If omitted,
@var{window} defaults to the selected window.

The value of the argument @var{minibuf} determines whether the
minibuffer is included in the window order.  Normally, when
@var{minibuf} is @code{nil}, the minibuffer is included if it is
currently active; this is the behavior of @kbd{C-x o}.  (The minibuffer
window is active while the minibuffer is in use.  @xref{Minibuffers}.)

If @var{minibuf} is @code{t}, then the cyclic ordering includes the
minibuffer window even if it is not active.

If @var{minibuf} is neither @code{t} nor @code{nil}, then the minibuffer
window is not included even if it is active.

By default, only the windows in the selected frame are considered.
The optional argument @var{which-frames} changes this behavior.
Here are the possible values and their meanings:

@table @asis
@item @code{nil}
Consider all the windows in @var{window}'s frame, plus the minibuffer
used by that frame even if it lies in some other frame.

@item @code{t}
Consider all windows in all existing frames.

@item @code{visible}
Consider all windows in all visible frames.  (To get useful results, you
must ensure @var{window} is in a visible frame.)

@item @code{0}
Consider all windows in all visible or iconified frames.

@item @var{frame}
Consider all windows on frame @var{frame}.

@item anything else
Consider precisely the windows in @var{window}'s frame, and no others.
@end table

The optional argument @var{which-devices} further clarifies on which
devices to search for frames as specified by @var{which-frames}.
This value is only meaningful if @var{which-frames} is non-@code{nil}.

@table @asis
@item @code{nil}
Consider all devices on the selected console.

@item @var{device}
Consider only the one device @var{device}.

@item @var{console}
Consider all devices on @var{console}.

@item @var{device-type}
Consider all devices with device type @var{device-type}.

@item @code{window-system}
Consider all devices on window system consoles.

@item anything else
Consider all devices without restriction.
@end table

If you use consistent values for @var{minibuf}, @var{which-frames}, and
@var{which-devices}, you can use @code{next-window} to iterate through the
entire cycle of acceptable windows, eventually ending up back at the
window you started with.  @code{previous-window} traverses the same
cycle, in the reverse order.

This example assumes there are two windows, both displaying the
buffer @samp{windows.texi}:

@example
@group
(selected-window)
     @result{} #<window 56 on windows.texi>
@end group
@group
(next-window (selected-window))
     @result{} #<window 52 on windows.texi>
@end group
@group
(next-window (next-window (selected-window)))
     @result{} #<window 56 on windows.texi>
@end group
@end example
@end defun

@defun previous-window &optional window minibuf which-frames which-devices
This function returns the window preceding @var{window} in the cyclic
ordering of windows.  The other arguments specify which windows to
include in the cycle, as in @code{next-window}.
@end defun

@deffn Command other-window count &optional which-frames which-devices
This function selects the @var{count}th following window in the cyclic order.
If @var{count} is negative, then it selects the @minus{}@var{count}th
preceding window.  It returns @code{nil}.

In an interactive call, @var{count} is the numeric prefix argument.

The other arguments specify which windows to include in the cycle, as in
@code{next-window}.
@end deffn

@defun walk-windows function &optional minibuf which-frames which-devices
This function cycles through all windows, calling @code{function}
once for each window with the window as its sole argument.

The other arguments specify which windows to cycle through, as in
@code{next-window}.
@end defun


@node Buffers and Windows
@section Buffers and Windows
@cindex examining windows
@cindex windows, controlling precisely
@cindex buffers, controlled in windows

  This section describes low-level functions to examine windows or to
display buffers in windows in a precisely controlled fashion.
@iftex
See the following section for
@end iftex
@ifinfo
@xref{Displaying Buffers}, for
@end ifinfo
related functions that find a window to use and specify a buffer for it.
The functions described there are easier to use than these, but they
employ heuristics in choosing or creating a window; use these functions
when you need complete control.

@defun set-window-buffer window buffer-or-name &optional norecord
This function makes @var{window} display @var{buffer-or-name} as its
contents.  @var{buffer-or-name} can be a buffer or a buffer name.

With non-@code{nil} optional argument @var{norecord}, do not modify the
global or per-frame buffer ordering.

This function returns @code{nil}.

@example
@group
(set-window-buffer (selected-window) "foo")
     @result{} nil
@end group
@end example
@end defun

@defun window-buffer &optional window
This function returns the buffer that @var{window} is displaying.  If
@var{window} is omitted, this function returns the buffer for the
selected window.

@example
@group
(window-buffer)
     @result{} #<buffer windows.texi>
@end group
@end example
@end defun

@defun get-buffer-window buffer-or-name &optional which-frames which-devices
This function returns a window currently displaying
@var{buffer-or-name}, or @code{nil} if there is none.  If there are
several such windows, then the function returns the first one in the
cyclic ordering of windows, starting from the selected window.
@xref{Cyclic Window Ordering}.

The remaining arguments control which windows to consider.  They have
the same meaning as for @code{next-window}.
@end defun


@node Displaying Buffers
@section Displaying Buffers in Windows
@cindex switching to a buffer
@cindex displaying a buffer

  In this section we describe convenient functions that choose a window
automatically and use it to display a specified buffer.  These functions
can also split an existing window in certain circumstances.  We also
describe variables that parameterize the heuristics used for choosing a
window.
@iftex
See the preceding section for
@end iftex
@ifinfo
@xref{Buffers and Windows}, for
@end ifinfo
low-level functions that give you more precise control.

  Do not use the functions in this section in order to make a buffer
current so that a Lisp program can access or modify it; they are too
drastic for that purpose, since they change the display of buffers in
windows, which is gratuitous and will surprise the user.  Instead, use
@code{set-buffer} (@pxref{Current Buffer}) and @code{save-excursion}
(@pxref{Excursions}), which designate buffers as current for programmed
access without affecting the display of buffers in windows.

@deffn Command switch-to-buffer buffer-or-name &optional norecord
This function makes @var{buffer-or-name} the current buffer, and also
displays the buffer in the selected window.  This means that a human can
see the buffer and subsequent keyboard commands will apply to it.
Contrast this with @code{set-buffer}, which makes @var{buffer-or-name}
the current buffer but does not display it in the selected window.
@xref{Current Buffer}.

If @var{buffer-or-name} does not identify an existing buffer, then a new
buffer by that name is created.  The major mode for the new buffer is
set according to the variable @code{default-major-mode}.  @xref{Auto
Major Mode}.

Normally the specified buffer is put at the front of the buffer list.
This affects the operation of @code{other-buffer}.  However, if
@var{norecord} is non-@code{nil}, this is not done.  @xref{The Buffer
List}.

The @code{switch-to-buffer} function is often used interactively, as
the binding of @kbd{C-x b}.  It is also used frequently in programs.  It
always returns @code{nil}.
@end deffn

@deffn Command switch-to-buffer-other-window buffer-or-name
This function makes @var{buffer-or-name} the current buffer and
displays it in a window not currently selected.  It then selects that
window.  The handling of the buffer is the same as in
@code{switch-to-buffer}.

The currently selected window is absolutely never used to do the job.
If it is the only window, then it is split to make a distinct window for
this purpose.  If the selected window is already displaying the buffer,
then it continues to do so, but another window is nonetheless found to
display it in as well.
@end deffn

@defun pop-to-buffer buffer-or-name &optional other-window on-frame
This function makes @var{buffer-or-name} the current buffer and
switches to it in some window, preferably not the window previously
selected.  The ``popped-to'' window becomes the selected window within
its frame.

If the variable @code{pop-up-frames} is non-@code{nil},
@code{pop-to-buffer} looks for a window in any visible frame already
displaying the buffer; if there is one, it returns that window and makes
it be selected within its frame.  If there is none, it creates a new
frame and displays the buffer in it.

If @code{pop-up-frames} is @code{nil}, then @code{pop-to-buffer}
operates entirely within the selected frame.  (If the selected frame has
just a minibuffer, @code{pop-to-buffer} operates within the most
recently selected frame that was not just a minibuffer.)

If the variable @code{pop-up-windows} is non-@code{nil}, windows may
be split to create a new window that is different from the original
window.  For details, see @ref{Choosing Window}.

If @var{other-window} is non-@code{nil}, @code{pop-to-buffer} finds or
creates another window even if @var{buffer-or-name} is already visible
in the selected window.  Thus @var{buffer-or-name} could end up
displayed in two windows.  On the other hand, if @var{buffer-or-name} is
already displayed in the selected window and @var{other-window} is
@code{nil}, then the selected window is considered sufficient display
for @var{buffer-or-name}, so that nothing needs to be done.

All the variables that affect @code{display-buffer} affect
@code{pop-to-buffer} as well.  @xref{Choosing Window}.

If @var{buffer-or-name} is a string that does not name an existing
buffer, a buffer by that name is created.  The major mode for the new
buffer is set according to the variable @code{default-major-mode}.
@xref{Auto Major Mode}.

  If @var{on-frame} is non-@code{nil}, it is the frame to pop to this
buffer on.

  An example use of this function is found at the end of @ref{Filter
Functions}.
@end defun

@deffn Command replace-buffer-in-windows buffer &optional which-frames which-devices
This function replaces @var{buffer} with some other buffer in all
windows displaying it.  The other buffer used is chosen with
@code{other-buffer}.  In the usual applications of this function, you
don't care which other buffer is used; you just want to make sure that
@var{buffer} is no longer displayed.

The optional arguments @var{which-frames} and @var{which-devices} have
the same meaning as with @code{delete-windows-on}.

This function returns @code{nil}.
@end deffn


@node Choosing Window
@section Choosing a Window for Display

  This section describes the basic facility that chooses a window to
display a buffer in---@code{display-buffer}.  All the higher-level
functions and commands use this subroutine.  Here we describe how to use
@code{display-buffer} and how to customize it.

@deffn Command display-buffer buffer-or-name &optional not-this-window override-frame
This command makes @var{buffer-or-name} appear in some window, like
@code{pop-to-buffer}, but it does not select that window and does not
make the buffer current.  The identity of the selected window is
unaltered by this function.

@var{buffer-or-name} can be a buffer or the name of one.

If @var{not-this-window} is non-@code{nil}, it means to display the
specified buffer in a window other than the selected one, even if it is
already on display in the selected window.  This can cause the buffer to
appear in two windows at once.  Otherwise, if @var{buffer-or-name} is
already being displayed in any window, that is good enough, so this
function does nothing.

If @var{override-frame} is non-@code{nil}, display on that frame instead
of the current frame (or the dedicated frame).

@code{display-buffer} returns the window chosen to display @var{buffer-or-name}.

Precisely how @code{display-buffer} finds or creates a window depends on
the variables described below.
@end deffn

@c Emacs 19 feature
@cindex dedicated window
A window can be marked as ``dedicated'' to a particular buffer.
Then SXEmacs will not automatically change which buffer appears in the
window, such as @code{display-buffer} might normally do.

@defun window-dedicated-p window
This function returns @var{window}'s dedicated object, usually @code{t}
or @code{nil}.
@end defun

@defun set-window-buffer-dedicated window buffer
This function makes @var{window} display @var{buffer} and be dedicated
to that buffer.  Then SXEmacs will not automatically change which buffer
appears in @var{window}.  If @var{buffer} is @code{nil}, this function makes
@var{window} not be dedicated (but doesn't change which buffer appears
in it currently).
@end defun

@defopt pop-up-windows
This variable controls whether @code{display-buffer} makes new windows.
If it is non-@code{nil} and there is only one window, then that window
is split.  If it is @code{nil}, then @code{display-buffer} does not
split the single window, but uses it whole.
@end defopt

@defopt split-height-threshold
This variable determines when @code{display-buffer} may split a window,
if there are multiple windows.  @code{display-buffer} always splits the
largest window if it has at least this many lines.  If the largest
window is not this tall, it is split only if it is the sole window and
@code{pop-up-windows} is non-@code{nil}.
@end defopt

@c Emacs 19 feature
@defopt pop-up-frames
This variable controls whether @code{display-buffer} makes new frames.
If it is non-@code{nil}, @code{display-buffer} looks for an existing
window already displaying the desired buffer, on any visible frame.  If
it finds one, it returns that window.  Otherwise it makes a new frame.
The variables @code{pop-up-windows} and @code{split-height-threshold} do
not matter if @code{pop-up-frames} is non-@code{nil}.

If @code{pop-up-frames} is @code{nil}, then @code{display-buffer} either
splits a window or reuses one.

@xref{Frames}, for more information.
@end defopt

@c Emacs 19 feature
@defvar pop-up-frame-function
This variable specifies how to make a new frame if @code{pop-up-frames}
is non-@code{nil}.

Its value should be a function of no arguments.  When
@code{display-buffer} makes a new frame, it does so by calling that
function, which should return a frame.  The default value of the
variable is a function that creates a frame using properties from
@code{pop-up-frame-plist}.
@end defvar

@defvar pop-up-frame-plist
This variable holds a plist specifying frame properties used when
@code{display-buffer} makes a new frame.  @xref{Frame Properties}, for
more information about frame properties.
@end defvar

@defvar special-display-buffer-names
A list of buffer names for buffers that should be displayed specially.
If the buffer's name is in this list, @code{display-buffer} handles the
buffer specially.

By default, special display means to give the buffer a dedicated frame.

If an element is a list, instead of a string, then the @sc{car} of the
list is the buffer name, and the rest of the list says how to create the
frame.  There are two possibilities for the rest of the list.  It can be
a plist, specifying frame properties, or it can contain a function and
arguments to give to it.  (The function's first argument is always the
buffer to be displayed; the arguments from the list come after that.)
@end defvar

@defvar special-display-regexps
A list of regular expressions that specify buffers that should be
displayed specially.  If the buffer's name matches any of the regular
expressions in this list, @code{display-buffer} handles the buffer
specially.

By default, special display means to give the buffer a dedicated frame.

If an element is a list, instead of a string, then the @sc{car} of the
list is the regular expression, and the rest of the list says how to
create the frame.  See above, under @code{special-display-buffer-names}.
@end defvar

@defvar special-display-function
This variable holds the function to call to display a buffer specially.
It receives the buffer as an argument, and should return the window in
which it is displayed.

The default value of this variable is
@code{special-display-popup-frame}.
@end defvar

@defun special-display-popup-frame buffer
This function makes @var{buffer} visible in a frame of its own.  If
@var{buffer} is already displayed in a window in some frame, it makes
the frame visible and raises it, to use that window.  Otherwise, it
creates a frame that will be dedicated to @var{buffer}.

This function uses an existing window displaying @var{buffer} whether or
not it is in a frame of its own; but if you set up the above variables
in your init file, before @var{buffer} was created, then presumably the
window was previously made by this function.
@end defun

@defopt special-display-frame-plist
This variable holds frame properties for
@code{special-display-popup-frame} to use when it creates a frame.
@end defopt

@defvar same-window-buffer-names
A list of buffer names for buffers that should be displayed in the
selected window.  If the buffer's name is in this list,
@code{display-buffer} handles the buffer by switching to it in the
selected window.
@end defvar

@defvar same-window-regexps
A list of regular expressions that specify buffers that should be
displayed in the selected window.  If the buffer's name matches any of
the regular expressions in this list, @code{display-buffer} handles the
buffer by switching to it in the selected window.
@end defvar

@c Emacs 19 feature
@defvar display-buffer-function
This variable is the most flexible way to customize the behavior of
@code{display-buffer}.  If it is non-@code{nil}, it should be a function
that @code{display-buffer} calls to do the work.  The function should
accept two arguments, the same two arguments that @code{display-buffer}
received.  It should choose or create a window, display the specified
buffer, and then return the window.

This hook takes precedence over all the other options and hooks
described above.
@end defvar

@c Emacs 19 feature
@cindex dedicated window
A window can be marked as ``dedicated'' to its buffer.  Then
@code{display-buffer} does not try to use that window.

@defun window-dedicated-p window
This function returns @code{t} if @var{window} is marked as dedicated;
otherwise @code{nil}.
@end defun

@defun set-window-dedicated-p window flag
This function marks @var{window} as dedicated if @var{flag} is
non-@code{nil}, and nondedicated otherwise.
@end defun


@node Window Point
@section Windows and Point
@cindex window position
@cindex window point
@cindex position in window
@cindex point in window

  Each window has its own value of point, independent of the value of
point in other windows displaying the same buffer.  This makes it useful
to have multiple windows showing one buffer.

@itemize @bullet
@item
The window point is established when a window is first created; it is
initialized from the buffer's point, or from the window point of another
window opened on the buffer if such a window exists.

@item
Selecting a window sets the value of point in its buffer to the window's
value of point.  Conversely, deselecting a window sets the window's
value of point from that of the buffer.  Thus, when you switch between
windows that display a given buffer, the point value for the selected
window is in effect in the buffer, while the point values for the other
windows are stored in those windows.

@item
As long as the selected window displays the current buffer, the window's
point and the buffer's point always move together; they remain equal.

@item
@xref{Positions}, for more details on buffer positions.
@end itemize

  As far as the user is concerned, point is where the cursor is, and
when the user switches to another buffer, the cursor jumps to the
position of point in that buffer.

@defun window-point &optional window
This function returns the current position of point in @var{window}.
For a non-selected window, this is the value point would have (in that
window's buffer) if that window were selected.

When @var{window} is the selected window and its buffer is also the
current buffer, the value returned is the same as the value of point in
that buffer.

Strictly speaking, it would be more correct to return the
``top-level'' value of point, outside of any @code{save-excursion}
forms.  But that value is hard to find.
@end defun

@defun set-window-point window position
This function positions point in @var{window} at position
@var{position} in @var{window}'s buffer.
@end defun


@node Window Start
@section The Window Start Position

  Each window contains a marker used to keep track of a buffer position
that specifies where in the buffer display should start.  This position
is called the @dfn{display-start} position of the window (or just the
@dfn{start}).  The character after this position is the one that appears
at the upper left corner of the window.  It is usually, but not
inevitably, at the beginning of a text line.

@defun window-start &optional window
@cindex window top line
This function returns the display-start position of window
@var{window}.  If @var{window} is @code{nil}, the selected window is
used.  For example,

@example
@group
(window-start)
     @result{} 7058
@end group
@end example

When you create a window, or display a different buffer in it, the
display-start position is set to a display-start position recently used
for the same buffer, or 1 if the buffer doesn't have any.

For a realistic example, see the description of @code{count-lines} in
@ref{Text Lines}.
@end defun

@defun window-end &optional window guarantee
This function returns the position of the end of the display in window
@var{window}.  If @var{window} is @code{nil}, the selected window is
used.

Simply changing the buffer text or setting @code{window-start} does not
update the value that @code{window-end} returns.  The value is updated
only when SXEmacs redisplays and redisplay actually finishes.

If the last redisplay of @var{window} was preempted, and did not finish,
SXEmacs does not know the position of the end of display in that window.
In that case, this function returns a value that is not correct.  In a
future version, @code{window-end} will return @code{nil} in that case.

If optional arg @var{guarantee} is non-@code{nil}, the return value is
guaranteed to be the same as @code{window-end} would return at the end
of the next full redisplay assuming nothing else changes in the
meantime.  This function is potentially much slower with this flag set.

@ignore
in that case, this function returns @code{nil}.  You can compute where
the end of the window @emph{would} have been, if redisplay had finished,
like this:

@example
(save-excursion
  (goto-char (window-start window))
  (vertical-motion (1- (window-height window))
                   window)
  (point))
@end example
@end ignore
@end defun

@defun set-window-start window position &optional noforce
This function sets the display-start position of @var{window} to
@var{position} in @var{window}'s buffer.  It returns @var{position}.

The display routines insist that the position of point be visible when a
buffer is displayed.  Normally, they change the display-start position
(that is, scroll the window) whenever necessary to make point visible.
However, if you specify the start position with this function using
@code{nil} for @var{noforce}, it means you want display to start at
@var{position} even if that would put the location of point off the
screen.  If this does place point off screen, the display routines move
point to the left margin on the middle line in the window.

For example, if point @w{is 1} and you set the start of the window @w{to
2}, then point would be ``above'' the top of the window.  The display
routines will automatically move point if it is still 1 when redisplay
occurs.  Here is an example:

@example
@group
;; @r{Here is what @samp{foo} looks like before executing}
;;   @r{the @code{set-window-start} expression.}
@end group

@group
---------- Buffer: foo ----------
@point{}This is the contents of buffer foo.
2
3
4
5
6
---------- Buffer: foo ----------
@end group

@group
(set-window-start
 (selected-window)
 (1+ (window-start)))
@result{} 2
@end group

@group
;; @r{Here is what @samp{foo} looks like after executing}
;;   @r{the @code{set-window-start} expression.}
---------- Buffer: foo ----------
his is the contents of buffer foo.
2
3
@point{}4
5
6
---------- Buffer: foo ----------
@end group
@end example

If @var{noforce} is non-@code{nil}, and @var{position} would place point
off screen at the next redisplay, then redisplay computes a new window-start
position that works well with point, and thus @var{position} is not used.
@end defun

@defun pos-visible-in-window-p &optional position window
This function returns @code{t} if @var{position} is within the range
of text currently visible on the screen in @var{window}.  It returns
@code{nil} if @var{position} is scrolled vertically out of view.  The
argument @var{position} defaults to the current position of point;
@var{window}, to the selected window.  Here is an example:

@example
@group
(or (pos-visible-in-window-p
     (point) (selected-window))
    (recenter 0))
@end group
@end example

The @code{pos-visible-in-window-p} function considers only vertical
scrolling.  If @var{position} is out of view only because @var{window}
has been scrolled horizontally, @code{pos-visible-in-window-p} returns
@code{t}.  @xref{Horizontal Scrolling}.
@end defun


@node Vertical Scrolling
@section Vertical Scrolling
@cindex vertical scrolling
@cindex scrolling vertically

  Vertical scrolling means moving the text up or down in a window.  It
works by changing the value of the window's display-start location.  It
may also change the value of @code{window-point} to keep it on the
screen.

  In the commands @code{scroll-up} and @code{scroll-down}, the directions
``up'' and ``down'' refer to the motion of the text in the buffer at which
you are looking through the window.  Imagine that the text is
written on a long roll of paper and that the scrolling commands move the
paper up and down.  Thus, if you are looking at text in the middle of a
buffer and repeatedly call @code{scroll-down}, you will eventually see
the beginning of the buffer.

  Some people have urged that the opposite convention be used: they
imagine that the window moves over text that remains in place.  Then
``down'' commands would take you to the end of the buffer.  This view is
more consistent with the actual relationship between windows and the
text in the buffer, but it is less like what the user sees.  The
position of a window on the terminal does not move, and short scrolling
commands clearly move the text up or down on the screen.  We have chosen
names that fit the user's point of view.

  The scrolling functions (aside from @code{scroll-other-window}) have
unpredictable results if the current buffer is different from the buffer
that is displayed in the selected window.  @xref{Current Buffer}.

@deffn Command scroll-up &optional lines
This function scrolls the text in the selected window upward
@var{lines} lines.  If @var{lines} is negative, scrolling is actually
downward.

If @var{lines} is @code{nil} (or omitted), then the length of scroll
is @code{next-screen-context-lines} lines less than the usable height of
the window (not counting its modeline).

@code{scroll-up} returns @code{nil}.
@end deffn

@deffn Command scroll-down &optional lines
This function scrolls the text in the selected window downward
@var{lines} lines.  If @var{lines} is negative, scrolling is actually
upward.

If @var{lines} is omitted or @code{nil}, then the length of the scroll
is @code{next-screen-context-lines} lines less than the usable height of
the window (not counting its mode line).

@code{scroll-down} returns @code{nil}.
@end deffn

@deffn Command scroll-other-window &optional lines
This function scrolls the text in another window upward @var{lines}
lines.  Negative values of @var{lines}, or @code{nil}, are handled
as in @code{scroll-up}.

You can specify a buffer to scroll with the variable
@code{other-window-scroll-buffer}.  When the selected window is the
minibuffer, the next window is normally the one at the top left corner.
You can specify a different window to scroll with the variable
@code{minibuffer-scroll-window}.  This variable has no effect when any
other window is selected.  @xref{Minibuffer Misc}.

When the minibuffer is active, it is the next window if the selected
window is the one at the bottom right corner.  In this case,
@code{scroll-other-window} attempts to scroll the minibuffer.  If the
minibuffer contains just one line, it has nowhere to scroll to, so the
line reappears after the echo area momentarily displays the message
``Beginning of buffer''.
@end deffn

@c Emacs 19 feature
@defvar other-window-scroll-buffer
If this variable is non-@code{nil}, it tells @code{scroll-other-window}
which buffer to scroll.
@end defvar

@defopt scroll-step
This variable controls how scrolling is done automatically when point
moves off the screen.  If the value is zero, then redisplay scrolls the
text to center point vertically in the window.  If the value is a
positive integer @var{n}, then redisplay brings point back on screen by
scrolling @var{n} lines in either direction, if possible; otherwise, it
centers point.  The default value is zero.
@end defopt

@defopt scroll-conservatively
This variable controls how many lines SXEmacs tries to scroll before
recentering.  If you set it to a small number, then when you move point
a short distance off the screen, SXEmacs will scroll the screen just far
enough to bring point back on screen, provided that does not exceed
@code{scroll-conservatively} lines.  This variable overrides the
redisplay preemption.
@end defopt

@defopt next-screen-context-lines
The value of this variable is the number of lines of continuity to
retain when scrolling by full screens.  For example, @code{scroll-up}
with an argument of @code{nil} scrolls so that this many lines at the
bottom of the window appear instead at the top.  The default value is
@code{2}.
@end defopt

@deffn Command recenter &optional location window
@cindex centering point
This function scrolls @var{window} (which defaults to the selected
window) to put the text where point is located at a specified vertical
position within the window.

If @var{location} is a nonnegative number, it puts the line containing
point @var{location} lines down from the top of the window.  If @var{location}
is a negative number, then it counts upward from the bottom of the
window, so that @minus{}1 stands for the last usable line in the window.
If @var{location} is a non-@code{nil} list, then it stands for the line in
the middle of the window.

If @var{location} is @code{nil}, @code{recenter} puts the line containing
point in the middle of the window, then clears and redisplays the entire
selected frame.

When @code{recenter} is called interactively, @var{location} is the raw
prefix argument.  Thus, typing @kbd{C-u} as the prefix sets the
@var{location} to a non-@code{nil} list, while typing @kbd{C-u 4} sets
@var{location} to 4, which positions the current line four lines from the
top.

With an argument of zero, @code{recenter} positions the current line at
the top of the window.  This action is so handy that some people make a
separate key binding to do this.  For example,

@example
@group
(defun line-to-top-of-window ()
  "Scroll current line to top of window.
Replaces three keystroke sequence C-u 0 C-l."
  (interactive)
  (recenter 0))

(global-set-key [kp-multiply] 'line-to-top-of-window)
@end group
@end example
@end deffn


@node Horizontal Scrolling
@section Horizontal Scrolling
@cindex horizontal scrolling

  Because we read English first from top to bottom and second from left
to right, horizontal scrolling is not like vertical scrolling.  Vertical
scrolling involves selection of a contiguous portion of text to display.
Horizontal scrolling causes part of each line to go off screen.  The
amount of horizontal scrolling is therefore specified as a number of
columns rather than as a position in the buffer.  It has nothing to do
with the display-start position returned by @code{window-start}.

  Usually, no horizontal scrolling is in effect; then the leftmost
column is at the left edge of the window.  In this state, scrolling to
the right is meaningless, since there is no data to the left of the
screen to be revealed by it; so this is not allowed.  Scrolling to the
left is allowed; it scrolls the first columns of text off the edge of
the window and can reveal additional columns on the right that were
truncated before.  Once a window has a nonzero amount of leftward
horizontal scrolling, you can scroll it back to the right, but only so
far as to reduce the net horizontal scroll to zero.  There is no limit
to how far left you can scroll, but eventually all the text will
disappear off the left edge.

@deffn Command scroll-left &optional count
This function scrolls the selected window @var{count} columns to the
left (or to the right if @var{count} is negative).  The return value is
the total amount of leftward horizontal scrolling in effect after the
change---just like the value returned by @code{window-hscroll} (below).
@end deffn

@deffn Command scroll-right &optional count
This function scrolls the selected window @var{count} columns to the
right (or to the left if @var{count} is negative).  The return value is
the total amount of leftward horizontal scrolling in effect after the
change---just like the value returned by @code{window-hscroll} (below).

Once you scroll a window as far right as it can go, back to its normal
position where the total leftward scrolling is zero, attempts to scroll
any farther right have no effect.
@end deffn

@defun window-hscroll &optional window
This function returns the total leftward horizontal scrolling of
@var{window}---the number of columns by which the text in @var{window}
is scrolled left past the left margin.

The value is never negative.  It is zero when no horizontal scrolling
has been done in @var{window} (which is usually the case).

If @var{window} is @code{nil}, the selected window is used.

@example
@group
(window-hscroll)
     @result{} 0
@end group
@group
(scroll-left 5)
     @result{} 5
@end group
@group
(window-hscroll)
     @result{} 5
@end group
@end example
@end defun

@defun set-window-hscroll window columns
This function sets the number of columns from the left margin that
@var{window} is scrolled to the value of @var{columns}.  The argument
@var{columns} should be zero or positive; if not, it is taken as zero.

The value returned is @var{columns}.

@example
@group
(set-window-hscroll (selected-window) 10)
     @result{} 10
@end group
@end example
@end defun

  Here is how you can determine whether a given position @var{position}
is off the screen due to horizontal scrolling:

@example
@group
(defun hscroll-on-screen (window position)
  (save-excursion
    (goto-char position)
    (and
     (>= (- (current-column) (window-hscroll window)) 0)
     (< (- (current-column) (window-hscroll window))
        (window-width window)))))
@end group
@end example


@node Size of Window
@section The Size of a Window
@cindex window size
@cindex size of window

A SXEmacs window is rectangular, and its size information consists of
the height (in lines or pixels) and the width (in character positions
or pixels).  The modeline is included in the height.  The pixel
width and height values include scrollbars and margins, while the
line/character-position values do not.

Note that the height in lines, and the width in characters, are
determined by dividing the corresponding pixel value by the height or
width of the default font in that window (if this is a variable-width
font, the average width is used).  The resulting values may or may not
represent the actual number of lines in the window, or the actual number
of character positions in any particular line, esp. if there are pixmaps
or various different fonts in the window.

  The following functions return size information about a window:

@defun window-height &optional window
This function returns the number of lines in @var{window}, including
its modeline but not including the horizontal scrollbar, if any (this
is different from @code{window-pixel-height}).  If @var{window} is
@code{nil}, the function uses the selected window.

@example
@group
(window-height)
     @result{} 40
@end group
@group
(split-window-vertically)
     @result{} #<window on "windows.texi" 0x679b>
@end group
@group
(window-height)
     @result{} 20
@end group
@end example
@end defun

@defun window-width &optional window
This function returns the number of columns in @var{window}, not
including any left margin, right margin, or vertical scrollbar (this is
different from @code{window-pixel-width}).  If @var{window} is
@code{nil}, the function uses the selected window.

@example
@group
(window-width)
     @result{} 80
@end group
@group
(window-height)
     @result{} 40
@end group
@group
(split-window-horizontally)
     @result{} #<window on "windows.texi" 0x7538>
@end group
@group
(window-width)
     @result{} 39
@end group
@end example
@end defun

Note that after splitting the window into two side-by-side windows,
the width of each window is less the half the width of the original
window because a vertical scrollbar appeared between the windows,
occupying two columns worth of space.  Also, the height shrunk by
one because horizontal scrollbars appeared that weren't there
before. (Horizontal scrollbars appear only when lines are
truncated, not when they wrap.  This is usually the case for
horizontally split windows but not for full-frame windows.  You
can change this using the variables @code{truncate-lines} and
@code{truncate-partial-width-windows}.)

@defun window-pixel-height &optional window
This function returns the height of @var{window} in pixels, including
its modeline and horizontal scrollbar, if any.  If @var{window} is
@code{nil}, the function uses the selected window.

@example
@group
(window-pixel-height)
     @result{} 600
@end group
@group
(split-window-vertically)
     @result{} #<window on "windows.texi" 0x68a6>
@end group
@group
(window-pixel-height)
     @result{} 300
@end group
@end example
@end defun

@defun window-pixel-width &optional window
  This function returns the width of @var{window} in pixels, including
any left margin, right margin, or vertical scrollbar that may be
displayed alongside it.  If @var{window} is @code{nil}, the function
uses the selected window.

@example
@group
(window-pixel-width)
     @result{} 735
@end group
@group
(window-pixel-height)
     @result{} 600
@end group
@group
(split-window-horizontally)
     @result{} #<window on "windows.texi" 0x7538>
@end group
@group
(window-pixel-width)
     @result{} 367
@end group
@group
(window-pixel-height)
     @result{} 600
@end group
@end example
@end defun

@defun window-text-area-pixel-height &optional window
This function returns the height in pixels of the text displaying
portion of @var{window}, which defaults to the selected window.  Unlike
@code{window-pixel-height}, the space occupied by the modeline and
horizontal scrollbar, if any, is not counted.
@end defun

@defun window-text-area-pixel-width &optional window
This function returns the width in pixels of the text displaying
portion of @var{window}, which defaults to the selected window.  Unlike
@code{window-pixel-width}, the space occupied by the vertical scrollbar
and divider, if any, is not counted.
@end defun

@defun window-displayed-text-pixel-height &optional window noclipped
This function returns the height in pixels of the text displayed in
@var{window}, which defaults to the selected window.  Unlike
@code{window-text-area-pixel-height}, any blank space below the
end of the buffer is not included.  If optional argument @var{noclipped}
is non-@code{nil}, any space occupied by clipped lines will not be
included.
@end defun


@node Position of Window
@section The Position of a Window
@cindex window position
@cindex position of window

SXEmacs provides functions to determine the absolute location of windows
within a frame, and the relative location of a window in comparison to
other windows in the same frame.

@defun window-pixel-edges &optional window
  This function returns a list of the pixel edge coordinates of
@var{window}.  If @var{window} is @code{nil}, the selected window is
used.

  The order of the list is @code{(@var{left} @var{top} @var{right}
@var{bottom})}, all elements relative to 0, 0 at the top left corner of
@var{window}'s frame.  The element @var{right} of the value is one more
than the rightmost pixel used by @var{window} (including any left
margin, right margin, or vertical scrollbar displayed alongside it), and
@var{bottom} is one more than the bottommost pixel used by @var{window}
(including any modeline or horizontal scrollbar displayed above or below
it).  The frame area does not include any frame menubars, toolbars, or
gutters that may be displayed; thus, for example, if there is only one
window on the frame, the values for @var{left} and @var{top} will always
be 0.

  If @var{window} is at the upper left corner of its frame, @var{right}
and @var{bottom} are the same as the values returned by
@code{(window-pixel-width)} and @code{(window-pixel-height)}
respectively, and @var{left} and @var{top} are zero.
@end defun

  There is no longer a function @code{window-edges} because it does not
make sense in a world with variable-width and variable-height lines,
as are allowed in SXEmacs.

@defun window-highest-p window
  This function returns non-@code{nil} if @var{window} is along the
top of its frame.
@end defun

@defun window-lowest-p window
  This function returns non-@code{nil} if @var{window} is along the
bottom of its frame.
@end defun

@defun window-text-area-pixel-edges &optional window
This function allows one to determine the location of the
text-displaying portion of @var{window}, which defaults to the selected
window, with respect to the top left corner of the window.  It returns
a list of integer pixel positions @code{(left top right bottom)}, all
relative to @code{(0,0)} at the top left corner of the window.
@end defun


@node Resizing Windows
@section Changing the Size of a Window
@cindex window resizing
@cindex changing window size
@cindex window size, changing

  The window size functions fall into two classes: high-level commands
that change the size of windows and low-level functions that access
window size.  SXEmacs does not permit overlapping windows or gaps between
windows, so resizing one window affects other windows.

@deffn Command enlarge-window count &optional horizontal window
This function makes the selected window @var{count} lines taller,
stealing lines from neighboring windows.  It takes the lines from one
window at a time until that window is used up, then takes from another.
If a window from which lines are stolen shrinks below
@code{window-min-height} lines, that window disappears.

If @var{horizontal} is non-@code{nil}, this function makes
@var{window} wider by @var{count} columns, stealing columns instead of
lines.  If a window from which columns are stolen shrinks below
@code{window-min-width} columns, that window disappears.

If the requested size would exceed that of the window's frame, then the
function makes the window occupy the entire height (or width) of the
frame.

If @var{count} is negative, this function shrinks the window by
@minus{}@var{count} lines or columns.  If that makes the window smaller
than the minimum size (@code{window-min-height} and
@code{window-min-width}), @code{enlarge-window} deletes the window.

If @var{window} is non-@code{nil}, it specifies a window to change
instead of the selected window.

@code{enlarge-window} returns @code{nil}.
@end deffn

@deffn Command enlarge-window-horizontally columns
This function makes the selected window @var{columns} wider.
It could be defined as follows:

@example
@group
(defun enlarge-window-horizontally (columns)
  (enlarge-window columns t))
@end group
@end example
@end deffn

@deffn Command enlarge-window-pixels count &optional side window
This function makes the selected window @var{count} pixels larger.  
When called from Lisp, optional second argument @var{side}
non-@code{nil} means to grow sideways @var{count} pixels, and optional
third argument @var{window} specifies the window to change instead of
the selected window.
@end deffn

@deffn Command shrink-window count &optional horizontal window
This function is like @code{enlarge-window} but negates the argument
@var{count}, making the selected window smaller by giving lines (or
columns) to the other windows.  If the window shrinks below
@code{window-min-height} or @code{window-min-width}, then it disappears.

If @var{count} is negative, the window is enlarged by @minus{}@var{count}
lines or columns.

If @var{window} is non-@code{nil}, it specifies a window to change
instead of the selected window.
@end deffn

@deffn Command shrink-window-horizontally columns
This function makes the selected window @var{columns} narrower.
It could be defined as follows:

@example
@group
(defun shrink-window-horizontally (columns)
  (shrink-window columns t))
@end group
@end example
@end deffn

@deffn Command shrink-window-pixels count &optional side window
This function makes the selected window @var{count} pixels smaller.
When called from Lisp, optional second argument @var{side}
non-@code{nil} means to shrink sideways @var{count} pixels, and optional
third argument @var{window} specifies the window to change instead of
the selected window.
@end deffn

@cindex minimum window size
  The following two variables constrain the window-size-changing
functions to a minimum height and width.

@defopt window-min-height
The value of this variable determines how short a window may become
before it is automatically deleted.  Making a window smaller than
@code{window-min-height} automatically deletes it, and no window may be
created shorter than this.  The absolute minimum height is two (allowing
one line for the mode line, and one line for the buffer display).
Actions that change window sizes reset this variable to two if it is
less than two.  The default value is 4.
@end defopt

@defopt window-min-width
The value of this variable determines how narrow a window may become
before it automatically deleted.  Making a window smaller than
@code{window-min-width} automatically deletes it, and no window may be
created narrower than this.  The absolute minimum width is one; any
value below that is ignored.  The default value is 10.
@end defopt

@c This is not yet implemented.  Why is it "documented"?
@defvar window-size-change-functions
This variable holds a list of functions to be called if the size of any
window changes for any reason.  The functions are called just once per
redisplay, and just once for each frame on which size changes have
occurred.

Each function receives the frame as its sole argument.  There is no
direct way to find out which windows changed size, or precisely how;
however, if your size-change function keeps track, after each change, of
the windows that interest you, you can figure out what has changed by
comparing the old size data with the new.

Creating or deleting windows counts as a size change, and therefore
causes these functions to be called.  Changing the frame size also
counts, because it changes the sizes of the existing windows.

It is not a good idea to use @code{save-window-excursion} in these
functions, because that always counts as a size change, and it would
cause these functions to be called over and over.  In most cases,
@code{save-selected-window} is what you need here.
@end defvar


@node Window Configurations
@section Window Configurations
@cindex window configurations
@cindex saving window information

  A @dfn{window configuration} records the entire layout of a
frame---all windows, their sizes, which buffers they contain, what part
of each buffer is displayed, and the values of point and the mark.  You
can bring back an entire previous layout by restoring a window
configuration previously saved.

  If you want to record all frames instead of just one, use a frame
configuration instead of a window configuration.  @xref{Frame
Configurations}.

  Use the window configuration hook whenever you need to dynamicly
adapt to window configuration changes.  @xref{Window Configuration
Hook}.

@defun current-window-configuration &optional frame
This function returns a new object representing the current window
configuration of @var{frame}, namely the number of windows, their sizes
and current buffers, which window is the selected window, and for each
window the displayed buffer, the display-start position, and the
positions of point and the mark.  An exception is made for point in the
current buffer, whose value is not saved.

@var{frame} defaults to the selected frame.
@end defun

@defun set-window-configuration configuration
This function restores the configuration of SXEmacs's windows and
buffers to the state specified by @var{configuration}.  The argument
@var{configuration} must be a value that was previously returned by
@code{current-window-configuration}.

This function always counts as a window size change and triggers
execution of the @code{window-size-change-functions}.  (It doesn't know
how to tell whether the new configuration actually differs from the old
one.)

Here is a way of using this function to get the same effect
as @code{save-window-excursion}:

@example
@group
(let ((config (current-window-configuration)))
  (unwind-protect
      (progn (split-window-vertically nil)
             @dots{})
    (set-window-configuration config)))
@end group
@end example
@end defun

@defspec save-window-excursion forms@dots{}
This special form records the window configuration, executes @var{forms}
in sequence, then restores the earlier window configuration.  The window
configuration includes the value of point and the portion of the buffer
that is visible.  It also includes the choice of selected window.
However, it does not include the value of point in the current buffer;
use @code{save-excursion} if you wish to preserve that.

Don't use this construct when @code{save-selected-window} is all you need.

Exit from @code{save-window-excursion} always triggers execution of the
@code{window-size-change-functions}.  (It doesn't know how to tell
whether the restored configuration actually differs from the one in
effect at the end of the @var{forms}.)

The return value is the value of the final form in @var{forms}.
For example:

@example
@group
(split-window)
     @result{} #<window 25 on control.texi>
@end group
@group
(setq w (selected-window))
     @result{} #<window 19 on control.texi>
@end group
@group
(save-window-excursion
  (delete-other-windows w)
  (switch-to-buffer "foo")
  'do-something)
     @result{} do-something
     ;; @r{The frame is now split again.}
@end group
@end example
@end defspec

@defun window-configuration-p object
This function returns @code{t} if @var{object} is a window configuration.
@end defun

  Primitives to look inside of window configurations would make sense,
but none are implemented.  It is not clear they are useful enough to be
worth implementing.


@node Window Configuration Hook
@section Window Configuration Hook
@cindex window configuration hook

The @var{window-configuration-hook}, is a list of functions run whenever
the window configuration of a frame changes; such as when a window is
deleted, split or resized.

Each function is called with a window as argument, which window depends
on what function runs the hook.

When a new frame is created, this hook is not run on the newly created
window, please use the @var{create-frame-hook} instead, where each
function recieves the frame as argument.

There is no guarantee that this will only be run at the end of some
function that changes the window configuration (read layout), in fact it
can be run several times while the window layout changes.

The core functions that run this hook try to ensure that it does not
cause infinite loops, but if you run some functions that change the
layout @strong{expect trouble}.

Here is a complete list of core functions, running the hook.  All other
window manipulating functions call these and therefore run the hook at
some point in time.  If not, that's a bug, and you should report it as
such.

@table @asis
@c deleting windows
@item @code{delete-window} @xref{Deleting Windows}.
The window that takes the space of the deleted window is recieved as the
argument.  If this command deletes the frame, the hook is not run.
@item @code{delete-other-windows} @xref{Deleting Windows}.
The window that is left behind is recieved as argument.
@c buffers and windows
@item @code{set-window-buffer} @xref{Buffers and Windows}.
The window recievied as argument is passed on to the hook.
@c splitting windows
@item @code{split-window} @xref{Splitting Windows}.
The window recievied as argument is passed on to the hook.
@c resising windows
@item @code{enlarge-window} @xref{Resizing Windows}.
The window recievied as argument is passed on to the hook.
@item @code{enlarge-window-pixels} @xref{Resizing Windows}.
The window recievied as argument is passed on to the hook..
@item @code{shrink-window} @xref{Resizing Windows}.
The window recievied as argument is passed on to the hook.
@item @code{shrink-window-pixels} @xref{Resizing Windows}.
The window recievied as argument is passed on to the hook.
@end table
