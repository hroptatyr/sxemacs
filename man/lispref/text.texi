@c -*-texinfo-*-
@c This is part of the XEmacs Lisp Reference Manual.
@c Copyright (C) 1990, 1991, 1992, 1993, 1994 Free Software Foundation, Inc.
@c See the file lispref.texi for copying conditions.
@setfilename ../../info/text.info
@node Text, Searching and Matching, Markers, Top
@chapter Text
@cindex text

  This chapter describes the functions that deal with the text in a
buffer.  Most examine, insert, or delete text in the current buffer,
often in the vicinity of point.  Many are interactive.  All the
functions that change the text provide for undoing the changes
(@pxref{Undo}).

  Many text-related functions operate on a region of text defined by two
buffer positions passed in arguments named @var{start} and @var{end}.
These arguments should be either markers (@pxref{Markers}) or numeric
character positions (@pxref{Positions}).  The order of these arguments
does not matter; it is all right for @var{start} to be the end of the
region and @var{end} the beginning.  For example, @code{(delete-region 1
10)} and @code{(delete-region 10 1)} are equivalent.  An
@code{args-out-of-range} error is signaled if either @var{start} or
@var{end} is outside the accessible portion of the buffer.  In an
interactive call, point and the mark are used for these arguments.

@cindex buffer contents
  Throughout this chapter, ``text'' refers to the characters in the
buffer, together with their properties (when relevant).

@menu
* Near Point::       Examining text in the vicinity of point.
* Buffer Contents::  Examining text in a general fashion.
* Comparing Text::   Comparing substrings of buffers.
* Insertion::        Adding new text to a buffer.
* Commands for Insertion::  User-level commands to insert text.
* Deletion::         Removing text from a buffer.
* User-Level Deletion::     User-level commands to delete text.
* The Kill Ring::    Where removed text sometimes is saved for later use.
* Undo::             Undoing changes to the text of a buffer.
* Maintaining Undo:: How to enable and disable undo information.
			How to control how much information is kept.
* Filling::          Functions for explicit filling.
* Margins::          How to specify margins for filling commands.
* Auto Filling::     How auto-fill mode is implemented to break lines.
* Sorting::          Functions for sorting parts of the buffer.
* Columns::          Computing horizontal positions, and using them.
* Indentation::      Functions to insert or adjust indentation.
* Case Changes::     Case conversion of parts of the buffer.
* Text Properties::  Assigning Lisp property lists to text characters.
* Substitution::     Replacing a given character wherever it appears.
* Registers::        How registers are implemented.  Accessing the text or
                       position stored in a register.
* Transposition::    Swapping two portions of a buffer.
* Change Hooks::     Supplying functions to be run when text is changed.
* Transformations::  MD5 and base64 support.
@end menu

@node Near Point
@section Examining Text Near Point

  Many functions are provided to look at the characters around point.
Several simple functions are described here.  See also @code{looking-at}
in @ref{Regexp Search}.

  Many of these functions take an optional @var{buffer} argument.
In all such cases, the current buffer will be used if this argument
is omitted. (In FSF Emacs, and earlier versions of XEmacs, these
functions usually did not have these optional @var{buffer} arguments
and always operated on the current buffer.)


@defun char-after &optional position buffer
This function returns the character in the buffer at (i.e.,
immediately after) position @var{position}.  If @var{position} is out of
range for this purpose, either before the beginning of the buffer, or at
or beyond the end, then the value is @code{nil}.  The default for
@var{position} is point.  If optional argument @var{buffer} is
@code{nil}, the current buffer is assumed.

In the following example, assume that the first character in the
buffer is @samp{@@}:

@example
@group
(char-to-string (char-after 1))
     @result{} "@@"
@end group
@end example
@end defun

@defun char-before &optional position buffer
This function returns the character in the current buffer immediately
before position @var{position}.  If @var{position} is out of range for
this purpose, either at or before the beginning of the buffer, or beyond
the end, then the value is @code{nil}.  The default for
@var{position} is point.  If optional argument @var{buffer} is
@code{nil}, the current buffer is assumed.
@end defun

@defun following-char &optional buffer
This function returns the character following point in the buffer.
This is similar to @code{(char-after (point))}.  However, if point is at
the end of the buffer, then the result of @code{following-char} is 0.
If optional argument @var{buffer} is @code{nil}, the current buffer is
assumed.

Remember that point is always between characters, and the terminal
cursor normally appears over the character following point.  Therefore,
the character returned by @code{following-char} is the character the
cursor is over.

In this example, point is between the @samp{a} and the @samp{c}.

@example
@group
---------- Buffer: foo ----------
Gentlemen may cry ``Pea@point{}ce! Peace!,''
but there is no peace.
---------- Buffer: foo ----------
@end group

@group
(char-to-string (preceding-char))
     @result{} "a"
(char-to-string (following-char))
     @result{} "c"
@end group
@end example
@end defun

@defun preceding-char &optional buffer
This function returns the character preceding point in the buffer.
See above, under @code{following-char}, for an example.  If
point is at the beginning of the buffer, @code{preceding-char} returns
0.  If optional argument @var{buffer} is @code{nil}, the current buffer
is assumed.
@end defun

@defun bobp &optional buffer
This function returns @code{t} if point is at the beginning of the
buffer.  If narrowing is in effect, this means the beginning of the
accessible portion of the text.  If optional argument @var{buffer} is
@code{nil}, the current buffer is assumed.  See also @code{point-min} in
@ref{Point}.
@end defun

@defun eobp &optional buffer
This function returns @code{t} if point is at the end of the buffer.
If narrowing is in effect, this means the end of accessible portion of
the text.  If optional argument @var{buffer} is @code{nil}, the current
buffer is assumed.  See also @code{point-max} in @xref{Point}.
@end defun

@defun bolp &optional buffer
This function returns @code{t} if point is at the beginning of a line.
If optional argument @var{buffer} is @code{nil}, the current buffer is
assumed.  @xref{Text Lines}.  The beginning of the buffer (or its
accessible portion) always counts as the beginning of a line.
@end defun

@defun eolp &optional buffer
This function returns @code{t} if point is at the end of a line.  The
end of the buffer is always considered the end of a line.  If optional
argument @var{buffer} is @code{nil}, the current buffer is assumed.
The end of the buffer (or of its accessible portion) is always considered
the end of a line.
@end defun

@node Buffer Contents
@section Examining Buffer Contents

  This section describes two functions that allow a Lisp program to
convert any portion of the text in the buffer into a string.

@defun buffer-substring start end &optional buffer
@defunx buffer-string start end &optional buffer
These functions are equivalent and return a string containing a copy of
the text of the region defined by positions @var{start} and @var{end} in
the buffer.  If the arguments are not positions in the accessible
portion of the buffer, @code{buffer-substring} signals an
@code{args-out-of-range} error.  If optional argument @var{buffer} is
@code{nil}, the current buffer is assumed.

@c XEmacs feature.
  If the region delineated by @var{start} and @var{end} contains
duplicable extents, they will be remembered in the string.
@xref{Duplicable Extents}.

It is not necessary for @var{start} to be less than @var{end}; the
arguments can be given in either order.  But most often the smaller
argument is written first.

@example
@group
---------- Buffer: foo ----------
This is the contents of buffer foo

---------- Buffer: foo ----------
@end group

@group
(buffer-substring 1 10)
@result{} "This is t"
@end group
@group
(buffer-substring (point-max) 10)
@result{} "he contents of buffer foo
"
@end group
@end example
@end defun

@ignore
@c `equal' in XEmacs does not compare text properties on strings
@defun buffer-substring-without-properties start end
This is like @code{buffer-substring}, except that it does not copy text
properties, just the characters themselves.  @xref{Text Properties}.
Here's an example of using this function to get a word to look up in an
alist:

@example
(setq flammable
      (assoc (buffer-substring start end)
             '(("wood" . t) ("paper" . t)
               ("steel" . nil) ("asbestos" . nil))))
@end example

If this were written using @code{buffer-substring} instead, it would not
work reliably; any text properties that happened to be in the word
copied from the buffer would make the comparisons fail.
@end defun
@end ignore

@node Comparing Text
@section Comparing Text
@cindex comparing buffer text

  This function lets you compare portions of the text in a buffer, without
copying them into strings first.

@defun compare-buffer-substrings buffer1 start1 end1 buffer2 start2 end2
This function lets you compare two substrings of the same buffer or two
different buffers.  The first three arguments specify one substring,
giving a buffer and two positions within the buffer.  The last three
arguments specify the other substring in the same way.  You can use
@code{nil} for @var{buffer1}, @var{buffer2}, or both to stand for the
current buffer.

The value is negative if the first substring is less, positive if the
first is greater, and zero if they are equal.  The absolute value of
the result is one plus the index of the first differing characters
within the substrings.

This function ignores case when comparing characters
if @code{case-fold-search} is non-@code{nil}.  It always ignores
text properties.

Suppose the current buffer contains the text @samp{foobarbar
haha!rara!}; then in this example the two substrings are @samp{rbar }
and @samp{rara!}.  The value is 2 because the first substring is greater
at the second character.

@example
(compare-buffer-substring nil 6 11 nil 16 21)
     @result{} 2
@end example
@end defun

@node Insertion
@section Inserting Text
@cindex insertion of text
@cindex text insertion

  @dfn{Insertion} means adding new text to a buffer.  The inserted text
goes at point---between the character before point and the character
after point.

  Insertion relocates markers that point at positions after the
insertion point, so that they stay with the surrounding text
(@pxref{Markers}).  When a marker points at the place of insertion,
insertion normally doesn't relocate the marker, so that it points to the
beginning of the inserted text; however, certain special functions such
as @code{insert-before-markers} relocate such markers to point after the
inserted text.

@cindex insertion before point
@cindex before point, insertion
  Some insertion functions leave point before the inserted text, while
other functions leave it after.  We call the former insertion @dfn{after
point} and the latter insertion @dfn{before point}.

@c XEmacs feature.
  If a string with non-@code{nil} extent data is inserted, the remembered
extents will also be inserted.  @xref{Duplicable Extents}.

  Insertion functions signal an error if the current buffer is
read-only.

  These functions copy text characters from strings and buffers along
with their properties.  The inserted characters have exactly the same
properties as the characters they were copied from.  By contrast,
characters specified as separate arguments, not part of a string or
buffer, inherit their text properties from the neighboring text.

@defun insert &rest args
This function inserts the strings and/or characters @var{args} into the
current buffer, at point, moving point forward.  In other words, it
inserts the text before point.  An error is signaled unless all
@var{args} are either strings or characters.  The value is @code{nil}.
@end defun

@defun insert-before-markers &rest args
This function inserts the strings and/or characters @var{args} into the
current buffer, at point, moving point forward.  An error is signaled
unless all @var{args} are either strings or characters.  The value is
@code{nil}.

This function is unlike the other insertion functions in that it
relocates markers initially pointing at the insertion point, to point
after the inserted text.
@end defun

@defun insert-string string &optional buffer
This function inserts @var{string} into @var{buffer} before point.
@var{buffer} defaults to the current buffer if omitted.  This
function is chiefly useful if you want to insert a string in
a buffer other than the current one (otherwise you could just
use @code{insert}).
@end defun

@defun insert-char character &optional count ignored buffer
This function inserts @var{count} instances of @var{character} into
@var{buffer} before point.  @var{count} must be a number, and
@var{character} must be a character.

If optional argument @var{buffer} is @code{nil}, the current buffer is
assumed. (In FSF Emacs, the third argument is called @var{inherit} and
refers to text properties.  In XEmacs, it is always ignored.)

This function always returns @code{nil}.
@end defun

@defun insert-buffer-substring from-buffer-or-name &optional start end
This function inserts a portion of buffer @var{from-buffer-or-name}
(which must already exist) into the current buffer before point.  The
text inserted is the region from @var{start} and @var{end}.  (These
arguments default to the beginning and end of the accessible portion of
that buffer.)  This function returns @code{nil}.

In this example, the form is executed with buffer @samp{bar} as the
current buffer.  We assume that buffer @samp{bar} is initially empty.

@example
@group
---------- Buffer: foo ----------
We hold these truths to be self-evident, that all
---------- Buffer: foo ----------
@end group

@group
(insert-buffer-substring "foo" 1 20)
     @result{} nil

---------- Buffer: bar ----------
We hold these truth@point{}
---------- Buffer: bar ----------
@end group
@end example
@end defun

@node Commands for Insertion
@section User-Level Insertion Commands

  This section describes higher-level commands for inserting text,
commands intended primarily for the user but useful also in Lisp
programs.

@deffn Command insert-buffer from-buffer-or-name
This command inserts the entire contents of @var{from-buffer-or-name}
(which must exist) into the current buffer after point.  It leaves
the mark after the inserted text.  The value is @code{nil}.
@end deffn

@deffn Command self-insert-command count
@cindex character insertion
@cindex self-insertion
This command inserts the last character typed; it does so @var{count}
times, before point, and returns @code{nil}.  Most printing characters
are bound to this command.  In routine use, @code{self-insert-command}
is the most frequently called function in XEmacs, but programs rarely use
it except to install it on a keymap.

In an interactive call, @var{count} is the numeric prefix argument.

This command calls @code{auto-fill-function} whenever that is
non-@code{nil} and the character inserted is a space or a newline
(@pxref{Auto Filling}).

@c Cross refs reworded to prevent overfull hbox.  --rjc 15mar92
This command performs abbrev expansion if Abbrev mode is enabled and
the inserted character does not have word-constituent
syntax. (@xref{Abbrevs}, and @ref{Syntax Class Table}.)

This is also responsible for calling @code{blink-paren-function} when
the inserted character has close parenthesis syntax (@pxref{Blinking}).
@end deffn

@deffn Command newline &optional count
This command inserts newlines into the current buffer before point.
If @var{count} is supplied, that many newline characters
are inserted.

@cindex newline and Auto Fill mode
This function calls @code{auto-fill-function} if the current column
number is greater than the value of @code{fill-column} and
@var{count} is @code{nil}.  Typically what
@code{auto-fill-function} does is insert a newline; thus, the overall
result in this case is to insert two newlines at different places: one
at point, and another earlier in the line.  @code{newline} does not
auto-fill if @var{count} is non-@code{nil}.

This command indents to the left margin if that is not zero.
@xref{Margins}.

The value returned is @code{nil}.  In an interactive call, @var{count}
is the numeric prefix argument.
@end deffn

@deffn Command split-line
This command splits the current line, moving the portion of the line
after point down vertically so that it is on the next line directly
below where it was before.  Whitespace is inserted as needed at the
beginning of the lower line, using the @code{indent-to} function.
@code{split-line} returns the position of point.

Programs hardly ever use this function.
@end deffn

@defvar overwrite-mode
This variable controls whether overwrite mode is in effect: a
non-@code{nil} value enables the mode.  It is automatically made
buffer-local when set in any fashion.
@end defvar

@node Deletion
@section Deleting Text

@cindex deletion vs killing
  Deletion means removing part of the text in a buffer, without saving
it in the kill ring (@pxref{The Kill Ring}).  Deleted text can't be
yanked, but can be reinserted using the undo mechanism (@pxref{Undo}).
Some deletion functions do save text in the kill ring in some special
cases.

  All of the deletion functions operate on the current buffer, and all
return a value of @code{nil}.

@deffn Command erase-buffer &optional buffer
This function deletes the entire text of @var{buffer}, leaving it
empty.  If the buffer is read-only, it signals a @code{buffer-read-only}
error.  Otherwise, it deletes the text without asking for any
confirmation.  It returns @code{nil}.  @var{buffer} defaults to the
current buffer if omitted.

Normally, deleting a large amount of text from a buffer inhibits further
auto-saving of that buffer ``because it has shrunk''.  However,
@code{erase-buffer} does not do this, the idea being that the future
text is not really related to the former text, and its size should not
be compared with that of the former text.
@end deffn

@deffn Command delete-region start end &optional buffer
This command deletes the text in @var{buffer} in the region defined by
@var{start} and @var{end}.  The value is @code{nil}.  If optional
argument @var{buffer} is @code{nil}, the current buffer is assumed.
@end deffn

@deffn Command delete-char &optional count killp
This command deletes @var{count} characters directly after point, or
before point if @var{count} is negative.  @var{count} defaults to @code{1}.
If @var{killp} is non-@code{nil}, then it saves the deleted characters
in the kill ring.

In an interactive call, @var{count} is the numeric prefix argument, and
@var{killp} is the unprocessed prefix argument.  Therefore, if a prefix
argument is supplied, the text is saved in the kill ring.  If no prefix
argument is supplied, then one character is deleted, but not saved in
the kill ring.

The value returned is always @code{nil}.
@end deffn

@deffn Command delete-backward-char &optional count killp
@cindex delete previous char
This command deletes @var{count} characters directly before point, or
after point if @var{count} is negative.  @var{count} defaults to 1.
If @var{killp} is non-@code{nil}, then it saves the deleted characters
in the kill ring.

In an interactive call, @var{count} is the numeric prefix argument, and
@var{killp} is the unprocessed prefix argument.  Therefore, if a prefix
argument is supplied, the text is saved in the kill ring.  If no prefix
argument is supplied, then one character is deleted, but not saved in
the kill ring.

The value returned is always @code{nil}.
@end deffn

@deffn Command backward-delete-char-untabify count &optional killp
@cindex tab deletion
This command deletes @var{count} characters backward, changing tabs
into spaces.  When the next character to be deleted is a tab, it is
first replaced with the proper number of spaces to preserve alignment
and then one of those spaces is deleted instead of the tab.  If
@var{killp} is non-@code{nil}, then the command saves the deleted
characters in the kill ring.

Conversion of tabs to spaces happens only if @var{count} is positive.
If it is negative, exactly @minus{}@var{count} characters after point
are deleted.

In an interactive call, @var{count} is the numeric prefix argument, and
@var{killp} is the unprocessed prefix argument.  Therefore, if a prefix
argument is supplied, the text is saved in the kill ring.  If no prefix
argument is supplied, then one character is deleted, but not saved in
the kill ring.

The value returned is always @code{nil}.
@end deffn

@node User-Level Deletion
@section User-Level Deletion Commands

  This section describes higher-level commands for deleting text,
commands intended primarily for the user but useful also in Lisp
programs.

@deffn Command delete-horizontal-space
@cindex deleting whitespace
This function deletes all spaces and tabs around point.  It returns
@code{nil}.

In the following examples, we call @code{delete-horizontal-space} four
times, once on each line, with point between the second and third
characters on the line each time.

@example
@group
---------- Buffer: foo ----------
I @point{}thought
I @point{}     thought
We@point{} thought
Yo@point{}u thought
---------- Buffer: foo ----------
@end group

@group
(delete-horizontal-space)   ; @r{Four times.}
     @result{} nil

---------- Buffer: foo ----------
Ithought
Ithought
Wethought
You thought
---------- Buffer: foo ----------
@end group
@end example
@end deffn

@deffn Command delete-indentation &optional join-following-p
This function joins the line point is on to the previous line, deleting
any whitespace at the join and in some cases replacing it with one
space.  If @var{join-following-p} is non-@code{nil},
@code{delete-indentation} joins this line to the following line
instead.  The value is @code{nil}.

If there is a fill prefix, and the second of the lines being joined
starts with the prefix, then @code{delete-indentation} deletes the
fill prefix before joining the lines.  @xref{Margins}.

In the example below, point is located on the line starting
@samp{events}, and it makes no difference if there are trailing spaces
in the preceding line.

@smallexample
@group
---------- Buffer: foo ----------
When in the course of human
@point{}    events, it becomes necessary
---------- Buffer: foo ----------
@end group

(delete-indentation)
     @result{} nil

@group
---------- Buffer: foo ----------
When in the course of human@point{} events, it becomes necessary
---------- Buffer: foo ----------
@end group
@end smallexample

After the lines are joined, the function @code{fixup-whitespace} is
responsible for deciding whether to leave a space at the junction.
@end deffn

@deffn Command fixup-whitespace
This function replaces all the white space surrounding point with either
one space or no space, according to the context.  It returns @code{nil}.

At the beginning or end of a line, the appropriate amount of space is
none.  Before a character with close parenthesis syntax, or after a
character with open parenthesis or expression-prefix syntax, no space is
also appropriate.  Otherwise, one space is appropriate.  @xref{Syntax
Class Table}.

In the example below, @code{fixup-whitespace} is called the first time
with point before the word @samp{spaces} in the first line.  For the
second invocation, point is directly after the @samp{(}.

@smallexample
@group
---------- Buffer: foo ----------
This has too many     @point{}spaces
This has too many spaces at the start of (@point{}   this list)
---------- Buffer: foo ----------
@end group

@group
(fixup-whitespace)
     @result{} nil
(fixup-whitespace)
     @result{} nil
@end group

@group
---------- Buffer: foo ----------
This has too many spaces
This has too many spaces at the start of (this list)
---------- Buffer: foo ----------
@end group
@end smallexample
@end deffn

@deffn Command just-one-space
@comment !!SourceFile simple.el
This command replaces any spaces and tabs around point with a single
space.  It returns @code{nil}.
@end deffn

@deffn Command delete-blank-lines
This function deletes blank lines surrounding point.  If point is on a
blank line with one or more blank lines before or after it, then all but
one of them are deleted.  If point is on an isolated blank line, then it
is deleted.  If point is on a nonblank line, the command deletes all
blank lines following it.

A blank line is defined as a line containing only tabs and spaces.

@code{delete-blank-lines} returns @code{nil}.
@end deffn

@node The Kill Ring
@section The Kill Ring
@cindex kill ring

  @dfn{Kill} functions delete text like the deletion functions, but save
it so that the user can reinsert it by @dfn{yanking}.  Most of these
functions have @samp{kill-} in their name.  By contrast, the functions
whose names start with @samp{delete-} normally do not save text for
yanking (though they can still be undone); these are ``deletion''
functions.

  Most of the kill commands are primarily for interactive use, and are
not described here.  What we do describe are the functions provided for
use in writing such commands.  You can use these functions to write
commands for killing text.  When you need to delete text for internal
purposes within a Lisp function, you should normally use deletion
functions, so as not to disturb the kill ring contents.
@xref{Deletion}.

  Killed text is saved for later yanking in the @dfn{kill ring}.  This
is a list that holds a number of recent kills, not just the last text
kill.  We call this a ``ring'' because yanking treats it as having
elements in a cyclic order.  The list is kept in the variable
@code{kill-ring}, and can be operated on with the usual functions for
lists; there are also specialized functions, described in this section,
that treat it as a ring.

  Some people think this use of the word ``kill'' is unfortunate, since
it refers to operations that specifically @emph{do not} destroy the
entities ``killed''.  This is in sharp contrast to ordinary life, in
which death is permanent and ``killed'' entities do not come back to
life.  Therefore, other metaphors have been proposed.  For example, the
term ``cut ring'' makes sense to people who, in pre-computer days, used
scissors and paste to cut up and rearrange manuscripts.  However, it
would be difficult to change the terminology now.

@menu
* Kill Ring Concepts::     What text looks like in the kill ring.
* Kill Functions::         Functions that kill text.
* Yank Commands::          Commands that access the kill ring.
* Low-Level Kill Ring::	   Functions and variables for kill ring access.
* Internals of Kill Ring:: Variables that hold kill-ring data.
@end menu

@node Kill Ring Concepts
@subsection Kill Ring Concepts

  The kill ring records killed text as strings in a list, most recent
first.  A short kill ring, for example, might look like this:

@example
("some text" "a different piece of text" "even older text")
@end example

@noindent
When the list reaches @code{kill-ring-max} entries in length, adding a
new entry automatically deletes the last entry.

  When kill commands are interwoven with other commands, each kill
command makes a new entry in the kill ring.  Multiple kill commands in
succession build up a single entry in the kill ring, which would be
yanked as a unit; the second and subsequent consecutive kill commands
add text to the entry made by the first one.

  For yanking, one entry in the kill ring is designated the ``front'' of
the ring.  Some yank commands ``rotate'' the ring by designating a
different element as the ``front.''  But this virtual rotation doesn't
change the list itself---the most recent entry always comes first in the
list.

@node Kill Functions
@subsection Functions for Killing

  @code{kill-region} is the usual subroutine for killing text.  Any
command that calls this function is a ``kill command'' (and should
probably have @samp{kill} in its name).  @code{kill-region} puts the
newly killed text in a new element at the beginning of the kill ring or
adds it to the most recent element.  It uses the @code{last-command}
variable to determine whether the previous command was a kill command,
and if so appends the killed text to the most recent entry.

@deffn Command kill-region start end &optional verbose
This function kills the text in the region defined by @var{start} and
@var{end}.  The text is deleted but saved in the kill ring, along with
its text properties.  The value is always @code{nil}.

In an interactive call, @var{start} and @var{end} are point and
the mark.

@c Emacs 19 feature
If the buffer is read-only, @code{kill-region} modifies the kill ring
just the same, then signals an error without modifying the buffer.  This
is convenient because it lets the user use all the kill commands to copy
text into the kill ring from a read-only buffer.
@end deffn

@deffn Command copy-region-as-kill start end
This command saves the region defined by @var{start} and @var{end} on
the kill ring (including text properties), but does not delete the text
from the buffer.  It returns @code{nil}.  It also indicates the extent
of the text copied by moving the cursor momentarily, or by displaying a
message in the echo area.

The command does not set @code{this-command} to @code{kill-region}, so a
subsequent kill command does not append to the same kill ring entry.

Don't call @code{copy-region-as-kill} in Lisp programs unless you aim to
support Emacs 18.  For Emacs 19, it is better to use @code{kill-new} or
@code{kill-append} instead.  @xref{Low-Level Kill Ring}.
@end deffn

@node Yank Commands
@subsection Functions for Yanking

  @dfn{Yanking} means reinserting an entry of previously killed text
from the kill ring.  The text properties are copied too.

@deffn Command yank &optional arg
@cindex inserting killed text
This command inserts before point the text in the first entry in the
kill ring.  It positions the mark at the beginning of that text, and
point at the end.

If @var{arg} is a list (which occurs interactively when the user
types @kbd{C-u} with no digits), then @code{yank} inserts the text as
described above, but puts point before the yanked text and puts the mark
after it.

If @var{arg} is a number, then @code{yank} inserts the @var{arg}th most
recently killed text---the @var{arg}th element of the kill ring list.

@code{yank} does not alter the contents of the kill ring or rotate it.
It returns @code{nil}.
@end deffn

@deffn Command yank-pop arg
This command replaces the just-yanked entry from the kill ring with a
different entry from the kill ring.

This is allowed only immediately after a @code{yank} or another
@code{yank-pop}.  At such a time, the region contains text that was just
inserted by yanking.  @code{yank-pop} deletes that text and inserts in
its place a different piece of killed text.  It does not add the deleted
text to the kill ring, since it is already in the kill ring somewhere.

If @var{arg} is @code{nil}, then the replacement text is the previous
element of the kill ring.  If @var{arg} is numeric, the replacement is
the @var{arg}th previous kill.  If @var{arg} is negative, a more recent
kill is the replacement.

The sequence of kills in the kill ring wraps around, so that after the
oldest one comes the newest one, and before the newest one goes the
oldest.

The value is always @code{nil}.
@end deffn

@node Low-Level Kill Ring
@subsection Low-Level Kill Ring

  These functions and variables provide access to the kill ring at a lower
level, but still convenient for use in Lisp programs.  They take care of
interaction with X Window selections.  They do not exist in Emacs
version 18.

@defun current-kill count &optional do-not-move
The function @code{current-kill} rotates the yanking pointer which
designates the ``front'' of the kill ring by @var{count} places (from newer
kills to older ones), and returns the text at that place in the ring.

If the optional second argument @var{do-not-move} is non-@code{nil},
then @code{current-kill} doesn't alter the yanking pointer; it just
returns the @var{count}th kill, counting from the current yanking pointer.

If @var{count} is zero, indicating a request for the latest kill,
@code{current-kill} calls the value of
@code{interprogram-paste-function} (documented below) before consulting
the kill ring.
@end defun

@defun kill-new string &optional replace
This function makes the text @var{string} the latest entry in the kill
ring, and sets @code{kill-ring-yank-pointer} to point to it.

Normally, @var{string} is added to the front of the kill ring as a new
entry.  However, if optional argument @var{replace} is non-@code{nil},
the entry previously at the front of the kill ring is discarded, and
@var{string} replaces it.

This function runs the functions on @code{kill-hooks}, and also invokes
the value of @code{interprogram-cut-function} (see below).
@end defun

@defun kill-append string before-p
This function appends the text @var{string} to the first entry in the
kill ring.  Normally @var{string} goes at the end of the entry, but if
@var{before-p} is non-@code{nil}, it goes at the beginning.  This
function also invokes the value of @code{interprogram-cut-function} (see
below).
@end defun

@defvar interprogram-paste-function
This variable provides a way of transferring killed text from other
programs, when you are using a window system.  Its value should be
@code{nil} or a function of no arguments.

If the value is a function, @code{current-kill} calls it to get the
``most recent kill''.  If the function returns a non-@code{nil} value,
then that value is used as the ``most recent kill''.  If it returns
@code{nil}, then the first element of @code{kill-ring} is used.

The normal use of this hook is to get the X server's primary selection
as the most recent kill, even if the selection belongs to another X
client.  @xref{X Selections}.
@end defvar

@defvar interprogram-cut-function
This variable provides a way of communicating killed text to other
programs, when you are using a window system.  Its value should be
@code{nil} or a function of one argument.

If the value is a function, @code{kill-new} and @code{kill-append} call
it with the new first element of the kill ring as an argument.

The normal use of this hook is to set the X server's primary selection
to the newly killed text.
@end defvar

@node Internals of Kill Ring
@subsection Internals of the Kill Ring

  The variable @code{kill-ring} holds the kill ring contents, in the
form of a list of strings.  The most recent kill is always at the front
of the list.

  The @code{kill-ring-yank-pointer} variable points to a link in the
kill ring list, whose @sc{car} is the text to yank next.  We say it
identifies the ``front'' of the ring.  Moving
@code{kill-ring-yank-pointer} to a different link is called
@dfn{rotating the kill ring}.  We call the kill ring a ``ring'' because
the functions that move the yank pointer wrap around from the end of the
list to the beginning, or vice-versa.  Rotation of the kill ring is
virtual; it does not change the value of @code{kill-ring}.

  Both @code{kill-ring} and @code{kill-ring-yank-pointer} are Lisp
variables whose values are normally lists.  The word ``pointer'' in the
name of the @code{kill-ring-yank-pointer} indicates that the variable's
purpose is to identify one element of the list for use by the next yank
command.

  The value of @code{kill-ring-yank-pointer} is always @code{eq} to one
of the links in the kill ring list.  The element it identifies is the
@sc{car} of that link.  Kill commands, which change the kill ring, also
set this variable to the value of @code{kill-ring}.  The effect is to
rotate the ring so that the newly killed text is at the front.

  Here is a diagram that shows the variable @code{kill-ring-yank-pointer}
pointing to the second entry in the kill ring @code{("some text" "a
different piece of text" "yet older text")}.

@example
@group
kill-ring       kill-ring-yank-pointer
  |               |
  |     ___ ___    --->  ___ ___      ___ ___
   --> |___|___|------> |___|___|--> |___|___|--> nil
         |                |            |
         |                |            |
         |                |             -->"yet older text"
         |                |
         |                 --> "a different piece of text"
         |
          --> "some text"
@end group
@end example

@noindent
This state of affairs might occur after @kbd{C-y} (@code{yank})
immediately followed by @kbd{M-y} (@code{yank-pop}).

@defvar kill-ring
This variable holds the list of killed text sequences, most recently
killed first.
@end defvar

@defvar kill-ring-yank-pointer
This variable's value indicates which element of the kill ring is at the
``front'' of the ring for yanking.  More precisely, the value is a tail
of the value of @code{kill-ring}, and its @sc{car} is the kill string
that @kbd{C-y} should yank.
@end defvar

@defopt kill-ring-max
The value of this variable is the maximum length to which the kill
ring can grow, before elements are thrown away at the end.  The default
value for @code{kill-ring-max} is 30.
@end defopt

@node Undo
@section Undo
@cindex redo

  Most buffers have an @dfn{undo list}, which records all changes made
to the buffer's text so that they can be undone.  (The buffers that
don't have one are usually special-purpose buffers for which XEmacs
assumes that undoing is not useful.)  All the primitives that modify the
text in the buffer automatically add elements to the front of the undo
list, which is in the variable @code{buffer-undo-list}.

@defvar buffer-undo-list
This variable's value is the undo list of the current buffer.
A value of @code{t} disables the recording of undo information.
@end defvar

Here are the kinds of elements an undo list can have:

@table @code
@item @var{integer}
This kind of element records a previous value of point.  Ordinary cursor
motion does not get any sort of undo record, but deletion commands use
these entries to record where point was before the command.

@item (@var{start} . @var{end})
This kind of element indicates how to delete text that was inserted.
Upon insertion, the text occupied the range @var{start}--@var{end} in the
buffer.

@item (@var{text} . @var{position})
This kind of element indicates how to reinsert text that was deleted.
The deleted text itself is the string @var{text}.  The place to
reinsert it is @code{(abs @var{position})}.

@item (t @var{high} . @var{low})
This kind of element indicates that an unmodified buffer became
modified.  The elements @var{high} and @var{low} are two integers, each
recording 16 bits of the visited file's modification time as of when it
was previously visited or saved.  @code{primitive-undo} uses those
values to determine whether to mark the buffer as unmodified once again;
it does so only if the file's modification time matches those numbers.

@item (nil @var{property} @var{value} @var{start} . @var{end})
This kind of element records a change in a text property.
Here's how you might undo the change:

@example
(put-text-property @var{start} @var{end} @var{property} @var{value})
@end example

@item @var{position}
This element indicates where point was at an earlier time.  Undoing this
element sets point to @var{position}.  Deletion normally creates an
element of this kind as well as a reinsertion element.

@item nil
This element is a boundary.  The elements between two boundaries are
called a @dfn{change group}; normally, each change group corresponds to
one keyboard command, and undo commands normally undo an entire group as
a unit.
@end table

@defun undo-boundary
This function places a boundary element in the undo list.  The undo
command stops at such a boundary, and successive undo commands undo
to earlier and earlier boundaries.  This function returns @code{nil}.

The editor command loop automatically creates an undo boundary before
each key sequence is executed.  Thus, each undo normally undoes the
effects of one command.  Self-inserting input characters are an
exception.  The command loop makes a boundary for the first such
character; the next 19 consecutive self-inserting input characters do
not make boundaries, and then the 20th does, and so on as long as
self-inserting characters continue.

All buffer modifications add a boundary whenever the previous undoable
change was made in some other buffer.  This way, a command that modifies
several buffers makes a boundary in each buffer it changes.

Calling this function explicitly is useful for splitting the effects of
a command into more than one unit.  For example, @code{query-replace}
calls @code{undo-boundary} after each replacement, so that the user can
undo individual replacements one by one.
@end defun

@defun primitive-undo count list
This is the basic function for undoing elements of an undo list.
It undoes the first @var{count} elements of @var{list}, returning
the rest of @var{list}.  You could write this function in Lisp,
but it is convenient to have it in C.

@code{primitive-undo} adds elements to the buffer's undo list when it
changes the buffer.  Undo commands avoid confusion by saving the undo
list value at the beginning of a sequence of undo operations.  Then the
undo operations use and update the saved value.  The new elements added
by undoing are not part of this saved value, so they don't interfere with
continuing to undo.
@end defun

@node Maintaining Undo
@section Maintaining Undo Lists

  This section describes how to enable and disable undo information for
a given buffer.  It also explains how the undo list is truncated
automatically so it doesn't get too big.

  Recording of undo information in a newly created buffer is normally
enabled to start with; but if the buffer name starts with a space, the
undo recording is initially disabled.  You can explicitly enable or
disable undo recording with the following two functions, or by setting
@code{buffer-undo-list} yourself.

@deffn Command buffer-enable-undo &optional buffer-or-name
This command enables recording undo information for buffer
@var{buffer-or-name}, so that subsequent changes can be undone.  If no
argument is supplied, then the current buffer is used.  This function
does nothing if undo recording is already enabled in the buffer.  It
returns @code{nil}.

In an interactive call, @var{buffer-or-name} is the current buffer.
You cannot specify any other buffer.
@end deffn

@deffn Command buffer-disable-undo &optional buffer
@deffnx Command buffer-flush-undo &optional buffer
@cindex disable undo
This function discards the undo list of @var{buffer}, and disables
further recording of undo information.  As a result, it is no longer
possible to undo either previous changes or any subsequent changes.  If
the undo list of @var{buffer} is already disabled, this function
has no effect.

This function returns @code{nil}.  It cannot be called interactively.

The name @code{buffer-flush-undo} is not considered obsolete, but the
preferred name @code{buffer-disable-undo} is new as of Emacs versions
19.
@end deffn

  As editing continues, undo lists get longer and longer.  To prevent
them from using up all available memory space, garbage collection trims
them back to size limits you can set.  (For this purpose, the ``size''
of an undo list measures the cons cells that make up the list, plus the
strings of deleted text.)  Two variables control the range of acceptable
sizes: @code{undo-limit} and @code{undo-strong-limit}.

@defvar undo-limit
This is the soft limit for the acceptable size of an undo list.  The
change group at which this size is exceeded is the last one kept.
@end defvar

@defvar undo-strong-limit
This is the upper limit for the acceptable size of an undo list.  The
change group at which this size is exceeded is discarded itself (along
with all older change groups).  There is one exception: the very latest
change group is never discarded no matter how big it is.
@end defvar

@node Filling
@section Filling
@cindex filling, explicit

  @dfn{Filling} means adjusting the lengths of lines (by moving the line
breaks) so that they are nearly (but no greater than) a specified
maximum width.  Additionally, lines can be @dfn{justified}, which means
inserting spaces to make the left and/or right margins line up
precisely.  The width is controlled by the variable @code{fill-column}.
For ease of reading, lines should be no longer than 70 or so columns.

  You can use Auto Fill mode (@pxref{Auto Filling}) to fill text
automatically as you insert it, but changes to existing text may leave
it improperly filled.  Then you must fill the text explicitly.

  Most of the commands in this section return values that are not
meaningful.  All the functions that do filling take note of the current
left margin, current right margin, and current justification style
(@pxref{Margins}).  If the current justification style is
@code{none}, the filling functions don't actually do anything.

  Several of the filling functions have an argument @var{justify}.
If it is non-@code{nil}, that requests some kind of justification.  It
can be @code{left}, @code{right}, @code{full}, or @code{center}, to
request a specific style of justification.  If it is @code{t}, that
means to use the current justification style for this part of the text
(see @code{current-justification}, below).

  When you call the filling functions interactively, using a prefix
argument implies the value @code{full} for @var{justify}.

@deffn Command fill-paragraph justify
@cindex filling a paragraph
This command fills the paragraph at or after point.  If
@var{justify} is non-@code{nil}, each line is justified as well.
It uses the ordinary paragraph motion commands to find paragraph
boundaries.  @xref{Paragraphs,,, xemacs, The XEmacs User's Manual}.
@end deffn

@deffn Command fill-region start end &optional justify
This command fills each of the paragraphs in the region from @var{start}
to @var{end}.  It justifies as well if @var{justify} is
non-@code{nil}.

The variable @code{paragraph-separate} controls how to distinguish
paragraphs.  @xref{Standard Regexps}.
@end deffn

@deffn Command fill-individual-paragraphs start end &optional justify mail-flag
This command fills each paragraph in the region according to its
individual fill prefix.  Thus, if the lines of a paragraph were indented
with spaces, the filled paragraph will remain indented in the same
fashion.

The first two arguments, @var{start} and @var{end}, are the beginning
and end of the region to be filled.  The third and fourth arguments,
@var{justify} and @var{mail-flag}, are optional.  If
@var{justify} is non-@code{nil}, the paragraphs are justified as
well as filled.  If @var{mail-flag} is non-@code{nil}, it means the
function is operating on a mail message and therefore should not fill
the header lines.

Ordinarily, @code{fill-individual-paragraphs} regards each change in
indentation as starting a new paragraph.  If
@code{fill-individual-varying-indent} is non-@code{nil}, then only
separator lines separate paragraphs.  That mode can handle indented
paragraphs with additional indentation on the first line.
@end deffn

@defopt fill-individual-varying-indent
This variable alters the action of @code{fill-individual-paragraphs} as
described above.
@end defopt

@deffn Command fill-region-as-paragraph start end &optional justify
This command considers a region of text as a paragraph and fills it.  If
the region was made up of many paragraphs, the blank lines between
paragraphs are removed.  This function justifies as well as filling when
@var{justify} is non-@code{nil}.

In an interactive call, any prefix argument requests justification.

In Adaptive Fill mode, which is enabled by default,
@code{fill-region-as-paragraph} on an indented paragraph when there is
no fill prefix uses the indentation of the second line of the paragraph
as the fill prefix.
@end deffn

@deffn Command justify-current-line how eop nosqueeze
This command inserts spaces between the words of the current line so
that the line ends exactly at @code{fill-column}.  It returns
@code{nil}.

The argument @var{how}, if non-@code{nil} specifies explicitly the style
of justification.  It can be @code{left}, @code{right}, @code{full},
@code{center}, or @code{none}.  If it is @code{t}, that means to do
follow specified justification style (see @code{current-justification},
below).  @code{nil} means to do full justification.

If @var{eop} is non-@code{nil}, that means do left-justification when
@code{current-justification} specifies full justification.  This is used
for the last line of a paragraph; even if the paragraph as a whole is
fully justified, the last line should not be.

If @var{nosqueeze} is non-@code{nil}, that means do not change interior
whitespace.
@end deffn

@defopt default-justification
This variable's value specifies the style of justification to use for
text that doesn't specify a style with a text property.  The possible
values are @code{left}, @code{right}, @code{full}, @code{center}, or
@code{none}.  The default value is @code{left}.
@end defopt

@defun current-justification
This function returns the proper justification style to use for filling
the text around point.
@end defun

@defvar fill-paragraph-function
This variable provides a way for major modes to override the filling of
paragraphs.  If the value is non-@code{nil}, @code{fill-paragraph} calls
this function to do the work.  If the function returns a non-@code{nil}
value, @code{fill-paragraph} assumes the job is done, and immediately
returns that value.

The usual use of this feature is to fill comments in programming
language modes.  If the function needs to fill a paragraph in the usual
way, it can do so as follows:

@example
(let ((fill-paragraph-function nil))
  (fill-paragraph arg))
@end example
@end defvar

@defvar use-hard-newlines
If this variable is non-@code{nil}, the filling functions do not delete
newlines that have the @code{hard} text property.  These ``hard
newlines'' act as paragraph separators.
@end defvar

@node Margins
@section Margins for Filling

@defopt fill-prefix
This variable specifies a string of text that appears at the beginning
of normal text lines and should be disregarded when filling them.  Any
line that fails to start with the fill prefix is considered the start of
a paragraph; so is any line that starts with the fill prefix followed by
additional whitespace.  Lines that start with the fill prefix but no
additional whitespace are ordinary text lines that can be filled
together.  The resulting filled lines also start with the fill prefix.

The fill prefix follows the left margin whitespace, if any.
@end defopt

@defopt fill-column
This buffer-local variable specifies the maximum width of filled
lines.  Its value should be an integer, which is a number of columns.
All the filling, justification and centering commands are affected by
this variable, including Auto Fill mode (@pxref{Auto Filling}).

As a practical matter, if you are writing text for other people to
read, you should set @code{fill-column} to no more than 70.  Otherwise
the line will be too long for people to read comfortably, and this can
make the text seem clumsy.
@end defopt

@defvar default-fill-column
The value of this variable is the default value for @code{fill-column} in
buffers that do not override it.  This is the same as
@code{(default-value 'fill-column)}.

The default value for @code{default-fill-column} is 70.
@end defvar

@deffn Command set-left-margin from to margin
This sets the @code{left-margin} property on the text from @var{from} to
@var{to} to the value @var{margin}.  If Auto Fill mode is enabled, this
command also refills the region to fit the new margin.
@end deffn

@deffn Command set-right-margin from to margin
This sets the @code{right-margin} property on the text from @var{from}
to @var{to} to the value @var{margin}.  If Auto Fill mode is enabled,
this command also refills the region to fit the new margin.
@end deffn

@defun current-left-margin
This function returns the proper left margin value to use for filling
the text around point.  The value is the sum of the @code{left-margin}
property of the character at the start of the current line (or zero if
none), and the value of the variable @code{left-margin}.
@end defun

@defun current-fill-column
This function returns the proper fill column value to use for filling
the text around point.  The value is the value of the @code{fill-column}
variable, minus the value of the @code{right-margin} property of the
character after point.
@end defun

@deffn Command move-to-left-margin &optional n force
This function moves point to the left margin of the current line.  The
column moved to is determined by calling the function
@code{current-left-margin}.  If the argument @var{n} is non-@code{nil},
@code{move-to-left-margin} moves forward @var{n}@minus{}1 lines first.

If @var{force} is non-@code{nil}, that says to fix the line's
indentation if that doesn't match the left margin value.
@end deffn

@defun delete-to-left-margin &optional from to
This function removes left margin indentation from the text
between @var{from} and @var{to}.  The amount of indentation
to delete is determined by calling @code{current-left-margin}.
In no case does this function delete non-whitespace.

The arguments @var{from} and @var{to} are optional; the default is the
whole buffer.
@end defun

@defun indent-to-left-margin
This is the default @code{indent-line-function}, used in Fundamental
mode, Text mode, etc.  Its effect is to adjust the indentation at the
beginning of the current line to the value specified by the variable
@code{left-margin}.  This may involve either inserting or deleting
whitespace.
@end defun

@defvar left-margin
This variable specifies the base left margin column.  In Fundamental
mode, @key{LFD} indents to this column.  This variable automatically
becomes buffer-local when set in any fashion.
@end defvar

@node Auto Filling
@section Auto Filling
@cindex filling, automatic
@cindex Auto Fill mode

  Auto Fill mode is a minor mode that fills lines automatically as text
is inserted.  This section describes the hook used by Auto Fill mode.
For a description of functions that you can call explicitly to fill and
justify existing text, see @ref{Filling}.

  Auto Fill mode also enables the functions that change the margins and
justification style to refill portions of the text.  @xref{Margins}.

@defvar auto-fill-function
The value of this variable should be a function (of no arguments) to be
called after self-inserting a space or a newline.  It may be @code{nil},
in which case nothing special is done in that case.

The value of @code{auto-fill-function} is @code{do-auto-fill} when
Auto-Fill mode is enabled.  That is a function whose sole purpose is to
implement the usual strategy for breaking a line.

@quotation
In older Emacs versions, this variable was named @code{auto-fill-hook},
but since it is not called with the standard convention for hooks, it
was renamed to @code{auto-fill-function} in version 19.
@end quotation
@end defvar

@node Sorting
@section Sorting Text
@cindex sorting text

  The sorting functions described in this section all rearrange text in
a buffer.  This is in contrast to the function @code{sort}, which
rearranges the order of the elements of a list (@pxref{Rearrangement}).
The values returned by these functions are not meaningful.

@defun sort-subr reverse nextrecfun endrecfun &optional startkeyfun endkeyfun
This function is the general text-sorting routine that divides a buffer
into records and sorts them.  Most of the commands in this section use
this function.

To understand how @code{sort-subr} works, consider the whole accessible
portion of the buffer as being divided into disjoint pieces called
@dfn{sort records}.  The records may or may not be contiguous; they may
not overlap.  A portion of each sort record (perhaps all of it) is
designated as the sort key.  Sorting rearranges the records in order by
their sort keys.

Usually, the records are rearranged in order of ascending sort key.
If the first argument to the @code{sort-subr} function, @var{reverse},
is non-@code{nil}, the sort records are rearranged in order of
descending sort key.

The next four arguments to @code{sort-subr} are functions that are
called to move point across a sort record.  They are called many times
from within @code{sort-subr}.

@enumerate
@item
@var{nextrecfun} is called with point at the end of a record.  This
function moves point to the start of the next record.  The first record
is assumed to start at the position of point when @code{sort-subr} is
called.  Therefore, you should usually move point to the beginning of
the buffer before calling @code{sort-subr}.

This function can indicate there are no more sort records by leaving
point at the end of the buffer.

@item
@var{endrecfun} is called with point within a record.  It moves point to
the end of the record.

@item
@var{startkeyfun} is called to move point from the start of a record to
the start of the sort key.  This argument is optional; if it is omitted,
the whole record is the sort key.  If supplied, the function should
either return a non-@code{nil} value to be used as the sort key, or
return @code{nil} to indicate that the sort key is in the buffer
starting at point.  In the latter case, @var{endkeyfun} is called to
find the end of the sort key.

@item
@var{endkeyfun} is called to move point from the start of the sort key
to the end of the sort key.  This argument is optional.  If
@var{startkeyfun} returns @code{nil} and this argument is omitted (or
@code{nil}), then the sort key extends to the end of the record.  There
is no need for @var{endkeyfun} if @var{startkeyfun} returns a
non-@code{nil} value.
@end enumerate

As an example of @code{sort-subr}, here is the complete function
definition for @code{sort-lines}:

@example
@group
;; @r{Note that the first two lines of doc string}
;; @r{are effectively one line when viewed by a user.}
(defun sort-lines (reverse start end)
  "Sort lines in region alphabetically.
Called from a program, there are three arguments:
@end group
@group
REVERSE (non-nil means reverse order),
and START and END (the region to sort)."
  (interactive "P\nr")
  (save-restriction
    (narrow-to-region start end)
    (goto-char (point-min))
    (sort-subr reverse
               'forward-line
               'end-of-line)))
@end group
@end example

Here @code{forward-line} moves point to the start of the next record,
and @code{end-of-line} moves point to the end of record.  We do not pass
the arguments @var{startkeyfun} and @var{endkeyfun}, because the entire
record is used as the sort key.

The @code{sort-paragraphs} function is very much the same, except that
its @code{sort-subr} call looks like this:

@example
@group
(sort-subr reverse
           (function
            (lambda ()
              (skip-chars-forward "\n \t\f")))
           'forward-paragraph)
@end group
@end example
@end defun

@deffn Command sort-regexp-fields reverse record-regexp key-regexp start end
This command sorts the region between @var{start} and @var{end}
alphabetically as specified by @var{record-regexp} and @var{key-regexp}.
If @var{reverse} is a negative integer, then sorting is in reverse
order.

Alphabetical sorting means that two sort keys are compared by
comparing the first characters of each, the second characters of each,
and so on.  If a mismatch is found, it means that the sort keys are
unequal; the sort key whose character is less at the point of first
mismatch is the lesser sort key.  The individual characters are compared
according to their numerical values.  Since Emacs uses the @sc{ascii}
character set, the ordering in that set determines alphabetical order.
@c version 19 change

The value of the @var{record-regexp} argument specifies how to divide
the buffer into sort records.  At the end of each record, a search is
done for this regular expression, and the text that matches it is the
next record.  For example, the regular expression @samp{^.+$}, which
matches lines with at least one character besides a newline, would make
each such line into a sort record.  @xref{Regular Expressions}, for a
description of the syntax and meaning of regular expressions.

The value of the @var{key-regexp} argument specifies what part of each
record is the sort key.  The @var{key-regexp} could match the whole
record, or only a part.  In the latter case, the rest of the record has
no effect on the sorted order of records, but it is carried along when
the record moves to its new position.

The @var{key-regexp} argument can refer to the text matched by a
subexpression of @var{record-regexp}, or it can be a regular expression
on its own.

If @var{key-regexp} is:

@table @asis
@item @samp{\@var{digit}}
then the text matched by the @var{digit}th @samp{\(...\)} parenthesis
grouping in @var{record-regexp} is the sort key.

@item @samp{\&}
then the whole record is the sort key.

@item a regular expression
then @code{sort-regexp-fields} searches for a match for the regular
expression within the record.  If such a match is found, it is the sort
key.  If there is no match for @var{key-regexp} within a record then
that record is ignored, which means its position in the buffer is not
changed.  (The other records may move around it.)
@end table

For example, if you plan to sort all the lines in the region by the
first word on each line starting with the letter @samp{f}, you should
set @var{record-regexp} to @samp{^.*$} and set @var{key-regexp} to
@samp{\<f\w*\>}.  The resulting expression looks like this:

@example
@group
(sort-regexp-fields nil "^.*$" "\\<f\\w*\\>"
                    (region-beginning)
                    (region-end))
@end group
@end example

If you call @code{sort-regexp-fields} interactively, it prompts for
@var{record-regexp} and @var{key-regexp} in the minibuffer.
@end deffn

@deffn Command sort-lines reverse start end
This command alphabetically sorts lines in the region between
@var{start} and @var{end}.  If @var{reverse} is non-@code{nil}, the sort
is in reverse order.
@end deffn

@deffn Command sort-paragraphs reverse start end
This command alphabetically sorts paragraphs in the region between
@var{start} and @var{end}.  If @var{reverse} is non-@code{nil}, the sort
is in reverse order.
@end deffn

@deffn Command sort-pages reverse start end
This command alphabetically sorts pages in the region between
@var{start} and @var{end}.  If @var{reverse} is non-@code{nil}, the sort
is in reverse order.
@end deffn

@deffn Command sort-fields field start end
This command sorts lines in the region between @var{start} and
@var{end}, comparing them alphabetically by the @var{field}th field
of each line.  Fields are separated by whitespace and numbered starting
from 1.  If @var{field} is negative, sorting is by the
@w{@minus{}@var{field}th} field from the end of the line.  This command
is useful for sorting tables.
@end deffn

@deffn Command sort-numeric-fields field start end
This command sorts lines in the region between @var{start} and
@var{end}, comparing them numerically by the @var{field}th field of each
line.  The specified field must contain a number in each line of the
region.  Fields are separated by whitespace and numbered starting from
1.  If @var{field} is negative, sorting is by the
@w{@minus{}@var{field}th} field from the end of the line.  This command
is useful for sorting tables.
@end deffn

@deffn Command sort-columns reverse &optional start end
This command sorts the lines in the region between @var{start} and
@var{end}, comparing them alphabetically by a certain range of columns.
The column positions of @var{start} and @var{end} bound the range of
columns to sort on.

If @var{reverse} is non-@code{nil}, the sort is in reverse order.

One unusual thing about this command is that the entire line
containing position @var{start}, and the entire line containing position
@var{end}, are included in the region sorted.

Note that @code{sort-columns} uses the @code{sort} utility program,
and so cannot work properly on text containing tab characters.  Use
@kbd{M-x @code{untabify}} to convert tabs to spaces before sorting.
@end deffn

@node Columns
@comment  node-name,  next,  previous,  up
@section Counting Columns
@cindex columns
@cindex counting columns
@cindex horizontal position

  The column functions convert between a character position (counting
characters from the beginning of the buffer) and a column position
(counting screen characters from the beginning of a line).

  A character counts according to the number of columns it occupies on
the screen.  This means control characters count as occupying 2 or 4
columns, depending upon the value of @code{ctl-arrow}, and tabs count as
occupying a number of columns that depends on the value of
@code{tab-width} and on the column where the tab begins.  @xref{Usual Display}.

  Column number computations ignore the width of the window and the
amount of horizontal scrolling.  Consequently, a column value can be
arbitrarily high.  The first (or leftmost) column is numbered 0.

@defun current-column &optional buffer
This function returns the horizontal position of point, measured in
columns, counting from 0 at the left margin.

This is calculated by adding together the widths of all the displayed
representations of the character between the start of the previous line
and point. (e.g. control characters will have a width of 2 or 4, tabs
will have a variable width.)

Ignores the finite width of frame displaying the buffer, which means
that this function may return values greater than
@code{(frame-width)}.

Whether the line is visible (if @code{selective-display} is t) has no effect;
however, ^M is treated as end of line when @code{selective-display} is t.

If @var{buffer} is nil, the current buffer is assumed.

For an example of using @code{current-column}, see the description of
@code{count-lines} in @ref{Text Lines}.
@end defun

@defun move-to-column column &optional force buffer
This function moves point to @var{column} in the current line.  The
calculation of @var{column} takes into account the widths of the
displayed representations of the characters between the start of the
line and point.

If column @var{column} is beyond the end of the line, point moves to the
end of the line.  If @var{column} is negative, point moves to the
beginning of the line.

If it is impossible to move to column @var{column} because that is in
the middle of a multicolumn character such as a tab, point moves to the
end of that character.  However, if @var{force} is non-@code{nil}, and
@var{column} is in the middle of a tab, then @code{move-to-column}
converts the tab into spaces so that it can move precisely to column
@var{column}.  Other multicolumn characters can cause anomalies despite
@var{force}, since there is no way to split them.

The argument @var{force} also has an effect if the line isn't long
enough to reach column @var{column}; in that case, unless the value of
@var{force} is the special value @code{coerce}, it says to add
whitespace at the end of the line to reach that column.

If @var{column} is not a non-negative integer, an error is signaled.

The return value is the column number actually moved to.
@end defun

@node Indentation
@section Indentation
@cindex indentation

  The indentation functions are used to examine, move to, and change
whitespace that is at the beginning of a line.  Some of the functions
can also change whitespace elsewhere on a line.  Columns and indentation
count from zero at the left margin.

@menu
* Primitive Indent::      Functions used to count and insert indentation.
* Mode-Specific Indent::  Customize indentation for different modes.
* Region Indent::         Indent all the lines in a region.
* Relative Indent::       Indent the current line based on previous lines.
* Indent Tabs::           Adjustable, typewriter-like tab stops.
* Motion by Indent::      Move to first non-blank character.
@end menu

@node Primitive Indent
@subsection Indentation Primitives

  This section describes the primitive functions used to count and
insert indentation.  The functions in the following sections use these
primitives.

@defun current-indentation &optional buffer
@comment !!Type Primitive Function
@comment !!SourceFile indent.c
This function returns the indentation of the current line, which is
the horizontal position of the first nonblank character.  If the
contents are entirely blank, then this is the horizontal position of the
end of the line.
@end defun

@deffn Command indent-to column &optional minimum buffer
@comment !!Type Primitive Function
@comment !!SourceFile indent.c
This function indents from point with tabs and spaces until @var{column}
is reached.  If @var{minimum} is specified and non-@code{nil}, then at
least that many spaces are inserted even if this requires going beyond
@var{column}.  Otherwise the function does nothing if point is already
beyond @var{column}.  The value is the column at which the inserted
indentation ends.  If @var{buffer} is @code{nil}, the current buffer is assumed.
@end deffn

@defopt indent-tabs-mode
@comment !!SourceFile indent.c
If this variable is non-@code{nil}, indentation functions can insert
tabs as well as spaces.  Otherwise, they insert only spaces.  Setting
this variable automatically makes it local to the current buffer.
@end defopt

@node Mode-Specific Indent
@subsection Indentation Controlled by Major Mode

  An important function of each major mode is to customize the @key{TAB}
key to indent properly for the language being edited.  This section
describes the mechanism of the @key{TAB} key and how to control it.
The functions in this section return unpredictable values.

@defvar indent-line-function
This variable's value is the function to be used by @key{TAB} (and
various commands) to indent the current line.  The command
@code{indent-according-to-mode} does no more than call this function.

In Lisp mode, the value is the symbol @code{lisp-indent-line}; in C
mode, @code{c-indent-line}; in Fortran mode, @code{fortran-indent-line}.
In Fundamental mode, Text mode, and many other modes with no standard
for indentation, the value is @code{indent-to-left-margin} (which is the
default value).
@end defvar

@deffn Command indent-according-to-mode
This command calls the function in @code{indent-line-function} to
indent the current line in a way appropriate for the current major mode.
@end deffn

@deffn Command indent-for-tab-command &optional prefix-arg
This command calls the function in @code{indent-line-function} to indent
the current line; except that if that function is
@code{indent-to-left-margin}, it calls @code{insert-tab} instead.  (That
is a trivial command that inserts a tab character.)
@end deffn

@deffn Command newline-and-indent
@comment !!SourceFile simple.el
This function inserts a newline, then indents the new line (the one
following the newline just inserted) according to the major mode.

It does indentation by calling the current @code{indent-line-function}.
In programming language modes, this is the same thing @key{TAB} does,
but in some text modes, where @key{TAB} inserts a tab,
@code{newline-and-indent} indents to the column specified by
@code{left-margin}.
@end deffn

@deffn Command reindent-then-newline-and-indent
@comment !!SourceFile simple.el
This command reindents the current line, inserts a newline at point,
and then reindents the new line (the one following the newline just
inserted).

This command does indentation on both lines according to the current
major mode, by calling the current value of @code{indent-line-function}.
In programming language modes, this is the same thing @key{TAB} does,
but in some text modes, where @key{TAB} inserts a tab,
@code{reindent-then-newline-and-indent} indents to the column specified
by @code{left-margin}.
@end deffn

@node Region Indent
@subsection Indenting an Entire Region

  This section describes commands that indent all the lines in the
region.  They return unpredictable values.

@deffn Command indent-region start end to-column
This command indents each nonblank line starting between @var{start}
(inclusive) and @var{end} (exclusive).  If @var{to-column} is
@code{nil}, @code{indent-region} indents each nonblank line by calling
the current mode's indentation function, the value of
@code{indent-line-function}.

If @var{to-column} is non-@code{nil}, it should be an integer
specifying the number of columns of indentation; then this function
gives each line exactly that much indentation, by either adding or
deleting whitespace.

If there is a fill prefix, @code{indent-region} indents each line
by making it start with the fill prefix.
@end deffn

@defvar indent-region-function
The value of this variable is a function that can be used by
@code{indent-region} as a short cut.  You should design the function so
that it will produce the same results as indenting the lines of the
region one by one, but presumably faster.

If the value is @code{nil}, there is no short cut, and
@code{indent-region} actually works line by line.

A short-cut function is useful in modes such as C mode and Lisp mode,
where the @code{indent-line-function} must scan from the beginning of
the function definition: applying it to each line would be quadratic in
time.  The short cut can update the scan information as it moves through
the lines indenting them; this takes linear time.  In a mode where
indenting a line individually is fast, there is no need for a short cut.

@code{indent-region} with a non-@code{nil} argument @var{to-column} has
a different meaning and does not use this variable.
@end defvar

@deffn Command indent-rigidly start end count
@comment !!SourceFile indent.el
This command indents all lines starting between @var{start}
(inclusive) and @var{end} (exclusive) sideways by @var{count} columns.
This ``preserves the shape'' of the affected region, moving it as a
rigid unit.  Consequently, this command is useful not only for indenting
regions of unindented text, but also for indenting regions of formatted
code.

For example, if @var{count} is 3, this command adds 3 columns of
indentation to each of the lines beginning in the region specified.

In Mail mode, @kbd{C-c C-y} (@code{mail-yank-original}) uses
@code{indent-rigidly} to indent the text copied from the message being
replied to.
@end deffn

@deffn Command indent-code-rigidly start end columns &optional nochange-regexp
This is like @code{indent-rigidly}, except that it doesn't alter lines
that start within strings or comments.

In addition, it doesn't alter a line if @var{nochange-regexp} matches at
the beginning of the line (if @var{nochange-regexp} is non-@code{nil}).
@end deffn

@node Relative Indent
@subsection Indentation Relative to Previous Lines

  This section describes two commands that indent the current line
based on the contents of previous lines.

@deffn Command indent-relative &optional unindented-ok
This command inserts whitespace at point, extending to the same
column as the next @dfn{indent point} of the previous nonblank line.  An
indent point is a non-whitespace character following whitespace.  The
next indent point is the first one at a column greater than the current
column of point.  For example, if point is underneath and to the left of
the first non-blank character of a line of text, it moves to that column
by inserting whitespace.

If the previous nonblank line has no next indent point (i.e., none at a
great enough column position), @code{indent-relative} either does
nothing (if @var{unindented-ok} is non-@code{nil}) or calls
@code{tab-to-tab-stop}.  Thus, if point is underneath and to the right
of the last column of a short line of text, this command ordinarily
moves point to the next tab stop by inserting whitespace.

The return value of @code{indent-relative} is unpredictable.

In the following example, point is at the beginning of the second
line:

@example
@group
            This line is indented twelve spaces.
@point{}The quick brown fox jumped.
@end group
@end example

@noindent
Evaluation of the expression @code{(indent-relative nil)} produces the
following:

@example
@group
            This line is indented twelve spaces.
            @point{}The quick brown fox jumped.
@end group
@end example

  In this example, point is between the @samp{m} and @samp{p} of
@samp{jumped}:

@example
@group
            This line is indented twelve spaces.
The quick brown fox jum@point{}ped.
@end group
@end example

@noindent
Evaluation of the expression @code{(indent-relative nil)} produces the
following:

@example
@group
            This line is indented twelve spaces.
The quick brown fox jum  @point{}ped.
@end group
@end example
@end deffn

@deffn Command indent-relative-maybe
@comment !!SourceFile indent.el
This command indents the current line like the previous nonblank line.
It calls @code{indent-relative} with @code{t} as the @var{unindented-ok}
argument.  The return value is unpredictable.

If the previous nonblank line has no indent points beyond the current
column, this command does nothing.
@end deffn

@node Indent Tabs
@subsection Adjustable ``Tab Stops''
@cindex tabs stops for indentation

  This section explains the mechanism for user-specified ``tab stops''
and the mechanisms that use and set them.  The name ``tab stops'' is
used because the feature is similar to that of the tab stops on a
typewriter.  The feature works by inserting an appropriate number of
spaces and tab characters to reach the next tab stop column; it does not
affect the display of tab characters in the buffer (@pxref{Usual
Display}).  Note that the @key{TAB} character as input uses this tab
stop feature only in a few major modes, such as Text mode.

@deffn Command tab-to-tab-stop
This command inserts spaces or tabs up to the next tab stop column
defined by @code{tab-stop-list}.  It searches the list for an element
greater than the current column number, and uses that element as the
column to indent to.  It does nothing if no such element is found.
@end deffn

@defopt tab-stop-list
This variable is the list of tab stop columns used by
@code{tab-to-tab-stops}.  The elements should be integers in increasing
order.  The tab stop columns need not be evenly spaced.

Use @kbd{M-x edit-tab-stops} to edit the location of tab stops
interactively.
@end defopt

@node Motion by Indent
@subsection Indentation-Based Motion Commands

  These commands, primarily for interactive use, act based on the
indentation in the text.

@deffn Command back-to-indentation
@comment !!SourceFile simple.el
This command moves point to the first non-whitespace character in the
current line (which is the line in which point is located).  It returns
@code{nil}.
@end deffn

@deffn Command backward-to-indentation arg
@comment !!SourceFile simple.el
This command moves point backward @var{arg} lines and then to the
first nonblank character on that line.  It returns @code{nil}.
@end deffn

@deffn Command forward-to-indentation arg
@comment !!SourceFile simple.el
This command moves point forward @var{arg} lines and then to the first
nonblank character on that line.  It returns @code{nil}.
@end deffn

@node Case Changes
@section Case Changes
@cindex case changes

  The case change commands described here work on text in the current
buffer.  @xref{Character Case}, for case conversion commands that work
on strings and characters.  @xref{Case Tables}, for how to customize
which characters are upper or lower case and how to convert them.

@deffn Command capitalize-region start end &optional buffer
This function capitalizes all words in the region defined by
@var{start} and @var{end}.  To capitalize means to convert each word's
first character to upper case and convert the rest of each word to lower
case.  The function returns @code{nil}.

If one end of the region is in the middle of a word, the part of the
word within the region is treated as an entire word.

When @code{capitalize-region} is called interactively, @var{start} and
@var{end} are point and the mark, with the smallest first.

@example
@group
---------- Buffer: foo ----------
This is the contents of the 5th foo.
---------- Buffer: foo ----------
@end group

@group
(capitalize-region 1 44)
@result{} nil

---------- Buffer: foo ----------
This Is The Contents Of The 5th Foo.
---------- Buffer: foo ----------
@end group
@end example
@end deffn

@deffn Command downcase-region start end &optional buffer
This function converts all of the letters in the region defined by
@var{start} and @var{end} to lower case.  The function returns
@code{nil}.

When @code{downcase-region} is called interactively, @var{start} and
@var{end} are point and the mark, with the smallest first.
@end deffn

@deffn Command upcase-region start end &optional buffer
This function converts all of the letters in the region defined by
@var{start} and @var{end} to upper case.  The function returns
@code{nil}.

When @code{upcase-region} is called interactively, @var{start} and
@var{end} are point and the mark, with the smallest first.
@end deffn

@deffn Command capitalize-word count &optional buffer
This function capitalizes @var{count} words after point, moving point
over as it does.  To capitalize means to convert each word's first
character to upper case and convert the rest of each word to lower case.
If @var{count} is negative, the function capitalizes the
@minus{}@var{count} previous words but does not move point.  The value
is @code{nil}.

If point is in the middle of a word, the part of the word before point
is ignored when moving forward.  The rest is treated as an entire word.

When @code{capitalize-word} is called interactively, @var{count} is
set to the numeric prefix argument.
@end deffn

@deffn Command downcase-word count &optional buffer
This function converts the @var{count} words after point to all lower
case, moving point over as it does.  If @var{count} is negative, it
converts the @minus{}@var{count} previous words but does not move point.
The value is @code{nil}.

When @code{downcase-word} is called interactively, @var{count} is set
to the numeric prefix argument.
@end deffn

@deffn Command upcase-word count &optional buffer
This function converts the @var{count} words after point to all upper
case, moving point over as it does.  If @var{count} is negative, it
converts the @minus{}@var{count} previous words but does not move point.
The value is @code{nil}.

When @code{upcase-word} is called interactively, @var{count} is set to
the numeric prefix argument.
@end deffn

@node Text Properties
@section Text Properties
@cindex text properties
@cindex attributes of text
@cindex properties of text

  Text properties are an alternative interface to extents
(@pxref{Extents}), and are built on top of them.  They are useful when
you want to view textual properties as being attached to the characters
themselves rather than to intervals of characters.  The text property
interface is compatible with FSF Emacs.

  Each character position in a buffer or a string can have a @dfn{text
property list}, much like the property list of a symbol (@pxref{Property
Lists}).  The properties belong to a particular character at a
particular place, such as, the letter @samp{T} at the beginning of this
sentence or the first @samp{o} in @samp{foo}---if the same character
occurs in two different places, the two occurrences generally have
different properties.

  Each property has a name and a value.  Both of these can be any Lisp
object, but the name is normally a symbol.  The usual way to access the
property list is to specify a name and ask what value corresponds to it.

@ignore
  If a character has a @code{category} property, we call it the
@dfn{category} of the character.  It should be a symbol.  The properties
of the symbol serve as defaults for the properties of the character.
@end ignore
  Note that FSF Emacs also looks at the @code{category} property to find
defaults for text properties.  We consider this too bogus to implement.

  Copying text between strings and buffers preserves the properties
along with the characters; this includes such diverse functions as
@code{substring}, @code{insert}, and @code{buffer-substring}.

@menu
* Examining Properties::	Looking at the properties of one character.
* Changing Properties::		Setting the properties of a range of text.
* Property Search::		Searching for where a property changes value.
* Special Properties::		Particular properties with special meanings.
* Saving Properties::           Saving text properties in files, and reading
                                  them back.
* Fields::			Emacs-compatible text fields.
@end menu

@node Examining Properties
@subsection Examining Text Properties

  The simplest way to examine text properties is to ask for the value of
a particular property of a particular character.  For that, use
@code{get-text-property}.  Use @code{text-properties-at} to get the
entire property list of a character.  @xref{Property Search}, for
functions to examine the properties of a number of characters at once.

  These functions handle both strings and buffers.  (Keep in mind that
positions in a string start from 0, whereas positions in a buffer start
from 1.)

@defun get-text-property pos prop &optional object at-flag
This function returns the value of the @var{prop} property of the
character after position @var{pos} in @var{object} (a buffer or string).
The argument @var{object} is optional and defaults to the current
buffer.
@ignore @c Bogus as hell!
If there is no @var{prop} property strictly speaking, but the character
has a category that is a symbol, then @code{get-text-property} returns
the @var{prop} property of that symbol.
@end ignore
@end defun

@defun get-char-property pos prop &optional object at-flag
This function is like @code{get-text-property}, except that it checks
all extents, not just text-property extents.

@ignore Does not apply in XEmacs
The argument @var{object} may be a string, a buffer, or a window.  If it
is a window, then the buffer displayed in that window is used for text
properties and overlays, but only the overlays active for that window
are considered.  If @var{object} is a buffer, then all overlays in that
buffer are considered, as well as text properties.  If @var{object} is a
string, only text properties are considered, since strings never have
overlays.
@end ignore
@end defun

@defun text-properties-at position &optional object
This function returns the entire property list of the character at
@var{position} in the string or buffer @var{object}.  If @var{object} is
@code{nil}, it defaults to the current buffer.
@end defun

@defvar default-text-properties
This variable holds a property list giving default values for text
properties.  Whenever a character does not specify a value for a
property, the value stored in this list is used instead.  Here is
an example:

@example
(setq default-text-properties '(foo 69))
;; @r{Make sure character 1 has no properties of its own.}
(set-text-properties 1 2 nil)
;; @r{What we get, when we ask, is the default value.}
(get-text-property 1 'foo)
     @result{} 69
@end example
@end defvar

@node Changing Properties
@subsection Changing Text Properties

  The primitives for changing properties apply to a specified range of
text.  The function @code{set-text-properties} (see end of section) sets
the entire property list of the text in that range; more often, it is
useful to add, change, or delete just certain properties specified by
name.

  Since text properties are considered part of the buffer's contents, and
can affect how the buffer looks on the screen, any change in the text
properties is considered a buffer modification.  Buffer text property
changes are undoable (@pxref{Undo}).

@defun put-text-property start end prop value &optional object
This function sets the @var{prop} property to @var{value} for the text
between @var{start} and @var{end} in the string or buffer @var{object}.
If @var{object} is @code{nil}, it defaults to the current buffer.
@end defun

@defun add-text-properties start end props &optional object
This function modifies the text properties for the text between
@var{start} and @var{end} in the string or buffer @var{object}.  If
@var{object} is @code{nil}, it defaults to the current buffer.

The argument @var{props} specifies which properties to change.  It
should have the form of a property list (@pxref{Property Lists}): a list
whose elements include the property names followed alternately by the
corresponding values.

The return value is @code{t} if the function actually changed some
property's value; @code{nil} otherwise (if @var{props} is @code{nil} or
its values agree with those in the text).

For example, here is how to set the @code{comment} and @code{face}
properties of a range of text:

@example
(add-text-properties @var{start} @var{end}
                     '(comment t face highlight))
@end example
@end defun

@defun remove-text-properties start end props &optional object
This function deletes specified text properties from the text between
@var{start} and @var{end} in the string or buffer @var{object}.  If
@var{object} is @code{nil}, it defaults to the current buffer.

The argument @var{props} specifies which properties to delete.  It
should have the form of a property list (@pxref{Property Lists}): a list
whose elements are property names alternating with corresponding values.
But only the names matter---the values that accompany them are ignored.
For example, here's how to remove the @code{face} property.

@example
(remove-text-properties @var{start} @var{end} '(face nil))
@end example

The return value is @code{t} if the function actually changed some
property's value; @code{nil} otherwise (if @var{props} is @code{nil} or
if no character in the specified text had any of those properties).
@end defun

@defun set-text-properties start end props &optional object
This function completely replaces the text property list for the text
between @var{start} and @var{end} in the string or buffer @var{object}.
If @var{object} is @code{nil}, it defaults to the current buffer.

The argument @var{props} is the new property list.  It should be a list
whose elements are property names alternating with corresponding values.

After @code{set-text-properties} returns, all the characters in the
specified range have identical properties.

If @var{props} is @code{nil}, the effect is to get rid of all properties
from the specified range of text.  Here's an example:

@example
(set-text-properties @var{start} @var{end} nil)
@end example
@end defun

See also the function @code{buffer-substring-without-properties}
(@pxref{Buffer Contents}) which copies text from the buffer
but does not copy its properties.

@node Property Search
@subsection Property Search Functions

In typical use of text properties, most of the time several or many
consecutive characters have the same value for a property.  Rather than
writing your programs to examine characters one by one, it is much
faster to process chunks of text that have the same property value.

Here are functions you can use to do this.  They use @code{eq} for
comparing property values.  In all cases, @var{object} defaults to the
current buffer.

For high performance, it's very important to use the @var{limit}
argument to these functions, especially the ones that search for a
single property---otherwise, they may spend a long time scanning to the
end of the buffer, if the property you are interested in does not change.

Remember that a position is always between two characters; the position
returned by these functions is between two characters with different
properties.

@defun next-property-change pos &optional object limit
The function scans the text forward from position @var{pos} in the
string or buffer @var{object} till it finds a change in some text
property, then returns the position of the change.  In other words, it
returns the position of the first character beyond @var{pos} whose
properties are not identical to those of the character just after
@var{pos}.

If @var{limit} is non-@code{nil}, then the scan ends at position
@var{limit}.  If there is no property change before that point,
@code{next-property-change} returns @var{limit}.

The value is @code{nil} if the properties remain unchanged all the way
to the end of @var{object} and @var{limit} is @code{nil}.  If the value
is non-@code{nil}, it is a position greater than or equal to @var{pos}.
The value equals @var{pos} only when @var{limit} equals @var{pos}.

Here is an example of how to scan the buffer by chunks of text within
which all properties are constant:

@smallexample
(while (not (eobp))
  (let ((plist (text-properties-at (point)))
        (next-change
         (or (next-property-change (point) (current-buffer))
             (point-max))))
    @r{Process text from point to @var{next-change}@dots{}}
    (goto-char next-change)))
@end smallexample
@end defun

@defun next-single-property-change pos prop &optional object limit
The function scans the text forward from position @var{pos} in the
string or buffer @var{object} till it finds a change in the @var{prop}
property, then returns the position of the change.  In other words, it
returns the position of the first character beyond @var{pos} whose
@var{prop} property differs from that of the character just after
@var{pos}.

If @var{limit} is non-@code{nil}, then the scan ends at position
@var{limit}.  If there is no property change before that point,
@code{next-single-property-change} returns @var{limit}.

The value is @code{nil} if the property remains unchanged all the way to
the end of @var{object} and @var{limit} is @code{nil}.  If the value is
non-@code{nil}, it is a position greater than or equal to @var{pos}; it
equals @var{pos} only if @var{limit} equals @var{pos}.
@end defun

@defun previous-property-change pos &optional object limit
This is like @code{next-property-change}, but scans backward from @var{pos}
instead of forward.  If the value is non-@code{nil}, it is a position
less than or equal to @var{pos}; it equals @var{pos} only if @var{limit}
equals @var{pos}.
@end defun

@defun previous-single-property-change pos prop &optional object limit
This is like @code{next-single-property-change}, but scans backward from
@var{pos} instead of forward.  If the value is non-@code{nil}, it is a
position less than or equal to @var{pos}; it equals @var{pos} only if
@var{limit} equals @var{pos}.
@end defun

@defun text-property-any start end prop value &optional object
This function returns non-@code{nil} if at least one character between
@var{start} and @var{end} has a property @var{prop} whose value is
@var{value}.  More precisely, it returns the position of the first such
character.  Otherwise, it returns @code{nil}.

The optional fifth argument, @var{object}, specifies the string or
buffer to scan.  Positions are relative to @var{object}.  The default
for @var{object} is the current buffer.
@end defun

@defun text-property-not-all start end prop value &optional object
This function returns non-@code{nil} if at least one character between
@var{start} and @var{end} has a property @var{prop} whose value differs
from @var{value}.  More precisely, it returns the position of the
first such character.  Otherwise, it returns @code{nil}.

The optional fifth argument, @var{object}, specifies the string or
buffer to scan.  Positions are relative to @var{object}.  The default
for @var{object} is the current buffer.
@end defun

@node Special Properties
@subsection Properties with Special Meanings

The predefined properties are the same as those for extents.
@xref{Extent Properties}.

@ignore  Changed in XEmacs
(deleted section describing FSF Emacs special text properties)
@end ignore

@node Saving Properties
@subsection Saving Text Properties in Files
@cindex text properties in files
@cindex saving text properties

  You can save text properties in files, and restore text properties
when inserting the files, using these two hooks:

@defvar write-region-annotate-functions
This variable's value is a list of functions for @code{write-region} to
run to encode text properties in some fashion as annotations to the text
being written in the file.  @xref{Writing to Files}.

Each function in the list is called with two arguments: the start and
end of the region to be written.  These functions should not alter the
contents of the buffer.  Instead, they should return lists indicating
annotations to write in the file in addition to the text in the
buffer.

Each function should return a list of elements of the form
@code{(@var{position} . @var{string})}, where @var{position} is an
integer specifying the relative position in the text to be written, and
@var{string} is the annotation to add there.

Each list returned by one of these functions must be already sorted in
increasing order by @var{position}.  If there is more than one function,
@code{write-region} merges the lists destructively into one sorted list.

When @code{write-region} actually writes the text from the buffer to the
file, it intermixes the specified annotations at the corresponding
positions.  All this takes place without modifying the buffer.
@end defvar

@defvar after-insert-file-functions
This variable holds a list of functions for @code{insert-file-contents}
to call after inserting a file's contents.  These functions should scan
the inserted text for annotations, and convert them to the text
properties they stand for.

Each function receives one argument, the length of the inserted text;
point indicates the start of that text.  The function should scan that
text for annotations, delete them, and create the text properties that
the annotations specify.  The function should return the updated length
of the inserted text, as it stands after those changes.  The value
returned by one function becomes the argument to the next function.

These functions should always return with point at the beginning of
the inserted text.

The intended use of @code{after-insert-file-functions} is for converting
some sort of textual annotations into actual text properties.  But other
uses may be possible.
@end defvar

We invite users to write Lisp programs to store and retrieve text
properties in files, using these hooks, and thus to experiment with
various data formats and find good ones.  Eventually we hope users
will produce good, general extensions we can install in Emacs.

We suggest not trying to handle arbitrary Lisp objects as property
names or property values---because a program that general is probably
difficult to write, and slow.  Instead, choose a set of possible data
types that are reasonably flexible, and not too hard to encode.

@xref{Format Conversion}, for a related feature.

@node Fields
@subsection Fields
@cindex text fields
@cindex fields

Emacs supplies a notion of a @emph{text field}, which is a region of
text where every character has the same value of the @code{field}
property.  It is used to identify regions of a buffer used for
communicating with an external process, for example.  XEmacs supplies a
compatible interface.  In XEmacs, the @code{field} property can be set
as either an extent property or a text property, mirroring the Emacs
capability of using either overlays or text properties.

The field manipulating functions take a buffer position as the
field-identifying argument, defaulting to point.  This really means the
field containing that buffer position.  Consecutive buffer positions
with no @code{field} property are considered an ``empty'' field.  There
is some ambiguity when a specified buffer position falls at the very
beginning or the very end of a field: does it belong to the preceding or
the following field?  The answer depends on the openness or closedness
of the corresponding extents (@pxref{Extent Endpoints}).  A buffer
position corresponds to the field whose property would be inherited by a
character inserted at that position.  If the buffer position is between
an end-open and a start-open extent, then it corresponds to an empty
field at that position, since an inserted character will belong to
neither extent.

@defvar inhibit-field-text-motion
This variable controls whether the text motion commands notice fields or
not.  When it is nil (the default), commands such as beginning-of-line
will try to move only within fields.
@end defvar

@defun make-field value from to &optional buffer
There is no Emacs counterpart to this function.  The default open and
closedness of extents in XEmacs is opposite to the default for Emacs
overlays.  Hence, fields based on extents in XEmacs behave differently
from the equivalent fields based on overlays in Emacs.  This function
creates a field with value @var{value} over the region @var{from} to
@var{to} in @var{buffer}, which defaults to the current buffer, with the
default Emacs open and closedness.
@end defun

@defun find-field &optional pos merge-at-boundary beg-limit end-limit
There is no (Lisp-visible) Emacs counterpart to this function.  It is
the workhorse for the other functions.  It returns a dotted pair
@code{(start . stop)} holding the endpoints of the field matching a
specification.  If @var{pos} is non-@code{nil}, it specifies a buffer
position whose enclosing field should be found; otherwise, the value of
point is used.

If @var{merge-at-boundary} is non-@code{nil}, then two changes are made
to the search algorithm.  First, if @var{pos} is at the very first
position of a field, then the beginning of the previous field is
returned instead of the beginning of @var{pos}'s field.  Second, if the
value of the @code{field} property at @var{pos} is the symbol
@code{boundary}, then the beginning of the field before the boundary
field and the end of the field after the boundary field are returned.

If @var{beg-limit} is a buffer position, and the start position that
would be returned is less than @var{beg-limit}, then @var{beg-limit} is
returned instead.  Likewise, if @var{end-limit} is a buffer position,
and the stop position that would be returned is greater than
@var{end-limit}, then @var{end-limit} is returned instead.
@end defun

@defun delete-field &optional pos
Delete the text of the field at @var{pos}.
@end defun

@defun field-string &optional pos
Return the contents of the field at @var{pos} as a string.
@end defun

@defun field-string-no-properties &optional pos
Return the contents of the field at @var{pos} as a string, without text
properties.
@end defun

@defun field-beginning &optional pos escape-from-edge limit
Return the beginning of the field at @var{pos}.  If
@var{escape-from-edge} is non-nil and @var{pos} is at the beginning of a
field, then the beginning of the field that ends at @var{pos} is
returned instead.  If @var{limit} is a buffer position and the returned
value would be less than @var{limit}, then @var{limit} is returned
instead.
@end defun

@defun field-end &optional pos escape-from-edge limit
Return the end of the field at @var{pos}.  If @var{escape-from-edge} is
non-nil and @var{pos} is at the end of a field, then the end of the
field that begins at @var{pos} is returned instead.  If @var{limit} is a
buffer position and the returned value would be greater than
@var{limit}, then @var{limit} is returned instead.
@end defun

@defun constrain-to-field new-pos old-pos &optional escape-from-edge only-in-line inhibit-capture-property
Return the position closest to @var{new-pos} that is in the same field
as @var{old-pos}.  If @var{new-pos} is @code{nil}, then the value of
point is used instead @emph{and} point is set to the value that is
returned.

If @var{escape-from-edge} is non-@code{nil} and @var{old-pos} is at the
boundary of two fields, then the two adjacent fields are considered one
field.  Furthermore, if @var{new-pos} is in a field whose @code{field}
property is the symbol @code{boundary}, then the preceding field, the
boundary field, and the following field are considered one field.

If @var{only-in-line} is non-@code{nil} and the returned position would
be on a different line than @var{new-pos}, return @var{new-pos} instead.

If @var{inhibit-capture-property} is non-@code{nil} and the character at
@var{old-pos} has a property of the same name as the value of
@var{inhibit-capture-property}, then all field boundaries are ignored;
i.e., @var{new-pos} is returned.

If @var{inhibit-field-text-motion} is non-@code{nil}, then all field
boundaries are ignored and this function always returns @var{new-pos}.
@end defun

@node Substitution
@section Substituting for a Character Code

  The following functions replace characters within a specified region
based on their character codes.

@defun subst-char-in-region start end old-char new-char &optional noundo
@cindex replace characters
This function replaces all occurrences of the character @var{old-char}
with the character @var{new-char} in the region of the current buffer
defined by @var{start} and @var{end}.

@cindex Outline mode
@cindex undo avoidance
If @var{noundo} is non-@code{nil}, then @code{subst-char-in-region} does
not record the change for undo and does not mark the buffer as modified.
This feature is used for controlling selective display (@pxref{Selective
Display}).

@code{subst-char-in-region} does not move point and returns
@code{nil}.

@example
@group
---------- Buffer: foo ----------
This is the contents of the buffer before.
---------- Buffer: foo ----------
@end group

@group
(subst-char-in-region 1 20 ?i ?X)
     @result{} nil

---------- Buffer: foo ----------
ThXs Xs the contents of the buffer before.
---------- Buffer: foo ----------
@end group
@end example
@end defun

@defun translate-region start end table
This function applies a translation table to the characters in the
buffer between positions @var{start} and @var{end}.  The translation
table @var{table} can be either a string, a vector, or a char-table.

If @var{table} is a string, its @var{n}th element is the mapping for the
character with code @var{n}.

If @var{table} is a vector, its @var{n}th element is the mapping for
character with code @var{n}.  Legal mappings are characters, strings, or
@code{nil} (meaning don't replace.)

If @var{table} is a char-table, its elements describe the mapping
between characters and their replacements.  The char-table should be of
type @code{char} or @code{generic}.

When the @var{table} is a string or vector and its length is less than
the total number of characters (256 without Mule), any characters with
codes larger than the length of @var{table} are not altered by the
translation.

The return value of @code{translate-region} is the number of
characters that were actually changed by the translation.  This does
not count characters that were mapped into themselves in the
translation table.

@strong{NOTE}: Prior to XEmacs 21.2, the @var{table} argument was
allowed only to be a string.  This is still the case in FSF Emacs.

The following example creates a char-table that is passed to
@code{translate-region}, which translates character @samp{a} to
@samp{the letter a}, removes character @samp{b}, and translates
character @samp{c} to newline.

@example
@group
---------- Buffer: foo ----------
Here is a sentence in the buffer.
---------- Buffer: foo ----------
@end group

@group
(let ((table (make-char-table 'generic)))
  (put-char-table ?a "the letter a" table)
  (put-char-table ?b "" table)
  (put-char-table ?c ?\n table)
  (translate-region (point-min) (point-max) table))
     @result{} 3

---------- Buffer: foo ----------
Here is the letter a senten
e in the uffer.
---------- Buffer: foo ----------
@end group
@end example
@end defun

@node Registers
@section Registers
@cindex registers

  A register is a sort of variable used in XEmacs editing that can hold a
marker, a string, a rectangle, a window configuration (of one frame), or
a frame configuration (of all frames).  Each register is named by a
single character.  All characters, including control and meta characters
(but with the exception of @kbd{C-g}), can be used to name registers.
Thus, there are 255 possible registers.  A register is designated in
Emacs Lisp by a character that is its name.

  The functions in this section return unpredictable values unless
otherwise stated.
@c Will change in version 19

@defvar register-alist
This variable is an alist of elements of the form @code{(@var{name} .
@var{contents})}.  Normally, there is one element for each XEmacs
register that has been used.

The object @var{name} is a character (an integer) identifying the
register.  The object @var{contents} is a string, marker, or list
representing the register contents.  A string represents text stored in
the register.  A marker represents a position.  A list represents a
rectangle; its elements are strings, one per line of the rectangle.
@end defvar

@defun get-register register
This function returns the contents of the register
@var{register}, or @code{nil} if it has no contents.
@end defun

@defun set-register register value
This function sets the contents of register @var{register} to @var{value}.
A register can be set to any value, but the other register functions
expect only certain data types.  The return value is @var{value}.
@end defun

@deffn Command view-register register
This command displays what is contained in register @var{register}.
@end deffn

@ignore
@deffn Command point-to-register register
This command stores both the current location of point and the current
buffer in register @var{register} as a marker.
@end deffn

@deffn Command jump-to-register register
@deffnx Command register-to-point register
@comment !!SourceFile register.el
This command restores the status recorded in register @var{register}.

If @var{register} contains a marker, it moves point to the position
stored in the marker.  Since both the buffer and the location within the
buffer are stored by the @code{point-to-register} function, this command
can switch you to another buffer.

If @var{register} contains a window configuration or a frame configuration.
@code{jump-to-register} restores that configuration.
@end deffn
@end ignore

@deffn Command insert-register register &optional beforep
This command inserts contents of register @var{register} into the current
buffer.

Normally, this command puts point before the inserted text, and the
mark after it.  However, if the optional second argument @var{beforep}
is non-@code{nil}, it puts the mark before and point after.
You can pass a non-@code{nil} second argument @var{beforep} to this
function interactively by supplying any prefix argument.

If the register contains a rectangle, then the rectangle is inserted
with its upper left corner at point.  This means that text is inserted
in the current line and underneath it on successive lines.

If the register contains something other than saved text (a string) or
a rectangle (a list), currently useless things happen.  This may be
changed in the future.
@end deffn

@ignore
@deffn Command copy-to-register register start end &optional delete-flag
This command copies the region from @var{start} to @var{end} into
register @var{register}.  If @var{delete-flag} is non-@code{nil}, it deletes
the region from the buffer after copying it into the register.
@end deffn

@deffn Command prepend-to-register register start end &optional delete-flag
This command prepends the region from @var{start} to @var{end} into
register @var{register}.  If @var{delete-flag} is non-@code{nil}, it deletes
the region from the buffer after copying it to the register.
@end deffn

@deffn Command append-to-register register start end &optional delete-flag
This command appends the region from @var{start} to @var{end} to the
text already in register @var{register}.  If @var{delete-flag} is
non-@code{nil}, it deletes the region from the buffer after copying it
to the register.
@end deffn

@deffn Command copy-rectangle-to-register register start end &optional delete-flag
This command copies a rectangular region from @var{start} to @var{end}
into register @var{register}.  If @var{delete-flag} is non-@code{nil}, it
deletes the region from the buffer after copying it to the register.
@end deffn

@deffn Command window-configuration-to-register register
This function stores the window configuration of the selected frame in
register @var{register}.
@end deffn

@deffn Command frame-configuration-to-register register
This function stores the current frame configuration in register
@var{register}.
@end deffn
@end ignore

@node Transposition
@section Transposition of Text

  This subroutine is used by the transposition commands.

@defun transpose-regions start1 end1 start2 end2 &optional leave-markers
This function exchanges two nonoverlapping portions of the buffer.
Arguments @var{start1} and @var{end1} specify the bounds of one portion
and arguments @var{start2} and @var{end2} specify the bounds of the
other portion.

Normally, @code{transpose-regions} relocates markers with the transposed
text; a marker previously positioned within one of the two transposed
portions moves along with that portion, thus remaining between the same
two characters in their new position.  However, if @var{leave-markers}
is non-@code{nil}, @code{transpose-regions} does not do this---it leaves
all markers unrelocated.
@end defun

@node Change Hooks
@section Change Hooks
@cindex change hooks
@cindex hooks for text changes

  These hook variables let you arrange to take notice of all changes in
all buffers (or in a particular buffer, if you make them buffer-local).
@ignore  Not in XEmacs
See also @ref{Special Properties}, for how to detect changes to specific
parts of the text.
@end ignore

  The functions you use in these hooks should save and restore the match
data if they do anything that uses regular expressions; otherwise, they
will interfere in bizarre ways with the editing operations that call
them.

  Buffer changes made while executing the following hooks don't
themselves cause any change hooks to be invoked.

@defvar before-change-functions
This variable holds a list of a functions to call before any buffer
modification.  Each function gets two arguments, the beginning and end
of the region that is about to change, represented as integers.  The
buffer that is about to change is always the current buffer.
@end defvar

@defvar after-change-functions
This variable holds a list of a functions to call after any buffer
modification.  Each function receives three arguments: the beginning and
end of the region just changed, and the length of the text that existed
before the change.  (To get the current length, subtract the region
beginning from the region end.)  All three arguments are integers.  The
buffer that's about to change is always the current buffer.
@end defvar

@defvar before-change-function
This obsolete variable holds one function to call before any buffer
modification (or @code{nil} for no function).  It is called just like
the functions in @code{before-change-functions}.
@end defvar

@defvar after-change-function
This obsolete variable holds one function to call after any buffer modification
(or @code{nil} for no function).  It is called just like the functions in
@code{after-change-functions}.
@end defvar

@defvar first-change-hook
This variable is a normal hook that is run whenever a buffer is changed
that was previously in the unmodified state.
@end defvar

@node Transformations
@section Textual transformations---MD5 and base64 support
@cindex MD5 digests
@cindex base64

Some textual operations inherently require examining each character in
turn, and performing arithmetic operations on them.  Such operations
can, of course, be implemented in Emacs Lisp, but tend to be very slow
for large portions of text or data.  This is why some of them are
implemented in C, with an appropriate interface for Lisp programmers.
Examples of algorithms thus provided are MD5 and base64 support.

MD5 is an algorithm for calculating message digests, as described in
rfc1321.  Given a message of arbitrary length, MD5 produces a 128-bit
``fingerprint'' (``message digest'') corresponding to that message.  It
is considered computationally infeasible to produce two messages having
the same MD5 digest, or to produce a message having a prespecified
target digest.  MD5 is used heavily by various authentication schemes.

Emacs Lisp interface to MD5 consists of a single function @code{md5}:

@defun md5 object &optional start end coding noerror
This function returns the MD5 message digest of @var{object}, a buffer
or string.

Optional arguments @var{start} and @var{end} denote positions for
computing the digest of a portion of @var{object}.

The optional @var{coding} argument specifies the coding system the text
is to be represented in while computing the digest.  If unspecified, it
defaults to the current format of the data, or is guessed.

If @var{noerror} is non-@code{nil}, silently assume binary coding if the
guesswork fails.  Normally, an error is signaled in such case.

@var{coding} and @var{noerror} arguments are meaningful only in XEmacsen
with file-coding or Mule support.  Otherwise, they are ignored.  Some
examples of usage:

@example
@group
;; @r{Calculate the digest of the entire buffer}
(md5 (current-buffer))
     @result{} "8842b04362899b1cda8d2d126dc11712"
@end group

@group
;; @r{Calculate the digest of the current line}
(md5 (current-buffer) (point-at-bol) (point-at-eol))
     @result{} "60614d21e9dee27dfdb01fa4e30d6d00"
@end group

@group
;; @r{Calculate the digest of your name and email address}
(md5 (concat (format "%s <%s>" (user-full-name) user-mail-address)))
     @result{} "0a2188c40fd38922d941fe6032fce516"
@end group
@end example
@end defun

Base64 is a portable encoding for arbitrary sequences of octets, in a
form that need not be readable by humans.  It uses a 65-character subset
of US-ASCII, as described in rfc2045.  Base64 is used by MIME to encode
binary bodies, and to encode binary characters in message headers.

The Lisp interface to base64 consists of four functions:

@deffn Command base64-encode-region start end &optional no-line-break
This function encodes the region between @var{start} and @var{end} of the
current buffer to base64 format.  This means that the original region is
deleted, and replaced with its base64 equivalent.

Normally, encoded base64 output is multi-line, with 76-character lines.
If @var{no-line-break} is non-@code{nil}, newlines will not be inserted,
resulting in single-line output.

Mule note: you should make sure that you convert the multibyte
characters (those that do not fit into 0--255 range) to something else,
because they cannot be meaningfully converted to base64.  If the
@code{base64-encode-region} encounters such characters, it will signal
an error.

@code{base64-encode-region} returns the length of the encoded text.

@example
@group
;; @r{Encode the whole buffer in base64}
(base64-encode-region (point-min) (point-max))
@end group
@end example

The function can also be used interactively, in which case it works on
the currently active region.
@end deffn

@defun base64-encode-string string &optional no-line-break
This function encodes @var{string} to base64, and returns the encoded
string.

Normally, encoded base64 output is multi-line, with 76-character lines.
If @var{no-line-break} is non-@code{nil}, newlines will not be inserted,
resulting in single-line output.

For Mule, the same considerations apply as for
@code{base64-encode-region}.

@example
@group
(base64-encode-string "fubar")
    @result{} "ZnViYXI="
@end group
@end example
@end defun

@deffn Command base64-decode-region start end
This function decodes the region between @var{start} and @var{end} of the
current buffer.  The region should be in base64 encoding.

If the region was decoded correctly, @code{base64-decode-region} returns
the length of the decoded region.  If the decoding failed, @code{nil} is
returned.

@example
@group
;; @r{Decode a base64 buffer, and replace it with the decoded version}
(base64-decode-region (point-min) (point-max))
@end group
@end example
@end deffn

@defun base64-decode-string string
This function decodes @var{string} to base64, and returns the decoded
string.  @var{string} should be valid base64-encoded text.

If encoding was not possible, @code{nil} is returned.

@example
@group
(base64-decode-string "ZnViYXI=")
    @result{} "fubar"
@end group

@group
(base64-decode-string "totally bogus")
    @result{} nil
@end group
@end example
@end defun
