@c -*-texinfo-*-
@c This is part of the SXEmacs Lisp Reference Manual.
@c Copyright (C) 2005 Sebastian Freundt
@c See the file lispref.texi for copying conditions.
@setfilename ../../info/openssl.info

@node OpenSSL Support, Enhanced Number Types, PostgreSQL Support, top
@comment  node-name,  next,  previous,  up
@chapter OpenSSL Support
@cindex OpenSSL

SXEmacs can be linked with OpenSSL libcrypto and libssl to provide
a comprehensive gateway to cryptographic and related functions.

@comment HINT FOR EXPERIMENTAL STATUS
Note: Currently the API provided for SXEmacs is experimental.
Conceptional changes, renaming, and changes in the behaviour of
functions are highly likely.
@comment REMOVE ME WHEN I AM STABLE


@menu
* Building SXEmacs with OpenSSL support::
* SXEmacs OpenSSL API::
* SXEmacs openssl Examples::
@end menu


@node Building SXEmacs with OpenSSL support
@section Building SXEmacs with OpenSSL support

SXEmacs OpenSSL support requires linking to the OpenSSL libcrypto and libssl
libraries.  Describing how to build and install OpenSSL is beyond the
scope of this document.  See the OpenSSL manual for details.
@comment erm, why? we could give a rilly-quick howto

@c If you have installed SXEmacs from one of the binary kits on
@c (@url{ftp://ftp.sxemacs.org/}), or are using an SXEmacs binary from a CD
@c ROM, you may have SXEmacs OpenSSL support by default.  @code{M-x
@c describe-installation} will tell you if you do.
@comment BUT we gotta get to this issue

If you are building SXEmacs from source, you need to install OpenSSL
first.  On some systems, OpenSSL will come pre-installed in /usr.  In
this case, all you need to do is passing @samp{--enable-openssl} to
configure.  Otherwise you must specify the location via
@samp{--site-prefixes} when you run configure.


@node SXEmacs OpenSSL API
@section SXEmacs OpenSSL API

Explaining cryptographical details behind OpenSSL API functions is
beyond the scope of this document.  Ask Professor Google.
@comment erm, again: Why? maybe some alice-bob examples?

The SXEmacs OpenSSL API is intended to be an exact copy of the OpenSSL
API functions in libcrypto and libssl.  The intent is to provide elisp
for everything you have told your OpenSSL library to contain.  Then,
at stage 2, let higher level Lisp code come up with policies and
remove the guts of libcrypto and libssl.

Despite this rather noble intention of giving access to anything in
OpenSSL there are conceptional limits.  Auxiliary stuff from OpenSSL
such as BIO or BN will not be accessible to elisp, though the C
implementation might use them directly or indirectly as well.

On the one hand this is due to their very special purpose (like finding
prime numbers), on the other hand due to their obsoleteness (like
BIO_gets, BIO_do_connect, etc.) when SXEmacs already provides a similar
or more powerful implementation.

For convenience, we denote the elisp implementation of OpenSSL with openssl
whereas the distributed library package from @url{http://www.openssl.org}
is denoted OpenSSL.


@menu
* openssl General::		General Information
* openssl RAND::		(Pseudo) Random Numbers
* openssl MD::			Message Digests (aka hashes)
* openssl HMAC::		Message Authentication Codes (aka keyed hashes)
* openssl CIPHER::		Symmetric Cryptography
* openssl PKEY::		Public Key Crypto Systems (aka asymmetric ciphers)
* openssl SSL/TLS::		Secure Network Layers
* openssl Lisp Symbols and Datatypes::
* Unimplemented openssl Functions::
@end menu


@node openssl General
@subsection General information 

  To retrieve the version of the underlying OpenSSL installation
you can use

@defun ossl-version
This function returns a version string.
This string should be identical to the output of @code{openssl version}
in a shell.
@end defun

@example
@group
(ossl-version)
  @result{} "OpenSSL 0.9.9-dev XX xxx XXXX"
@end group
@end example

  Since it is possible to strip certain cryptographic stuff from the
OpenSSL installation (for example due to license or patent issues)
the openssl API provides the following functions to retrieve a list
of capabilities.

@defun ossl-available-digests
Return a list of digest algorithms in the underlying crypto library.
This yields a plain list of symbols.
@end defun

@defun ossl-available-ciphers
Return a list of cipher algorithms in the underlying crypto library.
This yields a list of conses \(cipher . size\)
@end defun

@example
@group
(ossl-available-digests)
  @result{} '(MD2 MD5 RSA-MD2 RSA-MD5 SHA RSA-SHA SHA1 RSA-SHA1 DSA-SHA
       DSA-SHA1-old MDC2 RSA-MDC2 DSA-SHA1 RSA-SHA1-2 DSA RIPEMD160
       RSA-RIPEMD160 MD4 RSA-MD4 ecdsa-with-SHA1 RSA-SHA256 RSA-SHA384
       RSA-SHA512 RSA-SHA224 SHA256 SHA384 SHA512 SHA224)
@end group

@group
(ossl-available-ciphers)
  @result{} '(RC4 DES-ECB DES-CFB DES-CBC DES-EDE DES-EDE3 IDEA-CBC IDEA-CFB
       IDEA-ECB RC2-CBC RC2-ECB RC2-CFB RC2-OFB DES-EDE-CBC
       DES-EDE3-CBC DES-OFB IDEA-OFB DES-EDE-CFB DES-EDE3-CFB
       DES-EDE-OFB DES-EDE3-OFB DESX-CBC BF-CBC BF-ECB BF-CFB
       BF-OFB RC4-40 RC2-40-CBC CAST5-CBC CAST5-ECB CAST5-CFB
       CAST5-OFB RC5-CBC RC5-ECB RC5-CFB RC5-OFB RC2-64-CBC
       AES-128-ECB AES-128-CBC AES-128-OFB AES-128-CFB AES-192-ECB
       AES-192-CBC AES-192-OFB AES-192-CFB AES-256-ECB AES-256-CBC
       AES-256-OFB AES-256-CFB AES-128-CFB1 AES-192-CFB1 AES-256-CFB1
       AES-128-CFB8 AES-192-CFB8 AES-256-CFB8 DES-CFB1 DES-CFB8)
@end group
@end example

  You should use higher level forms to prevent errors caused by
missing algorithms.

@example
(when (member 'MD4 (ossl-available-digests))
  @dots{})
@end example

  These functions work at run-time (not compile time) so it is possible
when building a dynamically linked SXEmacs to update OpenSSL on the
fly.  As a general hint you can assume to have support for at least the
MD5 and SHA1 message digests, and the BF-* symmetric cipher systems.


  Additionally, there are two convenience functions which, given a
digest or cipher algorithm symbol, allow to retrieve information about
the size of the digest or cipher.

@defun ossl-digest-bits digest
Return the number of effective output bits of @var{digest}.
@end defun

@defun ossl-cipher-bits cipher
Return the number of effective bits of @var{cipher}.
@end defun



@node openssl RAND
@subsection (Pseudo) Random Numbers

  Random numbers are necessary for cryptographically secure
implementations.  The term number here indeed means a string.  OpenSSL
itself provides random number generators which fulfill the the demands
of cryptography.

@defun ossl-rand-bytes count
Return @var{count} bytes of randomness.

Note: You probably want to put a wrapping encoder function
(like @code{base16-encode-string}) around it, since this returns
binary string data.
@end defun

@example
@group
(base16-encode-string (ossl-rand-bytes 8))
  @result{} "5a78acd572984bdf"
@end group
@end example

  Random numbers generated this way, can be used as ``passwords'' or
salt values in various encryption and decryption functions.

  Note: As stated above, whenever security is concerned
the function @code{ossl-rand-bytes} should be used to obtain random
numbers.  The built-in @code{random} function of SXEmacs is
@emph{not} cryptographically secure.


@node openssl MD
@subsection Message Digests (aka hashes)

  Message digests are widely used in modern information
infrastructure.  They are derived from (collision free) one-way hash
functions. 

  A hash function (such as @samp{md5} or @samp{sha1}) is a function
with following properties:

@enumerate
@item reduction: data of arbitrary length is mapped onto data
  of fixed length
@item dispersion: a change of one bit in input data changes
  (ideally) half the bits of the hash value.
@item well definedness: computing a hash value from the same
  source data twice yields the same result
@item efficiency: computing hash values is efficient (ideally
  with complexity O(n)) on the input, but it is hard to 
  compute a preimage for a given hash value.
@end enumerate

Often, the last property is too weak in practice, therefore
most hash functions comply with the even stronger:

@itemize
@item collision-freeness: it is hard to compute two different
  source data which result in the same hash value.
@end itemize

  Message digests fulfill several tasks in daily use.  Most commonly
used are so called checksums.  In modern days hash functions are used
almost exclusively for their error detecting facilities in contrast to
other checksum algorithms like CRC32.

  Beyond that, message digests play an important role in digital
signatures.  Since public key crypto systems map long plaintexts on
long ciphertexts, message digests are used to obscure the length of a
plaintext.

  Therefore in digital signatures not the message itself is signed but
the hash value of that message.  That also assures a certain upper
bound of the length of a digital signature which is (as in real life)
rather short compared to the message that was signed.

  Okay, after this short introduction to message digests, here are the
functions to access them from elisp.

@defun ossl-digest digest string
Return the message digest of @var{string} computed by @var{digest}.
@var{digest} may be one of the OpenSSL digests you have compiled.
See @code{ossl-available-digests}.

Note: You probably want to put a wrapping encoder function (like
@code{base16-encode-string}) around it, since this returns binary
string data.
@end defun

  In order to compute digest sums from files without actually looking
at the file contents explicitly, there is the companion function
@code{ossl-digest-file} which works similarly.

@defun ossl-digest digest file
Return the message digest of the contents of @var{file} computed by
@var{digest}.
@var{digest} may be one of the OpenSSL digests you have compiled.
See @code{ossl-available-digests}.

Note: You probably want to put a wrapping encoder function (like
@code{base16-encode-string}) around it, since this returns binary
string data.
@end defun

  The current implementation of the OpenSSL API in SXEmacs uses the
EVP layer of OpenSSL to access the digests.

@example
@group
(base16-encode-string (ossl-digest 'md5 "hash me"))
  @result{} "17b31dce96b9d6c6d0a6ba95f47796fb"
@end group

@group
(base16-encode-string (ossl-digest 'SHA1 "hash me"))
  @result{} "43f932e4f7c6ecd136a695b7008694bb69d517bd""
@end group
@end example

Let's do some performance tests.

@example
@group
;; @r{this is the SXEmacs built-in implementation of MD5}
(let ((st (current-btime)))
  (dotimes (i 100000)
    (md5 "Some test string to hash"))
  (- (current-btime) st))
  @result{} 6194289
  ;; @r{time in microseconds, so this is about 6 seconds}
@end group

@group
;; @r{now compare to the OpenSSL implementation}
(let ((st (current-btime)))
  (dotimes (i 100000)
    (ossl-digest 'md5 "Some test string to hash"))
  (- (current-btime) st))
  @result{} 10589408
  ;; @r{which is about 10 seconds}
@end group
@end example

  As we can see, the built-in implementation has slightly better
performance when hashing short strings.  The following example shows
performance on long strings, like the buffer string here.

@example
@group
(length (buffer-string))
  @result{} 16861
@end group

@group
;; @r{we begin with the built-in implementation}
(let ((st (current-btime))
      (b (buffer-string)))
  (dotimes (i 100000)
    (md5 b))
  (- (current-btime) st))
  @result{} 74350982
  ;; @r{which is about 74 seconds}
@end group

@group
;; @r{compare to the OpenSSL API}
(let ((st (current-btime))
      (b (buffer-string)))
  (dotimes (i 100000)
    (base16-encode-string 
      (ossl-digest 'md5 b)))
  (- (current-btime) st))
  @result{} 31697926
  ;; @r{which is about 31 seconds}
@end group
@end example

  This latter example shows digest hashing ``under real conditions''
since in practice messages to be hashed are typically in the range of
1000 to 30000 characters.  This range is even vastly exceeded when
dealing with checksums for files.

  Since the built-in md5 implementation cannot handle file streams, we
have to turn them into strings.  A possible way to achieve this has
been suggested by Steve Youngs.  I shall illustrate it with a tarball
file.

@example
@group
freundt@@muck:~> ls -sh ~/temp/pdftex-1.30.3.tar.bz2 
3.2M /home/freundt/temp/pdftex-1.30.3.tar.bz2
@end group

@group
(let ((st (current-btime))
      (b (with-temp-buffer
           (insert-file-contents-literally
            "~/temp/pdftex-1.30.3.tar.bz2")
           (buffer-string))))
  (dotimes (i 100)
    (md5 b))
  (- (current-btime) st))
  @result{} 22729718
  ;; @r{which is about 22 seconds}
@end group
@end example

Compared to the file stream function @code{ossl-digest-file}:

@example
@group
(let ((st (current-btime)))
  (dotimes (i 100)
    (ossl-digest-file 'md5 "~/temp/pdftex-1.30.3.tar.bz2"))
  (- (current-btime) st))
  @result{} 4189695
  ;; @r{which is about 4 seconds}
@end group
@end example

  Another performance test which compares the elisp implementation of
sha1 (taken from `No Gnus v0.4') to the one from the OpenSSL API

@example
@group
(let ((st (current-btime)))
  (dotimes (i 500)
    (sha1-binary "a short test string"))
  (- (current-btime) st))
  @result{} 2574326
  ;; @r{which is about 2.5 seconds}
@end group

@group
  ;; @r{the same with the OpenSSL API}
(let ((st (current-btime)))
  (dotimes (i 500)
    (ossl-digest 'sha1 "a short test string"))
  (- (current-btime) st))
  @result{} 31378
  ;; @r{which is about 0.03 seconds}
@end group
@end example

  These results suggest to always use the openssl interface in favour of
other implementations.


@node openssl HMAC
@subsection Message Authentication Codes (aka keyed hashes)

  Ordinary message digests only offer data integrity verification,
while HMACs may be used to simultaneously verify both the data
integrity and the authenticity of a message.  This is accomplished by
using a secret key.  Now whenever two parties have agreed upon a
common secret key, one of them can verify that a message hash was
indeed computed by the other one.

@defun ossl-hmac digest message password
Return the message authentication code of @var{message}
using the hash function @var{digest} and the key @var{password}.

Note: You probably want to put a wrapping encoder function
(like @code{base16-encode-string}) around it, since this returns
binary string data.
@end defun

  Unlike in public-key cryptography, this technique requires a new
secret key for any two parties which want to communicate.  On the
other hand, this technique works symmetrically, that is the same
function can be used for both generating and verifying a keyed message
digest.


@node openssl CIPHER
@subsection Symmetric Cryptography

  Symmetric-key algorithms can be divided into stream ciphers and
block ciphers.  Stream ciphers encrypt the bits of the message one at
a time, and block ciphers take a number of bits and encrypt them as a
single unit.  SXEmacs only supports block ciphers.

  Symmetric-key algorithms are much (that is about 1000 times) faster
than asymmetric algorithms.  The disadvantage of symmetric-key
cryptography is that any two parties which want to communicate need to
to agree upon a common secret key.

  In order to use symmetric-key cryptography some preparations have to
be done, mostly due to the block-oriented operation of the algorithms.
The following function, given a cipher and digest algorithm, computes
a valid key suitable for the given cipher algorithm.

@defun ossl-bytes-to-key cipher digest salt password count
Derive a key and initialisation vector (iv) suitable for a cipher.
Return a string @var{key} being the key. The initialisation vector is
put into @var{key}'s property list as @code{'iv}.

@var{cipher} (a symbol) is the cipher to derive the key and IV for.
Valid ciphers can be obtained by @code{ossl-available-ciphers}.

@var{digest} (a symbol) is the message digest to use.
Valid digests can be obtained by @code{ossl-available-digests}.

@var{salt} (string or @code{nil}) is used as a salt in the derivation.
Use @code{nil} here to indicate that no salt is used.

@var{password} is an arbitrary string which is processed to derive a
unique key and IV.

@var{count} (a positive integer) is the iteration count to use. This
indicates how often the hash algorithm is called recursively.

Note: You probably want to put a wrapping encoder function 
(like @code{base16-encode-string}) around it, since this returns
binary string data.
@end defun

Note: It is disregarded to use the key/iv pair of, say, AES-128 cipher
for e.g. a blowfish (BF) cipher, although it seems possible and is not
explicitly forbidden.  Such malpractices may result in severe
crashes.


@defun ossl-encrypt cipher string key &optional iv
Return the cipher of @var{string} computed by @var{cipher} under
@var{key}.

@var{cipher} (a symbol) may be one of the OpenSSL cipher algorithms
you have compiled. See @code{ossl-available-ciphers}.

@var{string} is the text to be encrypted.

@var{key} should be a key generated suitably for this cipher, for
example by @code{ossl-bytes-to-key}.

Optional fourth argument @var{iv} should be an initialisation vector
suitable for this cipher. Normally the initialisation vector from
@var{key}'s property list is used. However, if @var{iv} is
non-@code{nil}, use this IV instead.

Note: You probably want to put a wrapping encoder function
(like @code{base16-encode-string}) around it, since this returns
binary string data.
@end defun

@defun ossl-decrypt cipher string key &optional iv
Return the deciphered version of @var{string} computed by @var{cipher}
under @var{key}.

@var{cipher} (a symbol) may be one of the OpenSSL cipher algorithms
you have compiled. See @code{ossl-available-ciphers}.

@var{string} is the text to be decrypted.

@var{key} should be a key generated suitably for this cipher, for
example by @code{ossl-bytes-to-key}.

Optional fourth argument @var{iv} should be an initialisation vector
suitable for this cipher. Normally the initialisation vector from
@var{key}'s property list is used. However, if @var{iv} is
non-@code{nil}, use this IV instead.
@end defun

  As for message digests, there are two companion functions which
directly work on files.

@defun ossl-encrypt-file cipher file key &optional iv outfile
Return the encrypted contents of @var{file} computed by @var{cipher}
under @var{key}.

@var{cipher} (a symbol) may be one of the OpenSSL cipher algorithms
you have compiled. See @code{ossl-available-ciphers}.

@var{file} is the file to be encrypted.

@var{key} should be a key generated suitably for this
cipher, for example by @code{ossl-bytes-to-key}.

Optional fourth argument @var{iv} should be an initialisation vector
suitable for this cipher. Normally the initialisation vector from
@var{key}'s property list is used. However, if @var{iv} is
non-@code{nil}, use this IV instead.

Optional fifth argument @var{outfile} may specify a file to have the
encrypted data redirected.

Note: You probably want to put a wrapping encoder function
(like @code{base16-encode-string}) around it, since this returns
binary string data.
@end defun


@defun ossl-decrypt-file cipher file key &optional iv outfile
Return the deciphered version of @var{file} computed by @var{cipher}
under @var{key}.

@var{cipher} (a symbol) may be one of the OpenSSL cipher algorithms
you have compiled. See @code{ossl-available-ciphers}.

@var{file} is the file to be decrypted.

@var{key} should be a key generated suitably for this
cipher, for example by @code{ossl-bytes-to-key}.

Optional fourth argument @var{iv} should be an initialisation vector
suitable for this cipher. Normally the initialisation vector from
@var{key}'s property list is used. However, if @var{iv} is
non-@code{nil}, use this IV instead.

Optional fifth argument @var{outfile} may specify a file to have the
decrypted data redirected.
@end defun



@node openssl PKEY
@subsection public key crypto systems

Not yet documented.

@c  * + General
@c  *  ossl-pkey-p - discriminator of public keys
@c  *  ossl-pkey-size - selector of public key sizes
@c  *  ossl-pkey-get-public - strip the private data
@c  *  Lisp_EVP_PKEY - lrecord object to store public keys
@c  * + RSA
@c  *  ossl-rsa-generate-key - constructor of RSA public keys
@c  *  ossl-rsa-pkey-p - discriminator of RSA public keys
@c  *  ossl-rsa-subkey-p - comparator of two keys
@c  * + DSA
@c  *  ossl-dsa-generate-key - constructor of DSA public keys
@c  *  ossl-dsa-pkey-p - discriminator of DSA public keys
@c  *  ossl-dsa-subkey-p - comparator of two keys
@c  * + EC
@c  *  ossl-ec-generate-key - constructor of EC public keys
@c  *  ossl-ec-pkey-p - discriminator of EC public keys
@c  * + DH
@c  *  ossl-dh-pkey-p - discriminator of DH public keys
@c  *
@c  * - HYBRID
@c  *  ossl-seal - gateway to public key hybrid (envelope) encryption
@c  *  ossl-open - gateway to public key hybrid (envelope) decryption
@c  *
@c  * - SIGN
@c  *  ossl-sign - gateway to public key signature
@c  *  ossl-verify - gateway to public key signature verification
@c  *
@c  * - PEM
@c  *  ossl-pem-read-public-key
@c  *  ossl-pem-read-key
@c  *  ossl-pem-write-public-key
@c  *  ossl-pem-write-key
@c  *


@node openssl SSL/TLS
@subsection Secure Network Layers

The SSL/TLS support in this API is definitely not a copy of the
underlying libssl functions.  Instead we chose a higher level of access
methods because for example @code{SSL_connect} does not work
standalone, and having an elisp loop to check socket messages is
probably not desirable.

Also we chose to actually do what SSL/TLS stands for, namely to
establish a transparent security layer on top of an existing network
connection.  That is, you can use the usual @code{open-network-stream}+
@code{set-process-filter} + @code{process-send-string} chain and at some
point after the establishment of the connection you can coat that
connection with a secure layer.  Of course, this is done transparently
and your existing process filter or send-string commands will not notice
the change.

@defun ossl-connect process &optional timeout
Return an SSL connection object on top of PROCESS.
Establishing a connection performs a handshake with the
other peer.

If optional argument TIMEOUT is non-nil, it should be a
positive integer to indicate (in seconds) how long to wait
for a successful handshake.
Default: 2 seconds.
@end defun

Currently there are no high level `@code{open-ssl-stream}' (and such)
functions.  You have to invoke @code{open-network-stream} first and
after establishing that connection @code{ossl-connect} should be
performed.

Also, be sure to store the returned SSL-CONN object for later
reference.  Currently there is no way to extract that information from
the underlying network process.

@defun ossl-finish ssl-conn
Finish an SSL connection SSL-CONN.

Note: This may also finish the network connection.
@end defun

As noted above, not all peers finish the connection after finishing
the SS-Layer but it is highly suggested to do so.  Unpredictible
results may occur when you keep using that connection.

@example
@group
;; @r{open a https connection to addons.mozilla.org}
(setq p (open-network-stream "moz" "moz" "addons.mozilla.org" 443))
  @result{} #<network connection "moz" (443 . "addons.mozilla.org") state:run>

(setq m (ossl-connect p))
  @result{} #<OpenSSL socket layer: TLSv1 on top of moz>

;; @r{Let's examine @samp{p}}
p
  @result{} #<secure network connection "moz" (443 . "addons.mozilla.org") state:run>

(ossl-finish m)
  @result{} #<OpenSSL socket layer: dead>

;; @r{Let's examine @samp{p} again}
p
  @result{} #<network connection "moz" (443 . "addons.mozilla.org") state:exit>
@end group
@end example



@c  *  ossl-connect - constructor for SSL connection objects
@c  *  ossl-finish - destructor of SSL connection objects
@c  *  ossl-pending - predicate if data is available for read
@c  *  ossl-read - 
@c  *  ossl-write -
@c  *  ossl-x509-get-subject
@c  *  ossl-x509-get-issuer
@c  *  ossl-x509-get-pubkey
@c  *  ossl-cipher-get-version
@c  *  ossl-cipher-get-name
@c  *  ossl-cipher-get-bits


@node openssl Lisp Symbols and Datatypes
@subsection openssl Lisp Symbols and Datatypes

Not yet documented.


@node Unimplemented openssl Functions
@subsection Unimplemented openssl Functions

Not yet documented.



@node SXEmacs openssl Examples
@section SXEmacs openssl Examples

Not yet documented.

