\input texinfo  @c -*-texinfo-*-
@c %**start of header
@setfilename ../../info/lispref.info
@c @smallbook
@settitle SXEmacs Lisp Reference Manual
@c %**end of header
@macro version
3.4
@end macro

@ifinfo
@dircategory SXEmacs Editor
@direntry
* Lispref: (lispref).		SXEmacs Lisp Reference Manual.
@end direntry

Edition History:

GNU Emacs Lisp Reference Manual Second Edition (v2.01), May 1993
GNU Emacs Lisp Reference Manual Further Revised (v2.02), August 1993
Lucid Emacs Lisp Reference Manual (for 19.10) First Edition, March 1994
XEmacs Lisp Programmer's Manual (for 19.12) Second Edition, April 1995
GNU Emacs Lisp Reference Manual v2.4, June 1995
XEmacs Lisp Programmer's Manual (for 19.13) Third Edition, July 1995
XEmacs Lisp Reference Manual (for 19.14 and 20.0) v3.1, March 1996
XEmacs Lisp Reference Manual (for 19.15 and 20.1, 20.2, 20.3) v3.2, April, May, November 1997
XEmacs Lisp Reference Manual (for 21.0) v3.3, April 1998
SXEmacs Lisp Reference Manual (for 22.1) v3.4, May 2005
@c Please REMEMBER to update edition number in *four* places in this file
@c                 and also in *one* place in intro.texi

Copyright (C) 1990, 1991, 1992, 1993, 1994, 1995 Free Software Foundation, Inc.
Copyright (C) 1994, 1995 Sun Microsystems, Inc.
Copyright (C) 1995, 1996 Ben Wing.

Copyright (C) 2005, 2006 SXEmacs developers


Permission is granted to make and distribute verbatim copies of this
manual provided the copyright notice and this permission notice are
preserved on all copies.

@ignore
Permission is granted to process this file through TeX and print the
results, provided the printed document carries copying permission notice
identical to this one except for the removal of this paragraph (this
paragraph not being relevant to the printed manual).

@end ignore
Permission is granted to copy and distribute modified versions of this
manual under the conditions for verbatim copying, provided that the
entire resulting derived work is distributed under the terms of a
permission notice identical to this one.

Permission is granted to copy and distribute translations of this manual
into another language, under the above conditions for modified versions,
except that this permission notice may be stated in a translation
approved by the Foundation.

Permission is granted to copy and distribute modified versions of this
manual under the conditions for verbatim copying, provided also that the
section entitled ``GNU General Public License'' is included exactly as
in the original, and provided that the entire resulting derived work is
distributed under the terms of a permission notice identical to this
one.

Permission is granted to copy and distribute translations of this manual
into another language, under the above conditions for modified versions,
except that the section entitled ``GNU General Public License'' may be
included in a translation approved by the Free Software Foundation
instead of in the original English.
@end ifinfo

@c Combine indices.
@synindex cp fn
@syncodeindex vr fn
@syncodeindex ky fn
@syncodeindex pg fn
@syncodeindex tp fn

@setchapternewpage odd
@finalout

@titlepage
@title SXEmacs Lisp Reference Manual
@c The edition number appears in several places in this file
@c and also in the file intro.texi.
@c This manual documents SXEmacs 22.1 and was based on the
@c documentation for XEmacs 21.0 (v3.3).
@subtitle Version @version{} (for SXEmacs 22.1), May 2005

@author by Steve Youngs, Sebastian Freundt
@author SXEmacs developers
@author
@author Based on the XEmacs Lisp Reference Manual
@author by Ben Wing
@page
@vskip 0pt plus 1filll
Copyright @copyright{} 1990, 1991, 1992, 1993, 1994, 1995 Free Software Foundation, Inc.
Copyright @copyright{} 1994, 1995 Sun Microsystems, Inc.
Copyright @copyright{} 1995, 1996 Ben Wing.

Copyright @copyright{} 2005, 2006 SXEmacs developers
@sp 2
Version @version{} @*
Revised for SXEmacs Versions 22.1,@*
May 2005.@*

Permission is granted to make and distribute verbatim copies of this
manual provided the copyright notice and this permission notice are
preserved on all copies.

Permission is granted to copy and distribute modified versions of this
manual under the conditions for verbatim copying, provided also that the
section entitled ``GNU General Public License'' is included
exactly as in the original, and provided that the entire resulting
derived work is distributed under the terms of a permission notice
identical to this one.

Permission is granted to copy and distribute translations of this manual
into another language, under the above conditions for modified versions,
except that the section entitled ``GNU General Public License'' may be
included in a translation approved by the Free Software Foundation
instead of in the original English.

Cover art by Etienne Suvasa.
@end titlepage
@page

@node Top, Copying, (dir), (dir)

@ifinfo
This Info file contains the third edition of the SXEmacs Lisp
Reference Manual, corresponding to SXEmacs version 22.1.
@end ifinfo

@menu
* Copying::                 Conditions for copying and changing SXEmacs.
* Introduction::            Introduction and conventions used.

* Packaging::               Lisp library administrative infrastructure.

* Lisp Data Types::         Data types of objects in SXEmacs Lisp.
* Numbers::                 Numbers and arithmetic functions.
* Strings and Characters::  Strings, and functions that work on them.
* Lists::                   Lists, cons cells, and related functions.
* Sequences Arrays Vectors::  Lists, strings and vectors are called sequences.
                                Certain functions act on any kind of sequence.
                                The description of vectors is here as well.
* Symbols::                 Symbols represent names, uniquely.

* Evaluation::              How Lisp expressions are evaluated.
* Control Structures::      Conditionals, loops, nonlocal exits.
* Variables::               Using symbols in programs to stand for values.

* Functions and Commands::  A function is a Lisp program that can be
                            invoked from other functions.

* Macros::                  Macros are a way to extend the Lisp language.
* Customization::           Writing customization declarations.

* Loading::                 Reading files of Lisp code into Lisp.
* Byte Compilation::        Compilation makes programs run faster.
* Debugging::               Tools and tips for debugging Lisp programs.

* Read and Print::          Converting Lisp objects to text and back.
* Minibuffers::             Using the minibuffer to read input.
* Command Loop::            How the editor command loop works,
                              and how you can call its subroutines.
* Keymaps::                 Defining the bindings from keys to commands.
* Menus::                   Defining pull-down and pop-up menus.
* Dialog Boxes::	    Creating dialog boxes.
* Toolbar::		    Controlling the toolbar.
* Gutter::		    Controlling the gutter.
* Scrollbars::		    Controlling the scrollbars.
* Drag and Drop::	    Generic API to inter-application communication
                              via specific protocols.
* Modes::                   Defining major and minor modes.
* Documentation::           Writing and using documentation strings.

* Files::                   Accessing files.
* Backups and Auto-Saving:: Controlling how backups and auto-save
                              files are made.
* Buffers::                 Creating and using buffer objects.
* Windows::                 Manipulating windows and displaying buffers.
* Frames::		    Making multiple X windows.
* Consoles and Devices::    Opening frames on multiple TTY's or X displays.
* Positions::               Buffer positions and motion functions.
* Markers::                 Markers represent positions and update
                              automatically when the text is changed.

* Text::                    Examining and changing text in buffers.
* Searching and Matching::  Searching buffers for strings or regexps.
* Syntax Tables::           The syntax table controls word and list parsing.
* Abbrevs::                 How Abbrev mode works, and its data structures.

* Extents::                 Extents are regions of text with particular
                              display characteristics.
* Specifiers::		    How faces and glyphs are specified.
* Faces and Window-System Objects::
        		    A face is a set of display characteristics
                              specifying how text is to be displayed.
* Glyphs::		    General interface to pixmaps displayed in a
			      buffer or frame.
* Annotations::             Higher-level interface to glyphs in a buffer.
* Display::	            Parameters controlling screen usage.
                              The bell.  Waiting for input.

* Hash Tables::             Fast data structures for mappings.
* Range Tables::            Keeping track of ranges of numbers.
* Databases::               An interface to standard DBM and DB databases.

* Processes::               Running and communicating with subprocesses.
* System Interface::        Getting the user id, system type, environment
                              variables, and other such things.
* X-Windows::		    Functions specific to the X Window System.
* ToolTalk Support::        Interfacing with the ToolTalk message service.
* LDAP Support::            Interfacing with the Lightweight Directory
                              Access Protocol.
* PostgreSQL Support::      Interfacing to the PostgreSQL libpq library.
* OpenSSL Support::         Interfacing to the OpenSSL libcrypto/libssl libs
* Enhanced Number Types::   Using advanced numerical and mathematical
                              features 
* Internationalization::    How Emacs supports different languages and
                              cultural conventions.
* Foreign Functions::	    Accessing functions in external
			      libraries from with SXEmacs lisp.
* MULE::                    Specifics of the Asian-language support.

Appendices

* Tips::                    Advice for writing Lisp programs.
* Building SXEmacs and Object Allocation::
                            Behind-the-scenes information about SXEmacs.
* Standard Errors::         List of all error symbols.
* Standard Buffer-Local Variables::  List of variables local in all buffers.
* Standard Keymaps::        List of standard keymaps.
* Standard Hooks::          List of standard hook variables.

* Index::                   Index including concepts, functions, variables,
                              and other terms.

      --- The Detailed Node Listing ---

Here are other nodes that are inferiors of those already listed,
mentioned here so you can get to them in one step:

Introduction

* Caveats::                 Flaws and a request for help.
* Lisp History::            SXEmacs Lisp is descended from Maclisp.
* Conventions::             How the manual is formatted.
* Acknowledgements::        The authors, editors, and sponsors of this manual.

Conventions

* Some Terms::              Explanation of terms we use in this manual.
* nil and t::               How the symbols @code{nil} and @code{t} are used.
* Evaluation Notation::     The format we use for examples of evaluation.
* Printing Notation::       The format we use for examples that print output.
* Error Messages::          The format we use for examples of errors.
* Buffer Text Notation::    The format we use for buffer contents in examples.
* Format of Descriptions::  Notation for describing functions, variables, etc.

Format of Descriptions

* A Sample Function Description::
* A Sample Variable Description::

Packaging

* Package Overview::       Lisp Libraries and Packages.
* Package Terminology::    Basic stuff.
* Building Packages::      Turn packaged source into a tarball.
* Local.rules File::       Tell the SXEmacs Packaging System about your host.
* Creating Packages::      Tell the SXEmacs Packaging System about your package.
* Issues::

Package Overview

* The User View::
* The Library Maintainer View::
* The Package Release Engineer View::

The Library Maintainer's View

* Infrastructure::    Global Makefiles and common rules.
* Control Files::     Package-specific Makefiles and administrative files.
* Obtaining::         Obtaining the SXEmacs Packaging System and utilities.

Creating Packages

* package-info.in::             package-info.in
* Makefile::                    @file{Makefile}
* Makefile Targets::

Lisp Data Types

* Printed Representation::  How Lisp objects are represented as text.
* Comments::                Comments and their formatting conventions.
* Programming Types::       Types found in all Lisp systems.
* Editing Types::           Types specific to SXEmacs.
* Type Predicates::         Tests related to types.
* Equality Predicates::     Tests of equality between any two objects.

Programming Types

* Integer Type::        Numbers without fractional parts.
* Floating Point Type:: Numbers with fractional parts and with a large range.
* Character Type::      The representation of letters, numbers and
                        control characters.
* Sequence Type::       Both lists and arrays are classified as sequences.
* Cons Cell Type::      Cons cells, and lists (which are made from cons cells).
* Array Type::          Arrays include strings and vectors.
* String Type::         An (efficient) array of characters.
* Vector Type::         One-dimensional arrays.
* Symbol Type::         A multi-use object that refers to a function,
                        variable, property list, or itself.
* Function Type::       A piece of executable code you can call from elsewhere.
* Macro Type::          A method of expanding an expression into another
                          expression, more fundamental but less pretty.
* Primitive Function Type::     A function written in C, callable from Lisp.
* Compiled-Function Type::      A function written in Lisp, then compiled.
* Autoload Type::       A type used for automatically loading seldom-used
                        functions.

Cons Cell Type

* Dotted Pair Notation::    An alternative syntax for lists.
* Association List Type::   A specially constructed list.

Editing Types

* Buffer Type::             The basic object of editing.
* Window Type::             What makes buffers visible.
* Window Configuration Type:: Save what the screen looks like.
* Marker Type::             A position in a buffer.
* Process Type::            A process running on the underlying OS.
* Stream Type::             Receive or send characters.
* Keymap Type::             What function a keystroke invokes.
* Syntax Table Type::       What a character means.

Numbers

* Integer Basics::            Representation and range of integers.
* Float Basics::	      Representation and range of floating point.
* Predicates on Numbers::     Testing for numbers.
* Comparison of Numbers::     Equality and inequality predicates.
* Arithmetic Operations::     How to add, subtract, multiply and divide.
* Bitwise Operations::        Logical and, or, not, shifting.
* Numeric Conversions::	      Converting float to integer and vice versa.
* Math Functions::            Trig, exponential and logarithmic functions.
* Random Numbers::            Obtaining random integers, predictable or not.

Strings and Characters

* String Basics::             Basic properties of strings and characters.
* Predicates for Strings::    Testing whether an object is a string or char.
* Creating Strings::          Functions to allocate new strings.
* Predicates for Characters:: Testing whether an object is a character.
* Character Codes::           Each character has an equivalent integer.
* Text Comparison::           Comparing characters or strings.
* String Conversion::         Converting characters or strings and vice versa.
* Modifying Strings::	      Changing characters in a string.
* String Properties::	      Additional information attached to strings.
* Formatting Strings::        @code{format}: SXEmacs's analog of @code{printf}.
* Character Case::            Case conversion functions.
* Char Tables::               Mapping from characters to Lisp objects.
* Case Tables::		      Customizing case conversion.

Lists

* Cons Cells::              How lists are made out of cons cells.
* Lists as Boxes::          Graphical notation to explain lists.
* List-related Predicates:: Is this object a list?  Comparing two lists.
* List Elements::           Extracting the pieces of a list.
* Building Lists::          Creating list structure.
* Modifying Lists::         Storing new pieces into an existing list.
* Sets And Lists::          A list can represent a finite mathematical set.
* Association Lists::       A list can represent a finite relation or mapping.
* Property Lists::          A different way to represent a finite mapping.
* Weak Lists::              A list with special garbage-collection behavior.

Modifying Existing List Structure

* Setcar::                  Replacing an element in a list.
* Setcdr::                  Replacing part of the list backbone.
                              This can be used to remove or add elements.
* Rearrangement::           Reordering the elements in a list; combining lists.

Sequences, Arrays, and Vectors

* Sequence Functions::      Functions that accept any kind of sequence.
* Arrays::                  Characteristics of arrays in SXEmacs Lisp.
* Array Functions::         Functions specifically for arrays.
* Vectors::                 Functions specifically for vectors.

Symbols

* Symbol Components::       Symbols have names, values, function definitions
                              and property lists.
* Definitions::             A definition says how a symbol will be used.
* Creating Symbols::        How symbols are kept unique.
* Symbol Properties::       Each symbol has a property list
                              for recording miscellaneous information.

Evaluation

* Intro Eval::              Evaluation in the scheme of things.
* Eval::                    How to invoke the Lisp interpreter explicitly.
* Forms::                   How various sorts of objects are evaluated.
* Quoting::                 Avoiding evaluation (to put constants in
                              the program).

Kinds of Forms

* Self-Evaluating Forms::   Forms that evaluate to themselves.
* Symbol Forms::            Symbols evaluate as variables.
* Classifying Lists::       How to distinguish various sorts of list forms.
* Function Forms::          Forms that call functions.
* Macro Forms::             Forms that call macros.
* Special Forms::           ``Special forms'' are idiosyncratic primitives,
                              most of them extremely important.
* Autoloading::             Functions set up to load files
                              containing their real definitions.

Control Structures

* Sequencing::              Evaluation in textual order.
* Conditionals::            @code{if}, @code{cond}.
* Combining Conditions::    @code{and}, @code{or}, @code{not}.
* Iteration::               @code{while} loops.
* Nonlocal Exits::          Jumping out of a sequence.

Nonlocal Exits

* Catch and Throw::         Nonlocal exits for the program's own purposes.
* Examples of Catch::       Showing how such nonlocal exits can be written.
* Errors::                  How errors are signaled and handled.
* Cleanups::                Arranging to run a cleanup form if an
                              error happens.

Errors

* Signaling Errors::        How to report an error.
* Processing of Errors::    What SXEmacs does when you report an error.
* Handling Errors::         How you can trap errors and continue execution.
* Error Symbols::           How errors are classified for trapping them.

Variables

* Global Variables::        Variable values that exist permanently, everywhere.
* Constant Variables::      Certain "variables" have values that never change.
* Local Variables::         Variable values that exist only temporarily.
* Void Variables::          Symbols that lack values.
* Defining Variables::      A definition says a symbol is used as a variable.
* Accessing Variables::     Examining values of variables whose names
                              are known only at run time.
* Setting Variables::       Storing new values in variables.
* Variable Scoping::        How Lisp chooses among local and global values.
* Buffer-Local Variables::  Variable values in effect only in one buffer.

Scoping Rules for Variable Bindings

* Scope::                   Scope means where in the program a value
                              is visible.  Comparison with other languages.
* Extent::                  Extent means how long in time a value exists.
* Impl of Scope::           Two ways to implement dynamic scoping.
* Using Scoping::           How to use dynamic scoping carefully and
                              avoid problems.

Buffer-Local Variables

* Intro to Buffer-Local::   Introduction and concepts.
* Creating Buffer-Local::   Creating and destroying buffer-local bindings.
* Default Value::           The default value is seen in buffers
                              that don't have their own local values.

Functions

* What Is a Function::      Lisp functions vs primitives; terminology.
* Lambda Expressions::      How functions are expressed as Lisp objects.
* Function Names::          A symbol can serve as the name of a function.
* Defining Functions::      Lisp expressions for defining functions.
* Calling Functions::       How to use an existing function.
* Mapping Functions::       Applying a function to each element of a list, etc.
* Anonymous Functions::     Lambda-expressions are functions with no names.
* Function Cells::          Accessing or setting the function definition
                              of a symbol.
* Related Topics::          Cross-references to specific Lisp primitives
                              that have a special bearing on how
                              functions work.

Lambda Expressions

* Lambda Components::       The parts of a lambda expression.
* Simple Lambda::           A simple example.
* Argument List::           Details and special features of argument lists.
* Function Documentation::  How to put documentation in a function.

Macros

* Simple Macro::            A basic example.
* Expansion::               How, when and why macros are expanded.
* Compiling Macros::        How macros are expanded by the compiler.
* Defining Macros::         How to write a macro definition.
* Backquote::               Easier construction of list structure.
* Problems with Macros::    Don't evaluate the macro arguments too many times.
                              Don't hide the user's variables.

Loading

* How Programs Do Loading:: The @code{load} function and others.
* Autoload::                Setting up a function to autoload.
* Named Features::          Loading a library if it isn't already loaded.
* Repeated Loading::        Precautions about loading a file twice.

Byte Compilation

* Speed of Byte-Code::          An example of speedup from byte compilation.
* Compilation Functions::       Byte compilation functions.
* Docs and Compilation::        Dynamic loading of documentation strings.
* Dynamic Loading::             Dynamic loading of individual functions.
* Eval During Compile::  	Code to be evaluated when you compile.
* Compiled-Function Objects::	The data type used for byte-compiled functions.
* Disassembly::                 Disassembling byte-code; how to read byte-code.
* Different Behaviour::         When compiled code gives different results.

Debugging Lisp Programs

* Debugger::                How the SXEmacs Lisp debugger is implemented.
* Syntax Errors::           How to find syntax errors.
* Compilation Errors::      How to find errors that show up in
                              byte compilation.
* Edebug::                  A source-level SXEmacs Lisp debugger.

The Lisp Debugger

* Error Debugging::         Entering the debugger when an error happens.
* Function Debugging::      Entering it when a certain function is called.
* Explicit Debug::          Entering it at a certain point in the program.
* Using Debugger::          What the debugger does; what you see while in it.
* Debugger Commands::       Commands used while in the debugger.
* Invoking the Debugger::   How to call the function @code{debug}.
* Internals of Debugger::   Subroutines of the debugger, and global variables.

Debugging Invalid Lisp Syntax

* Excess Open::             How to find a spurious open paren or missing close.
* Excess Close::            How to find a spurious close paren or missing open.

Reading and Printing Lisp Objects

* Streams Intro::           Overview of streams, reading and printing.
* Input Streams::           Various data types that can be used as
                              input streams.
* Input Functions::         Functions to read Lisp objects from text.
* Output Streams::          Various data types that can be used as
                              output streams.
* Output Functions::        Functions to print Lisp objects as text.

Minibuffers

* Intro to Minibuffers::    Basic information about minibuffers.
* Text from Minibuffer::    How to read a straight text string.
* Object from Minibuffer::  How to read a Lisp object or expression.
* Completion::              How to invoke and customize completion.
* Yes-or-No Queries::       Asking a question with a simple answer.
* Minibuffer Misc::         Various customization hooks and variables.

Completion

* Basic Completion::        Low-level functions for completing strings.
                              (These are too low level to use the minibuffer.)
* Minibuffer Completion::   Invoking the minibuffer with completion.
* Completion Commands::     Minibuffer commands that do completion.
* High-Level Completion::   Convenient special cases of completion
                              (reading buffer name, file name, etc.)
* Reading File Names::      Using completion to read file names.
* Programmed Completion::   Finding the completions for a given file name.

Command Loop

* Command Overview::    How the command loop reads commands.
* Defining Commands::   Specifying how a function should read arguments.
* Interactive Call::    Calling a command, so that it will read arguments.
* Command Loop Info::   Variables set by the command loop for you to examine.
* Events::		What input looks like when you read it.
* Reading Input::       How to read input events from the keyboard or mouse.
* Waiting::             Waiting for user input or elapsed time.
* Quitting::            How @kbd{C-g} works.  How to catch or defer quitting.
* Prefix Command Arguments::    How the commands to set prefix args work.
* Recursive Editing::   Entering a recursive edit,
                          and why you usually shouldn't.
* Disabling Commands::  How the command loop handles disabled commands.
* Command History::     How the command history is set up, and how accessed.
* Keyboard Macros::     How keyboard macros are implemented.

Defining Commands

* Using Interactive::       General rules for @code{interactive}.
* Interactive Codes::       The standard letter-codes for reading arguments
                              in various ways.
* Interactive Examples::    Examples of how to read interactive arguments.

Events

* Event Types::			Events come in different types.
* Event Contents::		What the contents of each event type are.
* Event Predicates::		Querying whether an event is of a
				  particular type.
* Accessing Mouse Event Positions::
				Determining where a mouse event occurred,
				  and over what.
* Accessing Other Event Info::  Accessing non-positional event info.
* Working With Events::		Creating, copying, and destroying events.
* Converting Events::		Converting between events, keys, and
				  characters.

Accessing Mouse Event Positions

* Frame-Level Event Position Info::
* Window-Level Event Position Info::
* Event Text Position Info::
* Event Glyph Position Info::
* Event Toolbar Position Info::
* Other Event Position Info::

Reading Input

* Key Sequence Input::		How to read one key sequence.
* Reading One Event::		How to read just one event.
* Dispatching an Event::        What to do with an event once it has been read.
* Quoted Character Input::	Asking the user to specify a character.
* Peeking and Discarding::	How to reread or throw away input events.

Keymaps

* Keymap Terminology::        	Definitions of terms pertaining to keymaps.
* Format of Keymaps::		What a keymap looks like as a Lisp object.
* Creating Keymaps:: 		Functions to create and copy keymaps.
* Inheritance and Keymaps::	How one keymap can inherit the bindings
				  of another keymap.
* Key Sequences::               How to specify key sequences.
* Prefix Keys::                 Defining a key with a keymap as its definition.
* Active Keymaps::	        Each buffer has a local keymap
                                  to override the standard (global) bindings.
				Each minor mode can also override them.
* Key Lookup::                  How extracting elements from keymaps works.
* Functions for Key Lookup::    How to request key lookup.
* Changing Key Bindings::       Redefining a key in a keymap.
* Key Binding Commands::        Interactive interfaces for redefining keys.
* Scanning Keymaps::            Looking through all keymaps, for printing help.
* Other Keymap Functions::      Miscellaneous keymap functions.

Menus

* Menu Format::		Format of a menu description.
* Menubar Format::	How to specify a menubar.
* Menubar::		Functions for controlling the menubar.
* Modifying Menus::	Modifying a menu description.
* Pop-Up Menus::	Functions for specifying pop-up menus.
* Menu Filters::	Filter functions for the default menubar.
* Buffers Menu::	The menu that displays the list of buffers.

Dialog Boxes

* Dialog Box Format::
* Dialog Box Functions::

Toolbar

* Toolbar Intro::		An introduction.
* Toolbar Descriptor Format::	How to create a toolbar.
* Specifying the Toolbar::	Setting a toolbar.
* Other Toolbar Variables::	Controlling the size of toolbars.

Gutter

Scrollbars

Major and Minor Modes

* Major Modes::             Defining major modes.
* Minor Modes::             Defining minor modes.
* Modeline Format::         Customizing the text that appears in the modeline.
* Hooks::                   How to use hooks; how to write code that
                              provides hooks.

Major Modes

* Major Mode Conventions::  Coding conventions for keymaps, etc.
* Example Major Modes::     Text mode and Lisp modes.
* Auto Major Mode::         How SXEmacs chooses the major mode automatically.
* Mode Help::               Finding out how to use a mode.

Minor Modes

* Minor Mode Conventions::  Tips for writing a minor mode.
* Keymaps and Minor Modes:: How a minor mode can have its own keymap.

Modeline Format

* Modeline Data::           The data structure that controls the modeline.
* Modeline Variables::      Variables used in that data structure.
* %-Constructs::            Putting information into a modeline.

Documentation

* Documentation Basics::    Good style for doc strings.
                              Where to put them.  How SXEmacs stores them.
* Accessing Documentation:: How Lisp programs can access doc strings.
* Keys in Documentation::   Substituting current key bindings.
* Describing Characters::   Making printable descriptions of
                              non-printing characters and key sequences.
* Help Functions::          Subroutines used by SXEmacs help facilities.

Files

* Visiting Files::          Reading files into Emacs buffers for editing.
* Saving Buffers::          Writing changed buffers back into files.
* Reading from Files::      Reading files into other buffers.
* Writing to Files::        Writing new files from parts of buffers.
* File Locks::              Locking and unlocking files, to prevent
                                simultaneous editing by two people.
* Information about Files::   Testing existence, accessibility, size of files.
* Contents of Directories::   Getting a list of the files in a directory.
* Changing File Attributes::  Renaming files, changing protection, etc.
* File Names::                Decomposing and expanding file names.

Visiting Files

* Visiting Functions::      The usual interface functions for visiting.
* Subroutines of Visiting:: Lower-level subroutines that they use.

Information about Files

* Testing Accessibility::   Is a given file readable?  Writable?
* Kinds of Files::          Is it a directory?  A link?
* File Attributes::         How large is it?  Any other names?  Etc.

File Names

* File Name Components::    The directory part of a file name, and the rest.
* Directory Names::         A directory's name as a directory
                              is different from its name as a file.
* Relative File Names::     Some file names are relative to a
                              current directory.
* File Name Expansion::     Converting relative file names to absolute ones.
* Unique File Names::       Generating names for temporary files.
* File Name Completion::    Finding the completions for a given file name.

Backups and Auto-Saving

* Backup Files::            How backup files are made; how their names
                              are chosen.
* Auto-Saving::             How auto-save files are made; how their
                              names are chosen.
* Reverting::               @code{revert-buffer}, and how to customize
                              what it does.

Backup Files

* Making Backups::          How SXEmacs makes backup files, and when.
* Rename or Copy::          Two alternatives: renaming the old file
                              or copying it.
* Numbered Backups::        Keeping multiple backups for each source file.
* Backup Names::            How backup file names are computed; customization.

Buffers

* Buffer Basics::           What is a buffer?
* Buffer Names::            Accessing and changing buffer names.
* Buffer File Name::        The buffer file name indicates which file
                              is visited.
* Buffer Modification::     A buffer is @dfn{modified} if it needs to be saved.
* Modification Time::       Determining whether the visited file was changed
                              ``behind SXEmacs's back''.
* Read Only Buffers::       Modifying text is not allowed in a
                              read-only buffer.
* The Buffer List::         How to look at all the existing buffers.
* Creating Buffers::        Functions that create buffers.
* Killing Buffers::         Buffers exist until explicitly killed.
* Current Buffer::          Designating a buffer as current
                              so primitives will access its contents.

Windows

* Basic Windows::           Basic information on using windows.
* Splitting Windows::       Splitting one window into two windows.
* Deleting Windows::        Deleting a window gives its space to other windows.
* Selecting Windows::       The selected window is the one that you edit in.
* Cyclic Window Ordering::  Moving around the existing windows.
* Buffers and Windows::     Each window displays the contents of a buffer.
* Displaying Buffers::      Higher-lever functions for displaying a buffer
                              and choosing a window for it.
* Window Point::            Each window has its own location of point.
* Window Start::            The display-start position controls which text
                              is on-screen in the window.
* Vertical Scrolling::      Moving text up and down in the window.
* Horizontal Scrolling::    Moving text sideways on the window.
* Size of Window::          Accessing the size of a window.
* Resizing Windows::        Changing the size of a window.
* Window Configurations::   Saving and restoring the state of the screen.

Frames

* Creating Frames::	    Creating additional frames.
* Frame Properties::	    Controlling frame size, position, font, etc.
* Frame Titles::            Automatic updating of frame titles.
* Deleting Frames::	    Frames last until explicitly deleted.
* Finding All Frames::	    How to examine all existing frames.
* Frames and Windows::	    A frame contains windows;
			      display of text always works through windows.
* Minibuffers and Frames::  How a frame finds the minibuffer to use.
* Input Focus::		    Specifying the selected frame.
* Visibility of Frames::    Frames may be visible or invisible, or icons.
* Raising and Lowering::    Raising a frame makes it hide other X windows;
			      lowering it makes the others hide them.
* Frame Hooks::             Hooks for customizing frame behavior.

Positions

* Point::                   The special position where editing takes place.
* Motion::                  Changing point.
* Excursions::              Temporary motion and buffer changes.
* Narrowing::               Restricting editing to a portion of the buffer.

Motion

* Character Motion::        Moving in terms of characters.
* Word Motion::             Moving in terms of words.
* Buffer End Motion::       Moving to the beginning or end of the buffer.
* Text Lines::              Moving in terms of lines of text.
* Screen Lines::            Moving in terms of lines as displayed.
* List Motion::             Moving by parsing lists and sexps.
* Skipping Characters::     Skipping characters belonging to a certain set.

Markers

* Overview of Markers::     The components of a marker, and how it relocates.
* Predicates on Markers::   Testing whether an object is a marker.
* Creating Markers::        Making empty markers or markers at certain places.
* Information from Markers::  Finding the marker's buffer or character
                                position.
* Changing Markers::        Moving the marker to a new buffer or position.
* The Mark::                How ``the mark'' is implemented with a marker.
* The Region::              How to access ``the region''.

Text

* Near Point::       Examining text in the vicinity of point.
* Buffer Contents::  Examining text in a general fashion.
* Comparing Text::   Comparing substrings of buffers.
* Insertion::        Adding new text to a buffer.
* Commands for Insertion::  User-level commands to insert text.
* Deletion::         Removing text from a buffer.
* User-Level Deletion::     User-level commands to delete text.
* The Kill Ring::    Where removed text sometimes is saved for later use.
* Undo::             Undoing changes to the text of a buffer.
* Maintaining Undo:: How to enable and disable undo information.
			How to control how much information is kept.
* Filling::          Functions for explicit filling.
* Margins::          How to specify margins for filling commands.
* Auto Filling::     How auto-fill mode is implemented to break lines.
* Sorting::          Functions for sorting parts of the buffer.
* Columns::          Computing horizontal positions, and using them.
* Indentation::      Functions to insert or adjust indentation.
* Case Changes::     Case conversion of parts of the buffer.
* Text Properties::  Assigning Lisp property lists to text characters.
* Substitution::     Replacing a given character wherever it appears.
* Registers::        How registers are implemented.  Accessing the text or
                       position stored in a register.
* Transposition::    Swapping two portions of a buffer.
* Change Hooks::     Supplying functions to be run when text is changed.

The Kill Ring

* Kill Ring Concepts::      What text looks like in the kill ring.
* Kill Functions::          Functions that kill text.
* Yank Commands::           Commands that access the kill ring.
* Low-Level Kill Ring::	    Functions and variables for kill ring access.
* Internals of Kill Ring::  Variables that hold kill-ring data.

Indentation

* Primitive Indent::        Functions used to count and insert indentation.
* Mode-Specific Indent::    Customize indentation for different modes.
* Region Indent::           Indent all the lines in a region.
* Relative Indent::         Indent the current line based on previous lines.
* Indent Tabs::             Adjustable, typewriter-like tab stops.
* Motion by Indent::        Move to first non-blank character.

Searching and Matching

* String Search::           Search for an exact match.
* Regular Expressions::     Describing classes of strings.
* Regexp Search::           Searching for a match for a regexp.
* Match Data::              Finding out which part of the text matched
                              various parts of a regexp, after regexp search.
* Saving Match Data::       Saving and restoring this information.
* Standard Regexps::        Useful regexps for finding sentences, pages,...
* Searching and Case::      Case-independent or case-significant searching.

Regular Expressions

* Syntax of Regexps::       Rules for writing regular expressions.
* Regexp Example::          Illustrates regular expression syntax.

Syntax Tables

* Syntax Descriptors::      How characters are classified.
* Syntax Table Functions::  How to create, examine and alter syntax tables.
* Parsing Expressions::     Parsing balanced expressions
                              using the syntax table.
* Standard Syntax Tables::  Syntax tables used by various major modes.
* Syntax Table Internals::  How syntax table information is stored.

Syntax Descriptors

* Syntax Class Table::      Table of syntax classes.
* Syntax Flags::            Additional flags each character can have.

Abbrevs And Abbrev Expansion

* Abbrev Mode::             Setting up SXEmacs for abbreviation.
* Tables: Abbrev Tables.    Creating and working with abbrev tables.
* Defining Abbrevs::        Specifying abbreviations and their expansions.
* Files: Abbrev Files.      Saving abbrevs in files.
* Expansion: Abbrev Expansion.  Controlling expansion; expansion subroutines.
* Standard Abbrev Tables::  Abbrev tables used by various major modes.

Extents

* Intro to Extents::	   Extents are regions over a buffer or string.
* Creating and Modifying Extents::
			   Basic extent functions.
* Extent Endpoints::	   Accessing and setting the bounds of an extent.
* Finding Extents::	   Determining which extents are in an object.
* Mapping Over Extents::   More sophisticated functions for extent scanning.
* Extent Properties::	   Extents have built-in and user-definable properties.
* Detached Extents::	   Extents that are not in a buffer.
* Extent Parents::         Inheriting properties from another extent.
* Duplicable Extents::	   Extents can be marked to be copied into strings.
* Extents and Events::	   Extents can interact with the keyboard and mouse.
* Atomic Extents::	   Treating a block of text as a single entity.

Specifiers

* Introduction to Specifiers::	Specifiers provide a clean way for
				display and other properties to vary
				(under user control) in a wide variety
				of contexts.
* Specifiers In-Depth::		Gory details about specifier innards.
* Specifier Instancing::	Instancing means obtaining the ``value'' of
				a specifier in a particular context.
* Specifier Types::		Specifiers come in different flavors.
* Adding Specifications::	Specifications control a specifier's ``value''
				by giving conditions under which a
				particular value is valid.
* Retrieving Specifications::	Querying a specifier's specifications.
* Specifier Instancing Functions::
				Functions to instance a specifier.
* Specifier Examples::		Making all this stuff clearer.
* Creating Specifiers::		Creating specifiers for your own use.
* Specifier Validation Functions::
				Validating the components of a specifier.
* Other Specification Functions::
				Other ways of working with specifications.

Faces and Window-System Objects

* Faces::		Controlling the way text looks.
* Fonts::		Controlling the typeface of text.
* Colors::		Controlling the color of text and pixmaps.

Faces

* Merging Faces::		How SXEmacs decides which face to use
				  for a character.
* Basic Face Functions::	How to define and examine faces.
* Face Properties::		How to access and modify a face's properties.
* Face Convenience Functions::	Convenience functions for accessing
				  particular properties of a face.
* Other Face Display Functions:: Other functions pertaining to how a
				  a face appears.

Fonts

* Font Specifiers::		Specifying how a font will appear.
* Font Instances::		What a font specifier gets instanced as.
* Font Instance Names::		The name of a font instance.
* Font Instance Size::		The size of a font instance.
* Font Instance Characteristics:: Display characteristics of font instances.
* Font Convenience Functions::	Convenience functions that automatically
				  instance and retrieve the properties
				  of a font specifier.

Colors

* Color Specifiers::		Specifying how a colour will appear.
* Color Instances::		What a colour specifier gets instanced as.
* Color Instance Properties::	Properties of color instances.
* Color Convenience Functions::	Convenience functions that automatically
				  instance and retrieve the properties
				  of a colour specifier.

Glyphs

* Glyph Intro::		Glyphs are abstract image specifications.
* Images::		Specifying the appearance of glyphs.
* Using Glyphs::	Creating and displaying glyphs.
* Manipulating Glyphs::	Getting and setting glyph properties.
* Glyph Examples::	Examples of how to work with glyphs.

Images

* Image Specifiers::			Specifying an image's appearance.
* Image Instantiator Conversion::	Lazy realization of graphics.
* Image Instantiator Formats::		A catalog of image descriptors.
* Image Instances::			Classes of graphical objects.

Image Instances

* Image Instance Types::         Each image instances has a particular type.
* Image Instance Functions::	 Functions for working with image instances.

Using Glyphs


Image Instances

* Image Instance Types::         Each image instances has a particular type.
* Image Instance Functions::	 Functions for working with image instances.

Using Glyphs

* Creating Glyphs::	Creating new glyphs.
* Buffer Glyphs::	Annotations are glyphs that appear in a buffer.
* Redisplay Glyphs::	Glyphs controlling various redisplay functions.
* Frame Glyphs::	Displaying glyphs in GUI components of the frame.
* External Glyphs::	Icons and mouse pointers for the window system.
* Native GUI Widgets::	Complex active elements treated as a single glyph.
* Subwindows::		Externally-controlled subwindows in buffers.

Native GUI Widgets

* Introduction to Widgets::     Native widgets provide tight integration of
                                GUI features with the platform GUI.
* Lisp API to Native Widgets::  Native widgets are glyphs.
* Layouts::                     Specifying composite widgets from Lisp.
* Primitive Widgets::           Catalogue of available native widgets.

Manipulating Glyphs

* Glyph Properties::	Accessing and modifying a glyph's properties.
* Glyph Convenience Functions::  Accessing particular properties of a glyph.
* Glyph Dimensions::	Determining the height, width, etc. of a glyph.
* Glyph Types::		Each glyph has a particular type.

Annotations

* Annotation Basics::		Introduction to annotations.
* Annotation Primitives::	Creating and deleting annotations.
* Annotation Properties::	Retrieving and changing the characteristics
				  of an annotation.
* Margin Primitives::		Controlling the size of the margins.
* Locating Annotations::	Looking for annotations in a buffer.
* Annotation Hooks::		Hooks called at certain times during an
				  annotation's lifetime.

Hash Tables

* Introduction to Hash Tables::	Hash tables are fast data structures for
                                implementing simple tables (i.e. finite
                                mappings from keys to values).
* Working With Hash Tables::    Hash table functions.
* Weak Hash Tables::            Hash tables with special garbage-collection
                                behavior.

Range Tables

* Introduction to Range Tables:: Range tables efficiently map ranges of
                                 integers to values.
* Working With Range Tables::    Range table functions.


SXEmacs Display

* Refresh Screen::      Clearing the screen and redrawing everything on it.
* Truncation::          Folding or wrapping long text lines.
* The Echo Area::       Where messages are displayed.
* Selective Display::   Hiding part of the buffer text.
* Overlay Arrow::       Display of an arrow to indicate position.
* Temporary Displays::  Displays that go away automatically.
* Blinking::            How SXEmacs shows the matching open parenthesis.
* Usual Display::	The usual conventions for displaying nonprinting chars.
* Display Tables::	How to specify other conventions.
* Beeping::             Audible signal to the user.

Processes

* Subprocess Creation::     Functions that start subprocesses.
* Synchronous Processes::   Details of using synchronous subprocesses.
* Asynchronous Processes::  Starting up an asynchronous subprocess.
* Deleting Processes::      Eliminating an asynchronous subprocess.
* Process Information::     Accessing run-status and other attributes.
* Input to Processes::      Sending input to an asynchronous subprocess.
* Signals to Processes::    Stopping, continuing or interrupting
                              an asynchronous subprocess.
* Output from Processes::   Collecting output from an asynchronous subprocess.
* Sentinels::               Sentinels run when process run-status changes.
* Network::                 Opening network connections.

Receiving Output from Processes

* Process Buffers::         If no filter, output is put in a buffer.
* Filter Functions::        Filter functions accept output from the process.
* Accepting Output::        How to wait until process output arrives.

Operating System Interface

* Starting Up::             Customizing SXEmacs start-up processing.
* Getting Out::             How exiting works (permanent or temporary).
* System Environment::      Distinguish the name and kind of system.
* Terminal Input::          Recording terminal input for debugging.
* Terminal Output::         Recording terminal output for debugging.
* Flow Control::            How to turn output flow control on or off.
* Batch Mode::              Running SXEmacs without terminal interaction.

Starting Up SXEmacs

* Start-up Summary::        Sequence of actions SXEmacs performs at start-up.
* Init File::               Details on reading the init file (@file{.emacs}).
* Terminal-Specific::       How the terminal-specific Lisp file is read.
* Command Line Arguments::  How command line arguments are processed,
                              and how you can customize them.

Getting out of SXEmacs

* Killing SXEmacs::         Exiting SXEmacs irreversibly.
* Suspending SXEmacs::      Exiting SXEmacs reversibly.

X-Windows

* X Selections::		Transferring text to and from other X clients.
* X Server::			Information about the X server connected to
				  a particular device.
* Resources::			Getting resource values from the server.
* Server Data::			Getting info about the X server.
* Grabs::			Restricting access to the server by other apps.
* X Miscellaneous::             Other X-specific functions and variables.

ToolTalk Support

* SXEmacs ToolTalk API Summary::
* Sending Messages::
* Receiving Messages::

LDAP Support

* Building SXEmacs with LDAP support::  How to add LDAP support to SXEmacs
* SXEmacs LDAP API::             Lisp access to LDAP functions
* Syntax of Search Filters::     A brief summary of RFC 1558

SXEmacs LDAP API

* LDAP Variables::              Lisp variables related to LDAP
* The High-Level LDAP API::     High-level LDAP lisp functions
* The Low-Level LDAP API::      Low-level LDAP lisp primitives
* LDAP Internationalization::   I18n variables and functions

The Low-Level LDAP API

* The LDAP Lisp Object::
* Opening and Closing a LDAP Connection::
* Low-level Operations on a LDAP Server::

LDAP Internationalization

* LDAP Internationalization Variables::
* Encoder/Decoder Functions::

PostgreSQL Support

* Building SXEmacs with PostgreSQL support::
* SXEmacs PostgreSQL libpq API::
* SXEmacs PostgreSQL libpq Examples::

SXEmacs PostgreSQL libpq API

* libpq Lisp Variables::
* libpq Lisp Symbols and DataTypes::
* Synchronous Interface Functions::
* Asynchronous Interface Functions::
* Large Object Support::
* Other libpq Functions::
* Unimplemented libpq Functions::

OpenSSL Support

* Building SXEmacs with OpenSSL support::
* SXEmacs OpenSSL API::
* SXEmacs openssl Examples::

SXEmacs OpenSSL API

* openssl Submodules::
* openssl Lisp Symbols and Datatypes::
* Unimplemented openssl Functions::

Enhanced Number Types

* ENT Basics::			Introduction to enhanced numbers.

Internationalization

* I18N Levels 1 and 2:: Support for different time, date, and currency formats.
* I18N Level 3::        Support for localized messages.
* I18N Level 4::        Support for Asian languages.

MULE

* Internationalization Terminology::
                        Definition of various internationalization terms.
* Charsets::            Sets of related characters.
* MULE Characters::     Working with characters in SXEmacs/MULE.
* Composite Characters:: Making new characters by overstriking other ones.
* ISO 2022::            An international standard for charsets and encodings.
* Coding Systems::      Ways of representing a string of chars using integers.
* CCL::                 A special language for writing fast converters.
* Category Tables::     Subdividing charsets into groups.

Tips

* Style Tips::                Writing clean and robust programs.
* Compilation Tips::          Making compiled code run fast.
* Documentation Tips::        Writing readable documentation strings.
* Comment Tips::	      Conventions for writing comments.
* Library Headers::           Standard headers for library packages.

Building SXEmacs and Object Allocation

* Building SXEmacs::        How to preload Lisp libraries into SXEmacs.
* Pure Storage::            A kludge to make preloaded Lisp functions sharable.
* Garbage Collection::      Reclaiming space for Lisp objects no longer used.

@end menu

@include intro.texi
@include packaging.texi
@include objects.texi
@include numbers.texi
@include strings.texi

@include lists.texi
@include sequences.texi
@include symbols.texi
@include eval.texi

@include control.texi
@include variables.texi
@include functions.texi
@include macros.texi
@include customize.texi

@include loading.texi
@include compile.texi
@include debugging.texi
@include streams.texi

@include minibuf.texi
@include commands.texi
@include keymaps.texi
@include menus.texi
@include dialog.texi
@include toolbar.texi
@include gutter.texi
@include scrollbars.texi
@include dragndrop.texi
@include modes.texi

@include help.texi
@include files.texi
@include backups.texi
@include buffers.texi

@include windows.texi
@include frames.texi
@include consoles-devices.texi
@include positions.texi
@include markers.texi
@include text.texi

@include searching.texi
@include syntax.texi
@include abbrevs.texi

@include extents.texi
@include specifiers.texi
@include faces.texi
@include glyphs.texi
@include annotations.texi
@include display.texi

@include hash-tables.texi
@include range-tables.texi
@include databases.texi

@include processes.texi
@include os.texi
@include x-windows.texi
@include tooltalk.texi
@include ldap.texi
@include postgresql.texi
@include openssl.texi
@include ent.texi
@include internationalization.texi
@include ffi.texi
@include mule.texi

@c MOVE to User's Manual:  include calendar.texi

@c MOVE to User's Manual:  include misc-modes.texi

@c appendices

@c  REMOVE this:  include non-hacker.texi

@include tips.texi
@include building.texi
@include errors.texi
@include locals.texi
@include maps.texi
@include hooks.texi

@include index.texi

@c Print the tables of contents
@summarycontents
@contents
@c That's all

@bye


These words prevent "local variables" above from confusing SXEmacs.
