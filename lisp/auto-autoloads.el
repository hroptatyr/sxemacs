;;; DO NOT MODIFY THIS FILE
(if (featurep 'lisp-autoloads) (error "Already loaded"))

;;;### (autoloads nil "abbrev" "lisp/abbrev.el")

;;;***

;;;### (autoloads (about-xemacs) "about" "lisp/about.el")

(autoload 'about-xemacs "about" "\
Describe the True Editor and its minions." t nil)

;;;***

;;;### (autoloads (set-modified-alist modify-alist remove-alist set-alist del-alist put-alist vassoc) "alist" "lisp/alist.el")

(autoload 'vassoc "alist" "\
Search VALIST for a vector whose first element is equal to KEY.
See also `assoc'." nil nil)

(autoload 'put-alist "alist" "\
Modify ALIST to set VALUE to ITEM.
If there is a pair whose car is ITEM, replace its cdr by VALUE.
If there is not such pair, create new pair (ITEM . VALUE) and
return new alist whose car is the new pair and cdr is ALIST.
[tomo's ELIS like function]" nil nil)

(autoload 'del-alist "alist" "\
If there is a pair whose key is ITEM, delete it from ALIST.
[tomo's ELIS emulating function]" nil nil)

(autoload 'set-alist "alist" "\
Modify a alist indicated by SYMBOL to set VALUE to ITEM." nil nil)

(autoload 'remove-alist "alist" "\
Remove ITEM from the alist indicated by SYMBOL." nil nil)

(autoload 'modify-alist "alist" "\
Modify alist DEFAULT into alist MODIFIER." nil nil)

(autoload 'set-modified-alist "alist" "\
Modify a value of a symbol SYM into alist MODIFIER.
The symbol SYM should be alist. If it is not bound,
its value regard as nil." nil nil)

;;;***

;;;### (autoloads (apropos-documentation apropos-value apropos apropos-command) "apropos" "lisp/apropos.el")

(fset 'command-apropos 'apropos-command)

(autoload 'apropos-command "apropos" "\
Shows commands (interactively callable functions) that match REGEXP.
With optional prefix ARG or if `apropos-do-all' is non-nil, also show
variables." t nil)

(autoload 'apropos "apropos" "\
Show all bound symbols whose names match REGEXP.
With optional prefix ARG or if `apropos-do-all' is non-nil, also show unbound
symbols and key bindings, which is a little more time-consuming.
Returns list of symbols and documentation found." t nil)

(autoload 'apropos-value "apropos" "\
Show all symbols whose value's printed image matches REGEXP.
With optional prefix ARG or if `apropos-do-all' is non-nil, also looks
at the function and at the names and values of properties.
Returns list of symbols and values found." t nil)

(autoload 'apropos-documentation "apropos" "\
Show symbols whose documentation contain matches for REGEXP.
With optional prefix ARG or if `apropos-do-all' is non-nil, also use
documentation that is not stored in the documentation file and show key
bindings.
Returns list of symbols and documentation found." t nil)

;;;***

;;;### (autoloads (batch-update-one-directory batch-update-directory batch-update-autoloads update-autoloads-from-directory update-autoloads-here update-file-autoloads generate-file-autoloads) "autoload" "lisp/autoload.el")

(autoload 'generate-file-autoloads "autoload" "\
Insert at point a loaddefs autoload section for FILE.
autoloads are generated for defuns and defmacros in FILE
marked by `generate-autoload-cookie' (which see).
If FILE is being visited in a buffer, the contents of the buffer
are used." t nil)

(autoload 'update-file-autoloads "autoload" "\
Update the autoloads for FILE in `generated-autoload-file'
\(which FILE might bind in its local variables).
This function refuses to update autoloads files." t nil)

(autoload 'update-autoloads-here "autoload" "\
Update sections of the current buffer generated by `update-file-autoloads'." t nil)

(autoload 'update-autoloads-from-directory "autoload" "\
Update `generated-autoload-file' with all the current autoloads from DIR.
This runs `update-file-autoloads' on each .el file in DIR.
Obsolete autoload entries for files that no longer exist are deleted.
Note that, if this function is called from `batch-update-directory',
`generated-autoload-file' was rebound in that function." t nil)

(autoload 'batch-update-autoloads "autoload" "\
Update the autoloads for the files or directories on the command line.
Runs `update-file-autoloads' on files and `update-directory-autoloads'
on directories.  Must be used only with -batch, and kills Emacs on completion.
Each file will be processed even if an error occurred previously.
For example, invoke `xemacs -batch -f batch-update-autoloads *.el'.
The directory to which the auto-autoloads.el file must be the first parameter
on the command line." nil nil)

(autoload 'batch-update-directory "autoload" "\
Update the autoloads for the directories on the command line.
Runs `update-file-autoloads' on each file in the given directory, and must
be used only with -batch." nil nil)

(autoload 'batch-update-one-directory "autoload" "\
Update the autoloads for a single directory on the command line.
Runs `update-file-autoloads' on each file in the given directory, and must
be used only with -batch." nil nil)

;;;***

;;;### (autoloads nil "buff-menu" "lisp/buff-menu.el")

(defvar list-buffers-directory nil)

(make-variable-buffer-local 'list-buffers-directory)

;;;***

;;;### (autoloads (build-report) "build-report" "lisp/build-report.el")

(autoload 'build-report "build-report" "\
Report build information including Installation and make output.

Prompts for status (usually \"Success\" or \"Failure\").  Then uses
`compose-mail' to create a mail message.  The Subject header contains
status and version information.  Point is left at the beginning of the
mail text.  Add some notes if you like, and send the report.

Looks for Installation and the make output file (`beta.err' by
default, customizable via `build-report-make-output-files') in the
build directory of the running XEmacs by default (customizable via
`build-report-make-output-dir').  The output from make is filtered
through `build-report-keep-regexp' and `build-report-delete-regexp'
before including in the message.

See also `mail-user-agent', `build-report-destination', and
`build-report-installation-file'." t nil)

;;;***

;;;### (autoloads (batch-byte-recompile-directory batch-byte-recompile-directory-norecurse batch-byte-compile-one-file batch-byte-compile display-call-tree byte-compile-sexp byte-compile compile-defun byte-compile-buffer byte-compile-and-load-file byte-compile-file byte-recompile-file byte-recompile-directory byte-force-recompile) "bytecomp" "lisp/bytecomp.el")

(autoload 'byte-force-recompile "bytecomp" "\
Recompile every `.el' file in DIRECTORY that already has a `.elc' file.
Files in subdirectories of DIRECTORY are processed also." t nil)

(autoload 'byte-recompile-directory "bytecomp" "\
Recompile every `.el' file in DIRECTORY that needs recompilation.
This is if a `.elc' file exists but is older than the `.el' file.
Files in subdirectories of DIRECTORY are also processed unless
optional argument NORECURSION is non-nil.

If the `.elc' file does not exist, normally the `.el' file is *not* compiled.
But a prefix argument (optional second arg) means ask user,
for each such `.el' file, whether to compile it.  Prefix argument 0 means
don't ask and compile the file anyway.

A nonzero prefix argument also means ask about each subdirectory.

If the fourth optional argument FORCE is non-nil,
recompile every `.el' file that already has a `.elc' file." t nil)

(autoload 'byte-recompile-file "bytecomp" "\
Recompile a file of Lisp code named FILENAME if it needs recompilation.
This is if the `.elc' file exists but is older than the `.el' file.

If the `.elc' file does not exist, normally the `.el' file is *not*
compiled.  But a prefix argument (optional second arg) means ask user
whether to compile it.  Prefix argument 0 don't ask and recompile anyway." t nil)

(autoload 'byte-compile-file "bytecomp" "\
Compile a file of Lisp code named FILENAME into a file of byte code.
The output file's name is made by appending `c' to the end of FILENAME.
With prefix arg (noninteractively: 2nd arg), load the file after compiling." t nil)

(autoload 'byte-compile-and-load-file "bytecomp" "\
Compile a file of Lisp code named FILENAME into a file of byte code,
and then load it.  The output file's name is made by appending \"c\" to
the end of FILENAME." t nil)

(autoload 'byte-compile-buffer "bytecomp" "\
Byte-compile and evaluate contents of BUFFER (default: the current buffer)." t nil)

(autoload 'compile-defun "bytecomp" "\
Compile and evaluate the current top-level form.
Print the result in the minibuffer.
With argument, insert value in current buffer after the form." t nil)

(autoload 'byte-compile "bytecomp" "\
If FORM is a symbol, byte-compile its function definition.
If FORM is a lambda or a macro, byte-compile it as a function." nil nil)

(autoload 'byte-compile-sexp "bytecomp" "\
Compile and return SEXP." nil nil)

(autoload 'display-call-tree "bytecomp" "\
Display a call graph of a specified file.
This lists which functions have been called, what functions called
them, and what functions they call.  The list includes all functions
whose definitions have been compiled in this Emacs session, as well as
all functions called by those functions.

The call graph does not include macros, inline functions, or
primitives that the byte-code interpreter knows about directly (eq,
cons, etc.).

The call tree also lists those functions which are not known to be called
\(that is, to which no calls have been compiled), and which cannot be
invoked interactively." t nil)

(autoload 'batch-byte-compile "bytecomp" "\
Run `byte-compile-file' on the files remaining on the command line.
Use this from the command line, with `-batch';
it won't work in an interactive Emacs.
Each file is processed even if an error occurred previously.
For example, invoke \"xemacs -batch -f batch-byte-compile $emacs/ ~/*.el\"." nil nil)

(autoload 'batch-byte-compile-one-file "bytecomp" "\
Run `byte-compile-file' on a single file remaining on the command line.
Use this from the command line, with `-batch';
it won't work in an interactive Emacs." nil nil)

(autoload 'batch-byte-recompile-directory-norecurse "bytecomp" "\
Same as `batch-byte-recompile-directory' but without recursion." nil nil)

(autoload 'batch-byte-recompile-directory "bytecomp" "\
Runs `byte-recompile-directory' on the dirs remaining on the command line.
Must be used only with `-batch', and kills Emacs on completion.
For example, invoke `xemacs -batch -f batch-byte-recompile-directory .'." nil nil)

;;;***

;;;### (autoloads (compiler-macroexpand define-compiler-macro ignore-file-errors ignore-errors assert check-type typep deftype cl-struct-setf-expander defstruct define-modify-macro callf2 callf letf* letf rotatef shiftf remf cl-do-pop psetf setf get-setf-method defsetf define-setf-method declare the locally multiple-value-setq multiple-value-bind lexical-let* lexical-let symbol-macrolet macrolet labels flet progv psetq do-all-symbols do-symbols dotimes dolist do* do loop return-from return block etypecase typecase ecase case load-time-value eval-when destructuring-bind function* defmacro* defun* cl-compile-time-init) "cl-macs" "lisp/cl-macs.el")

(autoload 'cl-compile-time-init "cl-macs" nil nil nil)

(autoload 'defun* "cl-macs" "\
(defun* NAME ARGLIST [DOCSTRING] BODY...): define NAME as a function.
Like normal `defun', except ARGLIST allows full Common Lisp conventions,
and BODY is implicitly surrounded by (block NAME ...)." nil 'macro)

(autoload 'defmacro* "cl-macs" "\
(defmacro* NAME ARGLIST [DOCSTRING] BODY...): define NAME as a macro.
Like normal `defmacro', except ARGLIST allows full Common Lisp conventions,
and BODY is implicitly surrounded by (block NAME ...)." nil 'macro)

(autoload 'function* "cl-macs" "\
(function* SYMBOL-OR-LAMBDA): introduce a function.
Like normal `function', except that if argument is a lambda form, its
ARGLIST allows full Common Lisp conventions." nil 'macro)

(autoload 'destructuring-bind "cl-macs" nil nil 'macro)

(autoload 'eval-when "cl-macs" "\
(eval-when (WHEN...) BODY...): control when BODY is evaluated.
If `compile' is in WHEN, BODY is evaluated when compiled at top-level.
If `load' is in WHEN, BODY is evaluated when loaded after top-level compile.
If `eval' is in WHEN, BODY is evaluated when interpreted or at non-top-level." nil 'macro)

(autoload 'load-time-value "cl-macs" "\
Like `progn', but evaluates the body at load time.
The result of the body appears to the compiler as a quoted constant." nil 'macro)

(autoload 'case "cl-macs" "\
(case EXPR CLAUSES...): evals EXPR, chooses from CLAUSES on that value.
Each clause looks like (KEYLIST BODY...).  EXPR is evaluated and compared
against each key in each KEYLIST; the corresponding BODY is evaluated.
If no clause succeeds, case returns nil.  A single atom may be used in
place of a KEYLIST of one atom.  A KEYLIST of `t' or `otherwise' is
allowed only in the final clause, and matches if no other keys match.
Key values are compared by `eql'." nil 'macro)

(autoload 'ecase "cl-macs" "\
(ecase EXPR CLAUSES...): like `case', but error if no case fits.
`otherwise'-clauses are not allowed." nil 'macro)

(autoload 'typecase "cl-macs" "\
(typecase EXPR CLAUSES...): evals EXPR, chooses from CLAUSES on that value.
Each clause looks like (TYPE BODY...).  EXPR is evaluated and, if it
satisfies TYPE, the corresponding BODY is evaluated.  If no clause succeeds,
typecase returns nil.  A TYPE of `t' or `otherwise' is allowed only in the
final clause, and matches if no other keys match." nil 'macro)

(autoload 'etypecase "cl-macs" "\
(etypecase EXPR CLAUSES...): like `typecase', but error if no case fits.
`otherwise'-clauses are not allowed." nil 'macro)

(autoload 'block "cl-macs" "\
(block NAME BODY...): define a lexically-scoped block named NAME.
NAME may be any symbol.  Code inside the BODY forms can call `return-from'
to jump prematurely out of the block.  This differs from `catch' and `throw'
in two respects:  First, the NAME is an unevaluated symbol rather than a
quoted symbol or other form; and second, NAME is lexically rather than
dynamically scoped:  Only references to it within BODY will work.  These
references may appear inside macro expansions, but not inside functions
called from BODY." nil 'macro)

(autoload 'return "cl-macs" "\
(return [RESULT]): return from the block named nil.
This is equivalent to `(return-from nil RESULT)'." nil 'macro)

(autoload 'return-from "cl-macs" "\
(return-from NAME [RESULT]): return from the block named NAME.
This jumps out to the innermost enclosing `(block NAME ...)' form,
returning RESULT from that form (or nil if RESULT is omitted).
This is compatible with Common Lisp, but note that `defun' and
`defmacro' do not create implicit blocks as they do in Common Lisp." nil 'macro)

(autoload 'loop "cl-macs" "\
(loop CLAUSE...): The Common Lisp `loop' macro.
Valid clauses are:
  for VAR from/upfrom/downfrom NUM to/upto/downto/above/below NUM by NUM,
  for VAR in LIST by FUNC, for VAR on LIST by FUNC, for VAR = INIT then EXPR,
  for VAR across ARRAY, repeat NUM, with VAR = INIT, while COND, until COND,
  always COND, never COND, thereis COND, collect EXPR into VAR,
  append EXPR into VAR, nconc EXPR into VAR, sum EXPR into VAR,
  count EXPR into VAR, maximize EXPR into VAR, minimize EXPR into VAR,
  if COND CLAUSE [and CLAUSE]... else CLAUSE [and CLAUSE...],
  unless COND CLAUSE [and CLAUSE]... else CLAUSE [and CLAUSE...],
  do EXPRS..., initially EXPRS..., finally EXPRS..., return EXPR,
  finally return EXPR, named NAME." nil 'macro)

(autoload 'do "cl-macs" "\
The Common Lisp `do' loop.
Format is: (do ((VAR INIT [STEP])...) (END-TEST [RESULT...]) BODY...)" nil 'macro)

(autoload 'do* "cl-macs" "\
The Common Lisp `do*' loop.
Format is: (do* ((VAR INIT [STEP])...) (END-TEST [RESULT...]) BODY...)" nil 'macro)

(autoload 'dolist "cl-macs" "\
(dolist (VAR LIST [RESULT]) BODY...): loop over a list.
Evaluate BODY with VAR bound to each `car' from LIST, in turn.
Then evaluate RESULT to get return value, default nil." nil 'macro)

(autoload 'dotimes "cl-macs" "\
(dotimes (VAR COUNT [RESULT]) BODY...): loop a certain number of times.
Evaluate BODY with VAR bound to successive integers from 0, inclusive,
to COUNT, exclusive.  Then evaluate RESULT to get return value, default
nil." nil 'macro)

(autoload 'do-symbols "cl-macs" "\
(dosymbols (VAR [OBARRAY [RESULT]]) BODY...): loop over all symbols.
Evaluate BODY with VAR bound to each interned symbol, or to each symbol
from OBARRAY." nil 'macro)

(autoload 'do-all-symbols "cl-macs" nil nil 'macro)

(autoload 'psetq "cl-macs" "\
(psetq SYM VAL SYM VAL ...): set SYMs to the values VALs in parallel.
This is like `setq', except that all VAL forms are evaluated (in order)
before assigning any symbols SYM to the corresponding values." nil 'macro)

(autoload 'progv "cl-macs" "\
(progv SYMBOLS VALUES BODY...): bind SYMBOLS to VALUES dynamically in BODY.
The forms SYMBOLS and VALUES are evaluated, and must evaluate to lists.
Each SYMBOL in the first list is bound to the corresponding VALUE in the
second list (or made unbound if VALUES is shorter than SYMBOLS); then the
BODY forms are executed and their result is returned.  This is much like
a `let' form, except that the list of symbols can be computed at run-time." nil 'macro)

(autoload 'flet "cl-macs" "\
(flet ((FUNC ARGLIST BODY...) ...) FORM...): make temporary function defns.
This is an analogue of `let' that operates on the function cell of FUNC
rather than its value cell.  The FORMs are evaluated with the specified
function definitions in place, then the definitions are undone (the FUNCs
go back to their previous definitions, or lack thereof)." nil 'macro)

(autoload 'labels "cl-macs" "\
(labels ((FUNC ARGLIST BODY...) ...) FORM...): make temporary func bindings.
This is like `flet', except the bindings are lexical instead of dynamic.
Unlike `flet', this macro is fully compliant with the Common Lisp standard." nil 'macro)

(autoload 'macrolet "cl-macs" "\
(macrolet ((NAME ARGLIST BODY...) ...) FORM...): make temporary macro defns.
This is like `flet', but for macros instead of functions." nil 'macro)

(autoload 'symbol-macrolet "cl-macs" "\
(symbol-macrolet ((NAME EXPANSION) ...) FORM...): make symbol macro defns.
Within the body FORMs, references to the variable NAME will be replaced
by EXPANSION, and (setq NAME ...) will act like (setf EXPANSION ...)." nil 'macro)

(autoload 'lexical-let "cl-macs" "\
(lexical-let BINDINGS BODY...): like `let', but lexically scoped.
The main visible difference is that lambdas inside BODY will create
lexical closures as in Common Lisp." nil 'macro)

(autoload 'lexical-let* "cl-macs" "\
(lexical-let* BINDINGS BODY...): like `let*', but lexically scoped.
The main visible difference is that lambdas inside BODY will create
lexical closures as in Common Lisp." nil 'macro)

(autoload 'multiple-value-bind "cl-macs" "\
(multiple-value-bind (SYM SYM...) FORM BODY): collect multiple return values.
FORM must return a list; the BODY is then executed with the first N elements
of this list bound (`let'-style) to each of the symbols SYM in turn.  This
is analogous to the Common Lisp `multiple-value-bind' macro, using lists to
simulate true multiple return values.  For compatibility, (values A B C) is
a synonym for (list A B C)." nil 'macro)

(autoload 'multiple-value-setq "cl-macs" "\
(multiple-value-setq (SYM SYM...) FORM): collect multiple return values.
FORM must return a list; the first N elements of this list are stored in
each of the symbols SYM in turn.  This is analogous to the Common Lisp
`multiple-value-setq' macro, using lists to simulate true multiple return
values.  For compatibility, (values A B C) is a synonym for (list A B C)." nil 'macro)

(autoload 'locally "cl-macs" nil nil 'macro)

(autoload 'the "cl-macs" nil nil 'macro)

(autoload 'declare "cl-macs" nil nil 'macro)

(autoload 'define-setf-method "cl-macs" "\
(define-setf-method NAME ARGLIST BODY...): define a `setf' method.
This method shows how to handle `setf's to places of the form (NAME ARGS...).
The argument forms ARGS are bound according to ARGLIST, as if NAME were
going to be expanded as a macro, then the BODY forms are executed and must
return a list of five elements: a temporary-variables list, a value-forms
list, a store-variables list (of length one), a store-form, and an access-
form.  See `defsetf' for a simpler way to define most setf-methods." nil 'macro)

(autoload 'defsetf "cl-macs" "\
(defsetf NAME FUNC): define a `setf' method.
This macro is an easy-to-use substitute for `define-setf-method' that works
well for simple place forms.  In the simple `defsetf' form, `setf's of
the form (setf (NAME ARGS...) VAL) are transformed to function or macro
calls of the form (FUNC ARGS... VAL).  Example: (defsetf aref aset).
Alternate form: (defsetf NAME ARGLIST (STORE) BODY...).
Here, the above `setf' call is expanded by binding the argument forms ARGS
according to ARGLIST, binding the value form VAL to STORE, then executing
BODY, which must return a Lisp form that does the necessary `setf' operation.
Actually, ARGLIST and STORE may be bound to temporary variables which are
introduced automatically to preserve proper execution order of the arguments.
Example: (defsetf nth (n x) (v) (list 'setcar (list 'nthcdr n x) v))." nil 'macro)

(autoload 'get-setf-method "cl-macs" "\
Return a list of five values describing the setf-method for PLACE.
PLACE may be any Lisp form which can appear as the PLACE argument to
a macro like `setf' or `incf'." nil nil)

(autoload 'setf "cl-macs" "\
(setf PLACE VAL PLACE VAL ...): set each PLACE to the value of its VAL.
This is a generalized version of `setq'; the PLACEs may be symbolic
references such as (car x) or (aref x i), as well as plain symbols.
For example, (setf (cadar x) y) is equivalent to (setcar (cdar x) y).
The return value is the last VAL in the list." nil 'macro)

(autoload 'psetf "cl-macs" "\
(psetf PLACE VAL PLACE VAL ...): set PLACEs to the values VALs in parallel.
This is like `setf', except that all VAL forms are evaluated (in order)
before assigning any PLACEs to the corresponding values." nil 'macro)

(autoload 'cl-do-pop "cl-macs" nil nil nil)

(autoload 'remf "cl-macs" "\
(remf PLACE TAG): remove TAG from property list PLACE.
PLACE may be a symbol, or any generalized variable allowed by `setf'.
The form returns true if TAG was found and removed, nil otherwise." nil 'macro)

(autoload 'shiftf "cl-macs" "\
(shiftf PLACE PLACE... VAL): shift left among PLACEs.
Example: (shiftf A B C) sets A to B, B to C, and returns the old A.
Each PLACE may be a symbol, or any generalized variable allowed by `setf'." nil 'macro)

(autoload 'rotatef "cl-macs" "\
(rotatef PLACE...): rotate left among PLACEs.
Example: (rotatef A B C) sets A to B, B to C, and C to A.  It returns nil.
Each PLACE may be a symbol, or any generalized variable allowed by `setf'." nil 'macro)

(autoload 'letf "cl-macs" "\
(letf ((PLACE VALUE) ...) BODY...): temporarily bind to PLACEs.
This is the analogue of `let', but with generalized variables (in the
sense of `setf') for the PLACEs.  Each PLACE is set to the corresponding
VALUE, then the BODY forms are executed.  On exit, either normally or
because of a `throw' or error, the PLACEs are set back to their original
values.  Note that this macro is *not* available in Common Lisp.
As a special case, if `(PLACE)' is used instead of `(PLACE VALUE)',
the PLACE is not modified before executing BODY." nil 'macro)

(autoload 'letf* "cl-macs" "\
(letf* ((PLACE VALUE) ...) BODY...): temporarily bind to PLACEs.
This is the analogue of `let*', but with generalized variables (in the
sense of `setf') for the PLACEs.  Each PLACE is set to the corresponding
VALUE, then the BODY forms are executed.  On exit, either normally or
because of a `throw' or error, the PLACEs are set back to their original
values.  Note that this macro is *not* available in Common Lisp.
As a special case, if `(PLACE)' is used instead of `(PLACE VALUE)',
the PLACE is not modified before executing BODY." nil 'macro)

(autoload 'callf "cl-macs" "\
(callf FUNC PLACE ARGS...): set PLACE to (FUNC PLACE ARGS...).
FUNC should be an unquoted function name.  PLACE may be a symbol,
or any generalized variable allowed by `setf'." nil 'macro)

(autoload 'callf2 "cl-macs" "\
(callf2 FUNC ARG1 PLACE ARGS...): set PLACE to (FUNC ARG1 PLACE ARGS...).
Like `callf', but PLACE is the second argument of FUNC, not the first." nil 'macro)

(autoload 'define-modify-macro "cl-macs" "\
(define-modify-macro NAME ARGLIST FUNC): define a `setf'-like modify macro.
If NAME is called, it combines its PLACE argument with the other arguments
from ARGLIST using FUNC: (define-modify-macro incf (&optional (n 1)) +)" nil 'macro)

(autoload 'defstruct "cl-macs" "\
(defstruct (NAME OPTIONS...) (SLOT SLOT-OPTS...)...): define a struct type.
This macro defines a new Lisp data type called NAME, which contains data
stored in SLOTs.  This defines a `make-NAME' constructor, a `copy-NAME'
copier, a `NAME-p' predicate, and setf-able `NAME-SLOT' accessors." nil 'macro)

(autoload 'cl-struct-setf-expander "cl-macs" nil nil nil)

(autoload 'deftype "cl-macs" "\
(deftype NAME ARGLIST BODY...): define NAME as a new data type.
The type name can then be used in `typecase', `check-type', etc." nil 'macro)

(autoload 'typep "cl-macs" "\
Check that OBJECT is of type TYPE.
TYPE is a Common Lisp-style type specifier." nil nil)

(autoload 'check-type "cl-macs" "\
Verify that PLACE is of type TYPE; signal a continuable error if not.
STRING is an optional description of the desired type." nil 'macro)

(autoload 'assert "cl-macs" "\
Verify that FORM returns non-nil; signal an error if not.
Second arg SHOW-ARGS means to include arguments of FORM in message.
Other args STRING and ARGS... are arguments to be passed to `error'.
They are not evaluated unless the assertion fails.  If STRING is
omitted, a default message listing FORM itself is used." nil 'macro)

(autoload 'ignore-errors "cl-macs" "\
Execute FORMS; if an error occurs, return nil.
Otherwise, return result of last FORM." nil 'macro)

(autoload 'ignore-file-errors "cl-macs" "\
Execute FORMS; if an error of type `file-error' occurs, return nil.
Otherwise, return result of last FORM." nil 'macro)

(autoload 'define-compiler-macro "cl-macs" "\
(define-compiler-macro FUNC ARGLIST BODY...): Define a compiler-only macro.
This is like `defmacro', but macro expansion occurs only if the call to
FUNC is compiled (i.e., not interpreted).  Compiler macros should be used
for optimizing the way calls to FUNC are compiled; the form returned by
BODY should do the same thing as a call to the normal function called
FUNC, though possibly more efficiently.  Note that, like regular macros,
compiler macros are expanded repeatedly until no further expansions are
possible.  Unlike regular macros, BODY can decide to \"punt\" and leave the
original function call alone by declaring an initial `&whole foo' parameter
and then returning foo." nil 'macro)

(autoload 'compiler-macroexpand "cl-macs" nil nil nil)

;;;***

;;;### (autoloads (config-value config-value-hash-table) "config" "lisp/config.el")

(autoload 'config-value-hash-table "config" "\
Return hash table of configuration parameters and their values." nil nil)

(autoload 'config-value "config" "\
Return the value of the configuration parameter CONFIG_SYMBOL." nil nil)

;;;***

;;;### (autoloads (Custom-make-dependencies) "cus-dep" "lisp/cus-dep.el")

(autoload 'Custom-make-dependencies "cus-dep" "\
Extract custom dependencies from .el files in SUBDIRS.
SUBDIRS is a list of directories.  If it is nil, the command-line
arguments are used.  If it is a string, only that directory is
processed.  This function is especially useful in batch mode.

Batch usage: xemacs -batch -l cus-dep.el -f Custom-make-dependencies DIRS" t nil)

;;;***

;;;### (autoloads (custom-migrate-custom-file customize-menu-create custom-menu-create custom-save-all customize-save-customized customize-browse custom-buffer-create-other-window custom-buffer-create customize-apropos-groups customize-apropos-faces customize-apropos-options customize-apropos customize-saved customize-customized customize-face-other-window customize-face customize-option-other-window customize-changed-options customize-variable customize-other-window customize customize-save-variable customize-set-variable customize-set-value) "cus-edit" "lisp/cus-edit.el")

(autoload 'customize-set-value "cus-edit" "\
Set VARIABLE to VALUE.  VALUE is a Lisp object.

If VARIABLE has a `variable-interactive' property, that is used as if
it were the arg to `interactive' (which see) to interactively read the value.

If VARIABLE has a `custom-type' property, it must be a widget and the
`:prompt-value' property of that widget will be used for reading the value.

If given a prefix (or a COMMENT argument), also prompt for a comment." t nil)

(autoload 'customize-set-variable "cus-edit" "\
Set the default for VARIABLE to VALUE.  VALUE is any Lisp object.

If VARIABLE has a `custom-set' property, that is used for setting
VARIABLE, otherwise `set-default' is used.

The `customized-value' property of the VARIABLE will be set to a list
with a quoted VALUE as its sole list member.

If VARIABLE has a `variable-interactive' property, that is used as if
it were the arg to `interactive' (which see) to interactively read the value.

If VARIABLE has a `custom-type' property, it must be a widget and the
`:prompt-value' property of that widget will be used for reading the value.

If given a prefix (or a COMMENT argument), also prompt for a comment." t nil)

(autoload 'customize-save-variable "cus-edit" "\
Set the default for VARIABLE to VALUE, and save it for future sessions.
If VARIABLE has a `custom-set' property, that is used for setting
VARIABLE, otherwise `set-default' is used.

The `customized-value' property of the VARIABLE will be set to a list
with a quoted VALUE as its sole list member.

If VARIABLE has a `variable-interactive' property, that is used as if
it were the arg to `interactive' (which see) to interactively read the value.

If VARIABLE has a `custom-type' property, it must be a widget and the
`:prompt-value' property of that widget will be used for reading the value.

If given a prefix (or a COMMENT argument), also prompt for a comment." t nil)

(autoload 'customize "cus-edit" "\
Select a customization buffer which you can use to set user options.
User options are structured into \"groups\".
The default group is `Emacs'." t nil)

(defalias 'customize-group 'customize)

(autoload 'customize-other-window "cus-edit" "\
Customize SYMBOL, which must be a customization group." t nil)

(defalias 'customize-group-other-window 'customize-other-window)

(defalias 'customize-option 'customize-variable)

(autoload 'customize-variable "cus-edit" "\
Customize SYMBOL, which must be a user option variable." t nil)

(autoload 'customize-changed-options "cus-edit" "\
Customize all user option variables whose default values changed recently.
This means, in other words, variables defined with a `:version' keyword." t nil)

(defalias 'customize-variable-other-window 'customize-option-other-window)

(autoload 'customize-option-other-window "cus-edit" "\
Customize SYMBOL, which must be a user option variable.
Show the buffer in another window, but don't select it." t nil)

(autoload 'customize-face "cus-edit" "\
Customize SYMBOL, which should be a face name or nil.
If SYMBOL is nil, customize all faces." t nil)

(autoload 'customize-face-other-window "cus-edit" "\
Show customization buffer for FACE in other window." t nil)

(autoload 'customize-customized "cus-edit" "\
Customize all user options set since the last save in this session." t nil)

(autoload 'customize-saved "cus-edit" "\
Customize all already saved user options." t nil)

(autoload 'customize-apropos "cus-edit" "\
Customize all user options matching REGEXP.
If ALL is `options', include only options.
If ALL is `faces', include only faces.
If ALL is `groups', include only groups.
If ALL is t (interactively, with prefix arg), include options which are not
user-settable, as well as faces and groups." t nil)

(autoload 'customize-apropos-options "cus-edit" "\
Customize all user options matching REGEXP.
With prefix arg, include options which are not user-settable." t nil)

(autoload 'customize-apropos-faces "cus-edit" "\
Customize all user faces matching REGEXP." t nil)

(autoload 'customize-apropos-groups "cus-edit" "\
Customize all user groups matching REGEXP." t nil)

(autoload 'custom-buffer-create "cus-edit" "\
Create a buffer containing OPTIONS.
Optional NAME is the name of the buffer.
OPTIONS should be an alist of the form ((SYMBOL WIDGET)...), where
SYMBOL is a customization option, and WIDGET is a widget for editing
that option." nil nil)

(autoload 'custom-buffer-create-other-window "cus-edit" "\
Create a buffer containing OPTIONS.
Optional NAME is the name of the buffer.
OPTIONS should be an alist of the form ((SYMBOL WIDGET)...), where
SYMBOL is a customization option, and WIDGET is a widget for editing
that option." nil nil)

(autoload 'customize-browse "cus-edit" "\
Create a tree browser for the customize hierarchy." t nil)

(autoload 'customize-save-customized "cus-edit" "\
Save all user options which have been set in this session." t nil)

(autoload 'custom-save-all "cus-edit" "\
Save all customizations in `custom-file'." nil nil)

(autoload 'custom-menu-create "cus-edit" "\
Create menu for customization group SYMBOL.
The menu is in a format applicable to `easy-menu-define'." nil nil)

(autoload 'customize-menu-create "cus-edit" "\
Return a customize menu for customization group SYMBOL.
If optional NAME is given, use that as the name of the menu.
Otherwise the menu will be named `Customize'.
The format is suitable for use with `easy-menu-define'." nil nil)

(autoload 'custom-migrate-custom-file "cus-edit" "\
Migrate custom file from home directory." nil nil)

;;;***

;;;### (autoloads (custom-reset-faces custom-theme-reset-faces custom-theme-face-value custom-theme-set-faces custom-set-faces custom-set-face-update-spec custom-declare-face) "cus-face" "lisp/cus-face.el")

(autoload 'custom-declare-face "cus-face" "\
Like `defface', but FACE is evaluated as a normal argument." nil nil)

(autoload 'custom-set-face-update-spec "cus-face" "\
Customize the FACE for display types matching DISPLAY, merging
  in the new items from PLIST." nil nil)

(autoload 'custom-set-faces "cus-face" "\
Initialize faces according to user preferences.
This asociates the setting with the USER theme.
The arguments should be a list where each entry has the form:

  (FACE SPEC [NOW [COMMENT]])

SPEC will be stored as the saved value for FACE.  If NOW is present
and non-nil, FACE will also be created according to SPEC.
COMMENT is a string comment about FACE.

See `defface' for the format of SPEC." nil nil)

(autoload 'custom-theme-set-faces "cus-face" "\
Initialize faces according to settings specified by args.
Records the settings as belonging to THEME.

See `custom-set-faces' for a description of the arguments ARGS." nil nil)

(autoload 'custom-theme-face-value "cus-face" "\
Return spec of FACE in THEME if the THEME modifies the
FACE.  Nil otherwise." nil nil)

(autoload 'custom-theme-reset-faces "cus-face" nil nil nil)

(autoload 'custom-reset-faces "cus-face" "\
Reset the value of the face to values previously defined.
Associate this setting with the 'user' theme.

ARGS is defined as for `custom-theme-reset-faces'." nil nil)

;;;***

;;;### (autoloads (make-custom-file-name) "cus-file" "lisp/cus-file.el")

(defconst custom-file-base "custom.el" "\
Base of file name for storing customization information.")

(defvar custom-file nil "\
File used for storing customization information.
If you change this from the default you need to
explicitly load that file for the settings to take effect.")

(autoload 'make-custom-file-name "cus-file" "\
Construct the default custom file name from the init file name.
If FORCE-NEW is non-nil, force post-migration location." nil nil)

;;;***

;;;### (autoloads (disassemble) "disass" "lisp/disass.el")

(autoload 'disassemble "disass" "\
Print disassembled code for OBJECT in (optional) BUFFER.
OBJECT can be a symbol defined as a function, or a function itself
\(a lambda expression or a compiled-function object).
If OBJECT is not already compiled, we compile it, but do not
redefine OBJECT if it is a symbol." t nil)

;;;***

;;;### (autoloads (standard-display-european standard-display-underline standard-display-graphic standard-display-g1 standard-display-ascii standard-display-default standard-display-8bit make-display-table describe-current-display-table) "disp-table" "lisp/disp-table.el")

(autoload 'describe-current-display-table "disp-table" "\
Describe the display table in use in the selected window and buffer." t nil)

(autoload 'make-display-table "disp-table" "\
Return a new, empty display table." nil nil)

(autoload 'standard-display-8bit "disp-table" "\
Display characters in the range L to H literally." nil nil)

(autoload 'standard-display-default "disp-table" "\
Display characters in the range L to H using the default notation." nil nil)

(autoload 'standard-display-ascii "disp-table" "\
Display character C using printable string S." nil nil)

(autoload 'standard-display-g1 "disp-table" "\
Display character C as character SC in the g1 character set.
This function assumes that your terminal uses the SO/SI characters;
it is meaningless for an X frame." nil nil)

(autoload 'standard-display-graphic "disp-table" "\
Display character C as character GC in graphics character set.
This function assumes VT100-compatible escapes; it is meaningless for an
X frame." nil nil)

(autoload 'standard-display-underline "disp-table" "\
Display character C as character UC plus underlining." nil nil)

(autoload 'standard-display-european "disp-table" "\
Toggle display of European characters encoded with ISO 8859.
When enabled, characters in the range of 160 to 255 display not
as octal escapes, but as accented characters.
With prefix argument, enable European character display iff arg is positive." t nil)

;;;***

;;;### (autoloads nil "easymenu" "lisp/easymenu.el")

;;;***

;;;### (autoloads (pop-tag-mark tags-apropos list-tags tags-query-replace tags-search tags-loop-continue next-file tag-complete-symbol find-tag-other-window find-tag find-tag-at-point visit-tags-table) "etags" "lisp/etags.el")

(autoload 'visit-tags-table "etags" "\
Tell tags commands to use tags table file FILE when all else fails.
FILE should be the name of a file created with the `etags' program.
A directory name is ok too; it means file TAGS in that directory." t nil)

(autoload 'find-tag-at-point "etags" "\
*Find tag whose name contains TAGNAME.
Identical to `find-tag' but does not prompt for tag when called interactively;
instead, uses tag around or before point." t nil)

(autoload 'find-tag "etags" "\
*Find tag whose name contains TAGNAME.
 Selects the buffer that the tag is contained in
and puts point at its definition.
 If TAGNAME is a null string, the expression in the buffer
around or before point is used as the tag name.
 If called interactively with a numeric argument, searches for the next tag
in the tag table that matches the tagname used in the previous find-tag.
 If second arg OTHER-WINDOW is non-nil, uses another window to display
the tag.

This version of this function supports multiple active tags tables,
and completion.

Variables of note:

  tag-table-alist		controls which tables apply to which buffers
  tags-file-name		a default tags table
  tags-build-completion-table   controls completion behavior
  buffer-tag-table		another way of specifying a buffer-local table
  make-tags-files-invisible	whether tags tables should be very hidden
  tag-mark-stack-max		how many tags-based hops to remember" t nil)

(autoload 'find-tag-other-window "etags" "\
*Find tag whose name contains TAGNAME, in another window.
 Selects the buffer that the tag is contained in in another window
and puts point at its definition.
 If TAGNAME is a null string, the expression in the buffer
around or before point is used as the tag name.
 If second arg NEXT is non-nil (interactively, with prefix arg),
searches for the next tag in the tag table
that matches the tagname used in the previous find-tag.

This version of this function supports multiple active tags tables,
and completion.

Variables of note:

  tag-table-alist		controls which tables apply to which buffers
  tags-file-name		a default tags table
  tags-build-completion-table   controls completion behavior
  buffer-tag-table		another way of specifying a buffer-local table
  make-tags-files-invisible	whether tags tables should be very hidden
  tag-mark-stack-max		how many tags-based hops to remember" t nil)

(autoload 'tag-complete-symbol "etags" "\
The function used to do tags-completion (using 'tag-completion-predicate)." t nil)

(autoload 'next-file "etags" "\
Select next file among files in current tag table(s).

A first argument of t (prefix arg, if interactive) initializes to the
beginning of the list of files in the (first) tags table.  If the argument
is neither nil nor t, it is evalled to initialize the list of files.

Non-nil second argument NOVISIT means use a temporary buffer
to save time and avoid uninteresting warnings.

Value is nil if the file was already visited;
if the file was newly read in, the value is the filename." t nil)

(autoload 'tags-loop-continue "etags" "\
Continue last \\[tags-search] or \\[tags-query-replace] command.
Used noninteractively with non-nil argument to begin such a command (the
argument is passed to `next-file', which see).
Two variables control the processing we do on each file:
the value of `tags-loop-scan' is a form to be executed on each file
to see if it is interesting (it returns non-nil if so)
and `tags-loop-operate' is a form to execute to operate on an interesting file
If the latter returns non-nil, we exit; otherwise we scan the next file." t nil)

(autoload 'tags-search "etags" "\
Search through all files listed in tags table for match for REGEXP.
Stops when a match is found.
To continue searching for next match, use command \\[tags-loop-continue].

See documentation of variable `tag-table-alist'." t nil)

(autoload 'tags-query-replace "etags" "\
Query-replace-regexp FROM with TO through all files listed in tags table.
Third arg DELIMITED (prefix arg) means replace only word-delimited matches.
If you exit (\\[keyboard-quit] or ESC), you can resume the query-replace
with the command \\[tags-loop-continue].

See documentation of variable `tag-table-alist'." t nil)

(autoload 'list-tags "etags" "\
Display list of tags in FILE." t nil)

(autoload 'tags-apropos "etags" "\
Display list of all tags in tag table REGEXP matches." t nil)
(define-key esc-map "*" 'pop-tag-mark)

(autoload 'pop-tag-mark "etags" "\
Go to last tag position.
`find-tag' maintains a mark-stack seperate from the \\[set-mark-command] mark-stack.
This function pops (and moves to) the tag at the top of this stack." t nil)

;;;***

;;;### (autoloads (finder-by-keyword finder-commentary) "finder" "lisp/finder.el")

(autoload 'finder-commentary "finder" "\
Display FILE's commentary section.
FILE should be in a form suitable for passing to `locate-library'." t nil)

(autoload 'finder-by-keyword "finder" "\
Find packages matching a given keyword." t nil)

;;;***

;;;### (autoloads (font-lock-set-defaults-1 font-lock-fontify-buffer turn-off-font-lock turn-on-font-lock font-lock-mode) "font-lock" "lisp/font-lock.el")

(defcustom font-lock-auto-fontify t "*Whether font-lock should automatically fontify files as they're loaded.\nThis will only happen if font-lock has fontifying keywords for the major\nmode of the file.  You can get finer-grained control over auto-fontification\nby using this variable in combination with `font-lock-mode-enable-list' or\n`font-lock-mode-disable-list'." :type 'boolean :group 'font-lock)

(defcustom font-lock-mode-enable-list nil "*List of modes to auto-fontify, if `font-lock-auto-fontify' is nil." :type '(repeat (symbol :tag "Mode")) :group 'font-lock)

(defcustom font-lock-mode-disable-list nil "*List of modes not to auto-fontify, if `font-lock-auto-fontify' is t." :type '(repeat (symbol :tag "Mode")) :group 'font-lock)

(defcustom font-lock-use-colors '(color) "*Specification for when Font Lock will set up color defaults.\nNormally this should be '(color), meaning that Font Lock will set up\ncolor defaults that are only used on color displays.  Set this to nil\nif you don't want Font Lock to set up color defaults at all.  This\nshould be one of\n\n-- a list of valid tags, meaning that the color defaults will be used\n   when all of the tags apply. (e.g. '(color x))\n-- a list whose first element is 'or and whose remaining elements are\n   lists of valid tags, meaning that the defaults will be used when\n   any of the tag lists apply.\n-- nil, meaning that the defaults should not be set up at all.\n\n(If you specify face values in your init file, they will override any\nthat Font Lock specifies, regardless of whether you specify the face\nvalues before or after loading Font Lock.)\n\nSee also `font-lock-use-fonts'.  If you want more control over the faces\nused for fontification, see the documentation of `font-lock-mode' for\nhow to do it." :type 'sexp :group 'font-lock)

(defcustom font-lock-use-fonts '(or (mono) (grayscale)) "*Specification for when Font Lock will set up non-color defaults.\n\nNormally this should be '(or (mono) (grayscale)), meaning that Font\nLock will set up non-color defaults that are only used on either mono\nor grayscale displays.  Set this to nil if you don't want Font Lock to\nset up non-color defaults at all.  This should be one of\n\n-- a list of valid tags, meaning that the non-color defaults will be used\n   when all of the tags apply. (e.g. '(grayscale x))\n-- a list whose first element is 'or and whose remaining elements are\n   lists of valid tags, meaning that the defaults will be used when\n   any of the tag lists apply.\n-- nil, meaning that the defaults should not be set up at all.\n\n(If you specify face values in your init file, they will override any\nthat Font Lock specifies, regardless of whether you specify the face\nvalues before or after loading Font Lock.)\n\nSee also `font-lock-use-colors'.  If you want more control over the faces\nused for fontification, see the documentation of `font-lock-mode' for\nhow to do it." :type 'sexp :group 'font-lock)

(defcustom font-lock-maximum-decoration t "*If non-nil, the maximum decoration level for fontifying.\nIf nil, use the minimum decoration (equivalent to level 0).\nIf t, use the maximum decoration available.\nIf a number, use that level of decoration (or if not available the maximum).\nIf a list, each element should be a cons pair of the form (MAJOR-MODE . LEVEL),\nwhere MAJOR-MODE is a symbol or t (meaning the default).  For example:\n ((c++-mode . 2) (c-mode . t) (t . 1))\nmeans use level 2 decoration for buffers in `c++-mode', the maximum decoration\navailable for buffers in `c-mode', and level 1 decoration otherwise." :type '(choice (const :tag "default" nil) (const :tag "maximum" t) (integer :tag "level" 1) (repeat :menu-tag "mode specific" :tag "mode specific" :value ((t . t)) (cons :tag "Instance" (radio :tag "Mode" (const :tag "all" t) (symbol :tag "name")) (radio :tag "Decoration" (const :tag "default" nil) (const :tag "maximum" t) (integer :tag "level" 1))))) :group 'font-lock)

(define-obsolete-variable-alias 'font-lock-use-maximal-decoration 'font-lock-maximum-decoration)

(defcustom font-lock-maximum-size (* 250 1024) "*If non-nil, the maximum size for buffers for fontifying.\nOnly buffers less than this can be fontified when Font Lock mode is turned on.\nIf nil, means size is irrelevant.\nIf a list, each element should be a cons pair of the form (MAJOR-MODE . SIZE),\nwhere MAJOR-MODE is a symbol or t (meaning the default).  For example:\n ((c++-mode . 256000) (c-mode . 256000) (rmail-mode . 1048576))\nmeans that the maximum size is 250K for buffers in `c++-mode' or `c-mode', one\nmegabyte for buffers in `rmail-mode', and size is irrelevant otherwise." :type '(choice (const :tag "none" nil) (integer :tag "size") (repeat :menu-tag "mode specific" :tag "mode specific" :value ((t)) (cons :tag "Instance" (radio :tag "Mode" (const :tag "all" t) (symbol :tag "name")) (radio :tag "Size" (const :tag "none" nil) (integer :tag "size"))))) :group 'font-lock)

(defcustom font-lock-fontify-string-delimiters nil "*If non-nil, apply font-lock-string-face to string delimiters as well as\nstring text when fontifying." :type 'boolean :group 'font-lock)

(defvar font-lock-keywords nil "\
A list defining the keywords for `font-lock-mode' to highlight.

 FONT-LOCK-KEYWORDS := List of FONT-LOCK-FORM's.

 FONT-LOCK-FORM     :== MATCHER
                      | (MATCHER . MATCH)
                      | (MATCHER . FACE-FORM)
                      | (MATCHER . HIGHLIGHT)
                      | (MATCHER HIGHLIGHT ...)
                      | (eval . FORM)

 MATCHER            :== A string containing a regexp.
                      | A variable containing a regexp to search for.
                      | A function to call to make the search.
                        It is called with one arg, the limit of the search,
                        and should leave MATCH results in the XEmacs global
                        match data.

 MATCH              :== An integer match subexpression number from MATCHER.

 FACE-FORM           :== The symbol naming a defined face.
                      | Expression whos value is the face name to use.  If you
                        want FACE-FORM to be a symbol that evaluates to a face,
                        use a form like \"(progn sym)\".

 HIGHLIGHT          :== MATCH-HIGHLIGHT
                      | MATCH-ANCHORED

 FORM               :== Expression returning a FONT-LOCK-FORM, evaluated when
                        the FONT-LOCK-FORM is first used in a buffer.  This
                        feature can be used to provide a FONT-LOCK-FORM that
                        can only be generated when Font Lock mode is actually
                        turned on.

 MATCH-HIGHLIGHT    :== (MATCH FACE-FORM OVERRIDE LAXMATCH)

 OVERRIDE           :== t        - overwrite existing fontification
                      | 'keep    - only parts not already fontified are
                                   highlighted.
                      | 'prepend - merge faces, this fontification has
                                   precedence over existing
                      | 'append  - merge faces, existing fontification has
                                   precedence over
                                   this face.

 LAXMATCH           :== If non-nil, no error is signalled if there is no MATCH
                        in MATCHER.

 MATCH-ANCHORED     :== (ANCHOR-MATCHER PRE-MATCH-FORM \\
                                          POST-MATCH-FORM MATCH-HIGHLIGHT ...)

 ANCHOR-MATCHER     :== Like a MATCHER, except that the limit of the search
                        defaults to the end of the line after PRE-MATCH-FORM
                        is evaluated.  However, if PRE-MATCH-FORM returns a
                        position greater than the end of the line, that
                        position is used as the limit of the search.  It is
                        generally a bad idea to return a position greater than
                        the end of the line, i.e., cause the ANCHOR-MATCHER
                        search to span lines.

 PRE-MATCH-FORM     :== Evaluated before the ANCHOR-MATCHER is used, therefore
                        can be used to initialize before, ANCHOR-MATCHER is
                        used.  Typically, PRE-MATCH-FORM is used to move to
                        some position relative to the original MATCHER, before
                        starting with the ANCHOR-MATCHER.

 POST-MATCH-FORM    :== Like PRE-MATCH-FORM, but used to clean up after the
                        ANCHOR-MATCHER.  It might be used to move, before
                        resuming with MATCH-ANCHORED's parent's MATCHER.

For example, an element of the first form highlights (if not already highlighted):

  \"\\\\\\=<foo\\\\\\=>\"                    Discrete occurrences of \"foo\" in the value
                                 of the variable `font-lock-keyword-face'.

  (\"fu\\\\(bar\\\\)\" . 1)            Substring \"bar\" within all occurrences of
                                 \"fubar\" in the value of
                                 `font-lock-keyword-face'.

  (\"fubar\" . fubar-face)         Occurrences of \"fubar\" in the value of
                                 `fubar-face'.

  (\"foo\\\\|bar\" 0 foo-bar-face t) Occurrences of either \"foo\" or \"bar\" in the
                                 value of `foo-bar-face', even if already
                                 highlighted.

  (fubar-match 1 fubar-face)     The first subexpression within all
                                 occurrences of whatever the function
                                 `fubar-match' finds and matches in the value
                                 of `fubar-face'.

  (\"\\\\\\=<anchor\\\\\\=>\" (0 anchor-face) (\"\\\\\\=<item\\\\\\=>\" nil nil (0 item-face)))
   -------------- ---------------  ------------ --- --- -------------
       |            |               |            |   |          |
   MATCHER          |         ANCHOR-MATCHER     |   +------+ MATCH-HIGHLIGHT
             MATCH-HIGHLIGHT                 PRE-MATCH-FORM |
                                                           POST-MATCH-FORM

  Discrete occurrences of \"anchor\" in the value of `anchor-face', and
  subsequent discrete occurrences of \"item\" (on the same line) in the value
  of `item-face'.  (Here PRE-MATCH-FORM and POST-MATCH-FORM are nil.
  Therefore \"item\" is initially searched for starting from the end of the
  match of \"anchor\", and searching for subsequent instance of \"anchor\"
  resumes from where searching for \"item\" concluded.)

For highlighting single items, typically only MATCH-HIGHLIGHT is required.
However, if an item or (typically) several items are to be highlighted
following the instance of another item (the anchor) then MATCH-ANCHORED may be
required.

These regular expressions should not match text which spans lines.  While
\\[font-lock-fontify-buffer] handles multi-line patterns correctly, updating when you
edit the buffer does not, since it considers text one line at a time.

Be very careful composing regexps for this list; the wrong pattern can
dramatically slow things down!
")

(make-variable-buffer-local 'font-lock-keywords)

(defvar font-lock-syntactic-keywords nil "\
A list of the syntactic keywords to highlight.
Can be the list or the name of a function or variable whose value is the list.
See `font-lock-keywords' for a description of the form of this list;
the differences are listed below.  MATCH-HIGHLIGHT should be of the form:

 (MATCH SYNTAX OVERRIDE LAXMATCH)

where SYNTAX can be of the form (SYNTAX-CODE . MATCHING-CHAR), the name of a
syntax table, or an expression whose value is such a form or a syntax table.
OVERRIDE cannot be `prepend' or `append'.

For example, an element of the form highlights syntactically:

 (\"\\\\$\\\\(#\\\\)\" 1 (1 . nil))

 a hash character when following a dollar character, with a SYNTAX-CODE of
 1 (meaning punctuation syntax).  Assuming that the buffer syntax table does
 specify hash characters to have comment start syntax, the element will only
 highlight hash characters that do not follow dollar characters as comments
 syntactically.

 (\"\\\\('\\\\).\\\\('\\\\)\"
  (1 (7 . ?'))
  (2 (7 . ?')))

 both single quotes which surround a single character, with a SYNTAX-CODE of
 7 (meaning string quote syntax) and a MATCHING-CHAR of a single quote (meaning
 a single quote matches a single quote).  Assuming that the buffer syntax table
 does not specify single quotes to have quote syntax, the element will only
 highlight single quotes of the form 'c' as strings syntactically.
 Other forms, such as foo'bar or 'fubar', will not be highlighted as strings.

This is normally set via `font-lock-defaults'.")

(make-variable-buffer-local 'font-lock-syntactic-keywords)

(defcustom font-lock-mode nil "Non nil means `font-lock-mode' is on" :group 'font-lock :type 'boolean :initialize 'custom-initialize-default :require 'font-lock :set (function (lambda (var val) (font-lock-mode (or val 0)))))

(defvar font-lock-mode-hook nil "\
Function or functions to run on entry to font-lock-mode.")

(autoload 'font-lock-mode "font-lock" "\
Toggle Font Lock Mode.
With arg, turn font-lock mode on if and only if arg is positive.

When Font Lock mode is enabled, text is fontified as you type it:

 - Comments are displayed in `font-lock-comment-face';
 - Strings are displayed in `font-lock-string-face';
 - Documentation strings (in Lisp-like languages) are displayed in
   `font-lock-doc-string-face';
 - Language keywords (\"reserved words\") are displayed in
   `font-lock-keyword-face';
 - Function names in their defining form are displayed in
   `font-lock-function-name-face';
 - Variable names in their defining form are displayed in
   `font-lock-variable-name-face';
 - Type names are displayed in `font-lock-type-face';
 - References appearing in help files and the like are displayed
   in `font-lock-reference-face';
 - Preprocessor declarations are displayed in
  `font-lock-preprocessor-face';

   and

 - Certain other expressions are displayed in other faces according
   to the value of the variable `font-lock-keywords'.

Where modes support different levels of fontification, you can use the variable
`font-lock-maximum-decoration' to specify which level you generally prefer.
When you turn Font Lock mode on/off the buffer is fontified/defontified, though
fontification occurs only if the buffer is less than `font-lock-maximum-size'.
To fontify a buffer without turning on Font Lock mode, and regardless of buffer
size, you can use \\[font-lock-fontify-buffer].

See the variable `font-lock-keywords' for customization." t nil)

(autoload 'turn-on-font-lock "font-lock" "\
Unconditionally turn on Font Lock mode." t nil)

(autoload 'turn-off-font-lock "font-lock" "\
Unconditionally turn off Font Lock mode." t nil)

(autoload 'font-lock-fontify-buffer "font-lock" "\
Fontify the current buffer the way `font-lock-mode' would.
See `font-lock-mode' for details.

This can take a while for large buffers." t nil)

(autoload 'font-lock-set-defaults-1 "font-lock" nil nil nil)

(add-minor-mode 'font-lock-mode " Font")

;;;***

;;;### (autoloads (font-menu-weight-constructor font-menu-size-constructor font-menu-family-constructor reset-device-font-menus) "font-menu" "lisp/font-menu.el")

(defcustom font-menu-ignore-scaled-fonts nil "*If non-nil, then the font menu will try to show only bitmap fonts." :type 'boolean :group 'font-menu)

(defcustom font-menu-this-frame-only-p nil "*If non-nil, then changing the default font from the font menu will only\naffect one frame instead of all frames." :type 'boolean :group 'font-menu)

(fset 'install-font-menus 'reset-device-font-menus)

(autoload 'reset-device-font-menus "font-menu" "\
Generates the `Font', `Size', and `Weight' submenus for the Options menu.
This is run the first time that a font-menu is needed for each device.
If you don't like the lazy invocation of this function, you can add it to
`create-device-hook' and that will make the font menus respond more quickly
when they are selected for the first time.  If you add fonts to your system,
or if you change your font path, you can call this to re-initialize the menus." nil nil)

(autoload 'font-menu-family-constructor "font-menu" nil nil nil)

(autoload 'font-menu-size-constructor "font-menu" nil nil nil)

(autoload 'font-menu-weight-constructor "font-menu" nil nil nil)

;;;***

;;;### (autoloads (x-font-build-cache font-default-size-for-device font-default-encoding-for-device font-default-registry-for-device font-default-family-for-device font-default-object-for-device font-default-font-for-device font-create-object) "font" "lisp/font.el")

(autoload 'font-create-object "font" "\
Return a font descriptor object for FONTNAME, appropriate for DEVICE." nil nil)

(autoload 'font-default-font-for-device "font" nil nil nil)

(autoload 'font-default-object-for-device "font" nil nil nil)

(autoload 'font-default-family-for-device "font" nil nil nil)

(autoload 'font-default-registry-for-device "font" nil nil nil)

(autoload 'font-default-encoding-for-device "font" nil nil nil)

(autoload 'font-default-size-for-device "font" nil nil nil)

(autoload 'x-font-build-cache "font" nil nil nil)

;;;***

;;;### (autoloads (gnuserv-start gnuserv-running-p) "gnuserv" "lisp/gnuserv.el")

(defcustom gnuserv-mode-line-string " Server" "*String to display in the modeline when Gnuserv is active.\nSet this to nil if you don't want a modeline indicator." :type '(choice string (const :tag "none" nil)) :group 'gnuserv)

(defcustom gnuserv-frame nil "*The frame to be used to display all edited files.\nIf nil, then a new frame is created for each file edited.\nIf t, then the currently selected frame will be used.\nIf a function, then this will be called with a symbol `x' or `tty' as the\nonly argument, and its return value will be interpreted as above." :tag "Gnuserv Frame" :type '(radio (const :tag "Create new frame each time" nil) (const :tag "Use selected frame" t) (function-item :tag "Use main Emacs frame" gnuserv-main-frame-function) (function-item :tag "Use visible frame, otherwise create new" gnuserv-visible-frame-function) (function-item :tag "Create special Gnuserv frame and use it" gnuserv-special-frame-function) (function :tag "Other")) :group 'gnuserv :group 'frames)

(autoload 'gnuserv-running-p "gnuserv" "\
Return non-nil if a gnuserv process is running from this XEmacs session." nil nil)

(autoload 'gnuserv-start "gnuserv" "\
Allow this Emacs process to be a server for client processes.
This starts a gnuserv communications subprocess through which
client \"editors\" (gnuclient and gnudoit) can send editing commands to
this Emacs job.  See the gnuserv(1) manual page for more details.

Prefix arg means just kill any existing server communications subprocess." t nil)

;;;***

;;;### (autoloads (gtk-reset-device-font-menus) "gtk-font-menu" "lisp/gtk-font-menu.el")

(autoload 'gtk-reset-device-font-menus "gtk-font-menu" "\
Generates the `Font', `Size', and `Weight' submenus for the Options menu.
This is run the first time that a font-menu is needed for each device.
If you don't like the lazy invocation of this function, you can add it to
`create-device-hook' and that will make the font menus respond more quickly
when they are selected for the first time.  If you add fonts to your system, 
or if you change your font path, you can call this to re-initialize the menus." nil nil)

(defun* gtk-font-menu-font-data (face dcache) (defvar gtk-font-regexp) (defvar gtk-font-regexp-foundry-and-family) (let* ((case-fold-search t) (domain (if font-menu-this-frame-only-p (selected-frame) (selected-device))) (name (font-instance-name (face-font-instance face domain))) (truename (font-instance-truename (face-font-instance face domain (if (featurep 'mule) 'ascii)))) family size weight entry slant) (when (string-match gtk-font-regexp-foundry-and-family name) (setq family (capitalize (match-string 1 name))) (setq entry (vassoc family (aref dcache 0)))) (when (and (null entry) (string-match gtk-font-regexp-foundry-and-family truename)) (setq family (capitalize (match-string 1 truename))) (setq entry (vassoc family (aref dcache 0)))) (when (null entry) (return-from gtk-font-menu-font-data (make-vector 5 nil))) (when (string-match gtk-font-regexp name) (setq weight (capitalize (match-string 1 name))) (setq size (string-to-int (match-string 6 name)))) (when (string-match gtk-font-regexp truename) (when (not (member weight (aref entry 1))) (setq weight (capitalize (match-string 1 truename)))) (when (not (member size (aref entry 2))) (setq size (string-to-int (match-string 6 truename)))) (setq slant (capitalize (match-string 2 truename)))) (vector entry family size weight slant)))

;;;***

;;;### (autoloads nil "help-macro" "lisp/help-macro.el")

(defcustom three-step-help t "*Non-nil means give more info about Help command in three steps.\nThe three steps are simple prompt, prompt with all options,\nand window listing and describing the options.\nA value of nil means skip the middle step, so that\n\\[help-command] \\[help-command] gives the window that lists the options." :type 'boolean :group 'help-appearance)

;;;***

;;;### (autoloads (hyper-apropos-popup-menu hyper-apropos-set-variable hyper-set-variable hyper-apropos-read-variable-symbol hyper-describe-function hyper-where-is hyper-describe-variable hyper-describe-face hyper-describe-key-briefly hyper-describe-key hyper-apropos) "hyper-apropos" "lisp/hyper-apropos.el")

(autoload 'hyper-apropos "hyper-apropos" "\
Display lists of functions and variables matching REGEXP
in buffer \"*Hyper Apropos*\".  If optional prefix arg is given, then the
value of `hyper-apropos-programming-apropos' is toggled for this search.
See also `hyper-apropos-mode'." t nil)

(autoload 'hyper-describe-key "hyper-apropos" nil t nil)

(autoload 'hyper-describe-key-briefly "hyper-apropos" nil t nil)

(autoload 'hyper-describe-face "hyper-apropos" "\
Describe face..
See also `hyper-apropos' and `hyper-describe-function'." t nil)

(autoload 'hyper-describe-variable "hyper-apropos" "\
Hypertext drop-in replacement for `describe-variable'.
See also `hyper-apropos' and `hyper-describe-function'." t nil)

(autoload 'hyper-where-is "hyper-apropos" "\
Print message listing key sequences that invoke specified command." t nil)

(autoload 'hyper-describe-function "hyper-apropos" "\
Hypertext replacement for `describe-function'.  Unlike `describe-function'
in that the symbol under the cursor is the default if it is a function.
See also `hyper-apropos' and `hyper-describe-variable'." t nil)

(autoload 'hyper-apropos-read-variable-symbol "hyper-apropos" "\
Hypertext drop-in replacement for `describe-variable'.
See also `hyper-apropos' and `hyper-describe-function'." nil nil)

(define-obsolete-function-alias 'hypropos-read-variable-symbol 'hyper-apropos-read-variable-symbol)

(define-obsolete-function-alias 'hypropos-get-doc 'hyper-apropos-get-doc)

(autoload 'hyper-set-variable "hyper-apropos" nil t nil)

(autoload 'hyper-apropos-set-variable "hyper-apropos" "\
Interactively set the variable on the current line." t nil)

(define-obsolete-function-alias 'hypropos-set-variable 'hyper-apropos-set-variable)

(autoload 'hyper-apropos-popup-menu "hyper-apropos" nil t nil)

(define-obsolete-function-alias 'hypropos-popup-menu 'hyper-apropos-popup-menu)

;;;***

;;;### (autoloads (Info-elisp-ref Info-emacs-key Info-goto-emacs-key-command-node Info-goto-emacs-command-node Info-emacs-command Info-search Info-visit-file Info-goto-node Info-batch-rebuild-dir Info-find-node Info-query info) "info" "lisp/info.el")

(defvar Info-directory-list nil "\
List of directories to search for Info documentation files.

The first directory in this list, the \"dir\" file there will become
the (dir)Top node of the Info documentation tree.

Note: DO NOT use the `customize' interface to change the value of this
variable.  Its value is created dynamically on each startup, depending
on XEmacs packages installed on the system.  If you want to change the
search path, make the needed modifications on the variable's value
from .emacs.  For instance:

    (setq Info-directory-list (cons \"~/info\" Info-directory-list))")

(autoload 'info "info" "\
Enter Info, the documentation browser.
Optional argument FILE specifies the file to examine;
the default is the top-level directory of Info.

In interactive use, a prefix argument directs this command
to read a file name from the minibuffer." t nil)

(autoload 'Info-query "info" "\
Enter Info, the documentation browser.  Prompt for name of Info file." t nil)

(autoload 'Info-find-node "info" "\
Go to an info node specified as separate FILENAME and NODENAME.
Look for a plausible filename, or if not found then look for URL's and
dispatch to the appropriate fn.  NO-GOING-BACK is non-nil if
recovering from an error in this function; it says do not attempt
further (recursive) error recovery.  TRYFILE is ??" nil nil)

(autoload 'Info-batch-rebuild-dir "info" "\
(Re)build `dir' files in the directories remaining on the command line.
Use this from the command line, with `-batch', it won't work in an
interactive XEmacs.

Each file is processed even if an error occurred previously. For example,
invoke \"xemacs -batch -f Info-batch-rebuild-dir /usr/local/info\"." nil nil)

(autoload 'Info-goto-node "info" "\
Go to info node named NAME.  Give just NODENAME or (FILENAME)NODENAME.
Actually, the following interpretations of NAME are tried in order:
    (FILENAME)NODENAME
    (FILENAME)     (using Top node)
    NODENAME       (in current file)
    TAGNAME        (see below)
    FILENAME       (using Top node)
where TAGNAME is a string that appears in quotes: \"TAGNAME\", in an
annotation for any node of any file.  (See `a' and `x' commands.)" t nil)

(autoload 'Info-visit-file "info" "\
Directly visit an info file." t nil)

(autoload 'Info-search "info" "\
Search for REGEXP, starting from point, and select node it's found in." t nil)

(autoload 'Info-emacs-command "info" "\
Look up an Emacs command in the Emacs manual in the Info system.
This command is designed to be used whether you are already in Info or not." t nil)

(autoload 'Info-goto-emacs-command-node "info" "\
Look up an Emacs command in the Emacs manual in the Info system.
This command is designed to be used whether you are already in Info or not." t nil)

(autoload 'Info-goto-emacs-key-command-node "info" "\
Look up an Emacs key sequence in the Emacs manual in the Info system.
This command is designed to be used whether you are already in Info or not." t nil)

(autoload 'Info-emacs-key "info" "\
Look up an Emacs key sequence in the Emacs manual in the Info system.
This command is designed to be used whether you are already in Info or not." t nil)

(autoload 'Info-elisp-ref "info" "\
Look up an Emacs Lisp function in the Elisp manual in the Info system.
This command is designed to be used whether you are already in Info or not." t nil)

;;;***

;;;### (autoloads nil "itimer-autosave" "lisp/itimer-autosave.el")

;;;***

;;;### (autoloads nil "loaddefs" "lisp/loaddefs.el")

;;;***

;;;### (autoloads nil "loadhist" "lisp/loadhist.el")

;;;***

;;;### (autoloads (mswindows-reset-device-font-menus) "msw-font-menu" "lisp/msw-font-menu.el")

(autoload 'mswindows-reset-device-font-menus "msw-font-menu" "\
Generates the `Font', `Size', and `Weight' submenus for the Options menu.
This is run the first time that a font-menu is needed for each device.
If you don't like the lazy invocation of this function, you can add it to
`create-device-hook' and that will make the font menus respond more quickly
when they are selected for the first time.  If you add fonts to your system, 
or if you change your font path, you can call this to re-initialize the menus." nil nil)

(defun* mswindows-font-menu-font-data (face dcache) (let* ((case-fold-search t) (domain (if font-menu-this-frame-only-p (selected-frame) (selected-device))) (name (font-instance-name (face-font-instance face domain))) (truename (font-instance-truename (face-font-instance face domain (if (featurep 'mule) 'ascii)))) family size weight entry slant) (when (string-match mswindows-font-regexp name) (setq family (match-string 1 name)) (setq entry (vassoc family (aref dcache 0)))) (when (and (null entry) (string-match mswindows-font-regexp truename)) (setq family (match-string 1 truename)) (setq entry (vassoc family (aref dcache 0)))) (when (null entry) (return-from mswindows-font-menu-font-data (make-vector 5 nil))) (when (string-match mswindows-font-regexp name) (setq weight (match-string 2 name)) (setq size (string-to-int (or (match-string 4 name) "0")))) (when (string-match mswindows-font-regexp truename) (when (not (member weight (aref entry 1))) (setq weight (match-string 2 truename))) (when (not (member size (aref entry 2))) (setq size (string-to-int (or (match-string 4 truename) "0")))) (setq slant (match-string 5 truename))) (vector entry family size weight slant)))

;;;***

;;;### (autoloads (mwheel-install) "mwheel" "lisp/mwheel.el")

(autoload 'mwheel-install "mwheel" "\
Enable mouse wheel support." t nil)

;;;***

;;;### (autoloads (package-admin-add-binary-package) "package-admin" "lisp/package-admin.el")

(autoload 'package-admin-add-binary-package "package-admin" "\
Install a pre-bytecompiled XEmacs package into package hierarchy." t nil)

;;;***

;;;### (autoloads (package-get-package-provider package-get package-get-list-packages-where package-get-info package-get-dependencies package-get-all package-get-update-all package-get-delete-package package-get-save-base package-get-update-base-from-buffer package-get-update-base package-get-update-base-entry package-get-require-base) "package-get" "lisp/package-get.el")

(defvar package-get-base nil "\
List of packages that are installed at this site.
For each element in the alist,  car is the package name and the cdr is
a plist containing information about the package.   Typical fields
kept in the plist are:

version		- version of this package
provides	- list of symbols provided
requires	- list of symbols that are required.
		  These in turn are provided by other packages.
filename	- name of the file.
size		- size of the file (aka the bundled package)
md5sum		- computed md5 checksum
description	- What this package is for.
type		- Whether this is a 'binary (default) or 'single file package

More fields may be added as needed.  An example:

'(
 (name
  (version \"<version 2>\"
   file \"filename\"
   description \"what this package is about.\"
   provides (<list>)
   requires (<list>)
   size <integer-bytes>
   md5sum \"<checksum\"
   type single
   )
  (version \"<version 1>\"
   file \"filename\"
   description \"what this package is about.\"
   provides (<list>)
   requires (<list>)
   size <integer-bytes>
   md5sum \"<checksum\"
   type single
   )
   ...
   ))

For version information, it is assumed things are listed in most
recent to least recent -- in other words, the version names don't have to
be lexically ordered.  It is debatable if it makes sense to have more than
one version of a package available.")

(defcustom package-get-package-index-file-location (car (split-path (or (getenv "EMACSPACKAGEPATH") user-init-directory))) "*The directory where the package-index file can be found." :type 'directory :group 'package-get)

(defcustom package-get-install-to-user-init-directory nil "*If non-nil install packages under `user-init-directory'." :type 'boolean :group 'package-get)

(defcustom package-get-download-sites '(("US (Main XEmacs Site)" "ftp.xemacs.org" "pub/xemacs/packages") ("Australia (aarnet.edu.au)" "mirror.aarnet.edu.au" "pub/xemacs/packages") ("Australia (au.xemacs.org)" "ftp.au.xemacs.org" "pub/xemacs/packages") ("Austria (at.xemacs.org)" "ftp.at.xemacs.org" "editors/xemacs/packages") ("Belgium (be.xemacs.org)" "ftp.be.xemacs.org" "xemacs/packages") ("Brazil (br.xemacs.org)" "ftp.br.xemacs.org" "pub/xemacs/packages") ("Canada (ca.xemacs.org)" "ftp.ca.xemacs.org" "pub/Mirror/xemacs/packages") ("Canada (crc.ca)" "ftp.crc.ca" "pub/packages/editors/xemacs/packages") ("Canada (ualberta.ca)" "sunsite.ualberta.ca" "pub/Mirror/xemacs/packages") ("Czech Republic (cz.xemacs.org)" "ftp.cz.xemacs.org" "MIRRORS/ftp.xemacs.org/pub/xemacs/packages") ("Denmark (dk.xemacs.org)" "ftp.dk.xemacs.org" "pub/emacs/xemacs/packages") ("Finland (fi.xemacs.org)" "ftp.fi.xemacs.org" "pub/mirrors/ftp.xemacs.org/pub/tux/xemacs/packages") ("France (fr.xemacs.org)" "ftp.fr.xemacs.org" "pub/xemacs/packages") ("France (mirror.cict.fr)" "mirror.cict.fr" "xemacs/packages") ("France (pasteur.fr)" "ftp.pasteur.fr" "pub/computing/xemacs/packages") ("Germany (de.xemacs.org)" "ftp.de.xemacs.org" "pub/ftp.xemacs.org/tux/xemacs/packages") ("Germany (tu-darmstadt.de)" "ftp.tu-darmstadt.de" "pub/editors/xemacs/packages") ("Ireland (ie.xemacs.org)" "ftp.ie.xemacs.org" "mirrors/ftp.xemacs.org/pub/xemacs/packages") ("Italy (it.xemacs.org)" "ftp.it.xemacs.org" "unix/packages/XEMACS/packages") ("Japan (aist.go.jp)" "ring.aist.go.jp" "pub/text/xemacs/packages") ("Japan (asahi-net.or.jp)" "ring.asahi-net.or.jp" "pub/text/xemacs/packages") ("Japan (dti.ad.jp)" "ftp.dti.ad.jp" "pub/unix/editor/xemacs/packages") ("Japan (jaist.ac.jp)" "ftp.jaist.ac.jp" "pub/GNU/xemacs/packages") ("Japan (jp.xemacs.org)" "ftp.jp.xemacs.org" "pub/GNU/xemacs/packages") ("Japan (nucba.ac.jp)" "mirror.nucba.ac.jp" "mirror/xemacs/packages") ("Japan (sut.ac.jp)" "sunsite.sut.ac.jp" "pub/archives/packages/xemacs/packages") ("Korea (kr.xemacs.org)" "ftp.kr.xemacs.org" "pub/tools/emacs/xemacs/packages") ("New Zealand (nz.xemacs.org)" "ftp.nz.xemacs.org" "mirror/ftp.xemacs.org/packages") ("Norway (no.xemacs.org)" "ftp.no.xemacs.org" "pub/xemacs/packages") ("Poland (pl.xemacs.org)" "ftp.pl.xemacs.org" "pub/unix/editors/xemacs/packages") ("Russia (ru.xemacs.org)" "ftp.ru.xemacs.org" "pub/xemacs/packages") ("Slovakia (sk.xemacs.org)" "ftp.sk.xemacs.org" "pub/mirrors/xemacs/packages") ("South Africa (za.xemacs.org)" "ftp.za.xemacs.org" "mirrorsites/ftp.xemacs.org/packages") ("Sweden (se.xemacs.org)" "ftp.se.xemacs.org" "pub/gnu/xemacs/packages") ("Switzerland (ch.xemacs.org)" "ftp.ch.xemacs.org" "mirror/xemacs/packages") ("UK (uk.xemacs.org)" "ftp.uk.xemacs.org" "sites/ftp.xemacs.org/pub/xemacs/packages") ("US (ibiblio.org)" "ibiblio.org" "pub/packages/editors/xemacs/packages") ("US (stealth.net)" "ftp.stealth.net" "pub/mirrors/ftp.xemacs.org/pub/xemacs/packages") ("US (unc.edu)" "metalab.unc.edu" "pub/packages/editors/xemacs/packages") ("US (us.xemacs.org)" "ftp.us.xemacs.org" "pub/xemacs/packages") ("US (utk.edu)" "ftp.sunsite.utk.edu" "pub/xemacs/packages")) "*List of remote sites available for downloading packages.\nList format is '(site-description site-name directory-on-site).\nSITE-DESCRIPTION is a textual description of the site.  SITE-NAME\nis the internet address of the download site.  DIRECTORY-ON-SITE\nis the directory on the site in which packages may be found.\nThis variable is used to initialize `package-get-remote', the\nvariable actually used to specify package download sites." :tag "Package download sites" :type '(repeat (list (string :tag "Name") host-name directory)) :group 'package-get)

(defcustom package-get-pre-release-download-sites '(("Pre-Releases (Main XEmacs Site)" "ftp.xemacs.org" "pub/xemacs/beta/experimental/packages") ("Australia Pre-Releases (aarnet.edu.au)" "mirror.aarnet.edu.au" "pub/xemacs/beta/experimental/packages") ("Australia Pre-Releases (au.xemacs.org)" "ftp.au.xemacs.org" "pub/xemacs/beta/experimental/packages") ("Austria Pre-Releases (at.xemacs.org)" "ftp.at.xemacs.org" "editors/xemacs/beta/experimentsl/packages") ("Brazil Pre-Releases (br.xemacs.org)" "ftp.br.xemacs.org" "pub/xemacs/xemacs-21.5/experimental/packages") ("Canada Pre-Releases (ca.xemacs.org)" "ftp.ca.xemacs.org" "pub/Mirror/xemacs/beta/experimental/packages") ("Canada Pre-Releases (crc.ca)" "ftp.crc.ca" "pub/packages/editors/xemacs/beta/experimental/packages") ("Canada Pre-Releases (ualberta.ca)" "sunsite.ualberta.ca" "pub/Mirror/xemacs/beta/experimental/packages") ("Czech Republic Pre-Releases (cz.xemacs.org)" "ftp.cz.xemacs.org" "MIRRORS/ftp.xemacs.org/pub/xemacs/xemacs-21.5/experimental/packages") ("Denmark Pre-Releases (dk.xemacs.org)" "ftp.dk.xemacs.org" "pub/emacs/xemacs/beta/experimental/packages") ("Finland Pre-Releases (fi.xemacs.org)" "ftp.fi.xemacs.org" "pub/mirrors/ftp.xemacs.org/pub/tux/xemacs/beta/experimental/packages") ("France Pre-Releases (fr.xemacs.org)" "ftp.fr.xemacs.org" "pub/xemacs/beta/experimental/packages") ("France Pre-Releases (mirror.cict.fr)" "mirror.cict.fr" "xemacs/beta/experimental/packages") ("France Pre-Releases (pasteur.fr)" "ftp.pasteur.fr" "pub/computing/xemacs/beta/experimental/packages") ("Germany Pre-Releases (de.xemacs.org)" "ftp.de.xemacs.org" "pub/ftp.xemacs.org/tux/xemacs/beta/experimental/packages") ("Germany Pre-Releases (tu-darmstadt.de)" "ftp.tu-darmstadt.de" "pub/editors/xemacs/beta/experimental/packages") ("Ireland Pre-Releases (ie.xemacs.org)" "ftp.ie.xemacs.org" "mirrors/ftp.xemacs.org/pub/xemacs/beta/experimental/packages") ("Italy Pre-Releases (it.xemacs.org)" "ftp.it.xemacs.org" "unix/packages/XEMACS/beta/experimental/packages") ("Japan Pre-Releases (aist.go.jp)" "ring.aist.go.jp" "pub/text/xemacs/beta/experimental/packages") ("Japan Pre-Releases (asahi-net.or.jp)" "ring.asahi-net.or.jp" "pub/text/xemacs/beta/experimental/packages") ("Japan Pre-Releases (dti.ad.jp)" "ftp.dti.ad.jp" "pub/unix/editor/xemacs/beta/experimental/packages") ("Japan Pre-Releases (jaist.ac.jp)" "ftp.jaist.ac.jp" "pub/GNU/xemacs/beta/experimental/packages") ("Japan Pre-Releases (jp.xemacs.org)" "ftp.jp.xemacs.org" "pub/GNU/xemacs/beta/experimental/packages") ("Japan Pre-Releases (sut.ac.jp)" "sunsite.sut.ac.jp" "pub/archives/packages/xemacs/xemacs-21.5/experimental/packages") ("New Zealand Pre-Releases (nz.xemacs.org)" "ftp.nz.xemacs.org" "mirror/ftp.xemacs.org/packages") ("Norway Pre-Releases (no.xemacs.org)" "ftp.no.xemacs.org" "pub/xemacs/beta/experimental/packages") ("Poland Pre-Releases (pl.xemacs.org)" "ftp.pl.xemacs.org" "pub/unix/editors/xemacs/beta/experimental/packages") ("Russia Pre-Releases (ru.xemacs.org)" "ftp.ru.xemacs.org" "pub/xemacs/beta/experimental/packages") ("Saudi Arabia Pre-Releases (sa.xemacs.org)" "ftp.sa.xemacs.org" "pub/mirrors/ftp.xemacs.org/xemacs/xemacs-21.5/experimental/packages") ("Slovakia Pre-Releases (sk.xemacs.org)" "ftp.sk.xemacs.org" "pub/mirrors/xemacs/beta/experimental/packages") ("South Africa Pre-Releases (za.xemacs.org)" "ftp.za.xemacs.org" "mirrorsites/ftp.xemacs.org/beta/experimental/packages") ("Sweden Pre-Releases (se.xemacs.org)" "ftp.se.xemacs.org" "pub/gnu/xemacs/beta/experimental/packages") ("Switzerland Pre-Releases (ch.xemacs.org)" "ftp.ch.xemacs.org" "mirror/xemacs/beta/experimental/packages") ("UK Pre-Releases (uk.xemacs.org)" "ftp.uk.xemacs.org" "sites/ftp.xemacs.org/pub/xemacs/beta/experimental/packages") ("US Pre-Releases (ibiblio.org)" "ibiblio.org" "pub/packages/editors/xemacs/beta/experimental/packages") ("US Pre-Releases (stealth.net)" "ftp.stealth.net" "pub/mirrors/ftp.xemacs.org/pub/xemacs/beta/experimental/packages") ("US Pre-Releases (unc.edu)" "metalab.unc.edu" "pub/packages/editors/xemacs/beta/experimental/packages") ("US Pre-Releases (us.xemacs.org)" "ftp.us.xemacs.org" "pub/xemacs/beta/experimental/packages") ("US Pre-Releases (utk.edu)" "ftp.sunsite.utk.edu" "pub/xemacs/beta/experimental/packages")) "*List of remote sites available for downloading \"Pre-Release\" packages.\nList format is '(site-description site-name directory-on-site).\nSITE-DESCRIPTION is a textual description of the site.  SITE-NAME\nis the internet address of the download site.  DIRECTORY-ON-SITE\nis the directory on the site in which packages may be found.\nThis variable is used to initialize `package-get-remote', the\nvariable actually used to specify package download sites." :tag "Pre-Release Package download sites" :type '(repeat (list (string :tag "Name") host-name directory)) :group 'package-get)

(defcustom package-get-site-release-download-sites nil "*List of remote sites available for downloading \"Site Release\" packages.\nList format is '(site-description site-name directory-on-site).\nSITE-DESCRIPTION is a textual description of the site.  SITE-NAME\nis the internet address of the download site.  DIRECTORY-ON-SITE\nis the directory on the site in which packages may be found.\nThis variable is used to initialize `package-get-remote', the\nvariable actually used to specify package download sites." :tag "Site Release Package download sites" :type '(repeat (list (string :tag "Name") host-name directory)) :group 'package-get)

(autoload 'package-get-require-base "package-get" "\
Require that a package-get database has been loaded.
If the optional FORCE-CURRENT argument or the value of
`package-get-always-update' is Non-nil, try to update the database
from a location in `package-get-remote'. Otherwise a local copy is used
if available and remote access is never done.

Please use FORCE-CURRENT only when the user is explictly dealing with packages
and remote access is likely in the near future." nil nil)

(autoload 'package-get-update-base-entry "package-get" "\
Update an entry in `package-get-base'." nil nil)

(autoload 'package-get-update-base "package-get" "\
Update the package-get database file with entries from DB-FILE.
Unless FORCE-CURRENT is non-nil never try to update the database." t nil)

(autoload 'package-get-update-base-from-buffer "package-get" "\
Update the package-get database with entries from BUFFER.
BUFFER defaults to the current buffer.  This command can be
used interactively, for example from a mail or news buffer." t nil)

(autoload 'package-get-save-base "package-get" "\
Write the package-get database to FILE.

Note: This database will be unsigned of course." t nil)

(autoload 'package-get-delete-package "package-get" "\
Delete an installation of PACKAGE below directory PKG-TOPDIR.
PACKAGE is a symbol, not a string.
This is just an interactive wrapper for `package-admin-delete-binary-package'." t nil)

(autoload 'package-get-update-all "package-get" "\
Fetch and install the latest versions of all currently installed packages." t nil)

(autoload 'package-get-all "package-get" "\
Fetch PACKAGE with VERSION and all other required packages.
Uses `package-get-base' to determine just what is required and what
package provides that functionality.  If VERSION is nil, retrieves
latest version.  Optional argument FETCHED-PACKAGES is used to keep
track of packages already fetched.  Optional argument INSTALL-DIR,
if non-nil, specifies the package directory where fetched packages
should be installed.

Returns nil upon error." t nil)

(autoload 'package-get-dependencies "package-get" "\
Compute dependencies for PACKAGES.
Uses `package-get-base' to determine just what is required and what
package provides that functionality.  Returns the list of packages
required by PACKAGES." nil nil)

(autoload 'package-get-info "package-get" "\
Get information about a package.

Quite similar to `package-get-info-prop', but can retrieve a lot more
information.

Argument PACKAGE is the name of an XEmacs package (a symbol).  It must
be a valid package, ie, a member of `package-get-base'.

Argument INFORMATION is a symbol that can be any one of:

   standards-version     Package system version (not used).
   version               Version of the XEmacs package.
   author-version        The upstream version of the package.
   date                  The date the package was last modified.
   build-date            The date the package was last built.
   maintainer            The maintainer of the package.
   distribution          Will always be \"xemacs\" (not used).
   priority              \"low\", \"medium\", or \"high\" (not used).
   category              Either \"standard\", \"mule\", or \"unsupported\"..
   dump                  Is the package dumped (not used).
   description           A description of the package.
   filename              The filename of the binary tarball of the package.
   md5sum                The md5sum of filename.
   size                  The size in bytes of filename.
   provides              A list of symbols that this package provides.
   requires              A list of packages that this package requires.
   type                  Can be either \"regular\" or \"single-file\".

If optional argument ARG is non-nil insert INFORMATION into current
buffer at point.  This is very useful for doing things like inserting
a maintainer's email address into a mail buffer.

If optional argument REMOTE is non-nil use a package list from a
remote site.  For this to work `package-get-remote' must be non-nil.

If this function is called interactively it will display INFORMATION
in the minibuffer." t nil)

(autoload 'package-get-list-packages-where "package-get" "\
Return a list of packages that fulfill certain criteria.

Argument ITEM, a symbol, is what you want to check for.  ITEM must be a
symbol even when it doesn't make sense to be a symbol (think, searching
maintainers, descriptions, etc).  The function will convert the symbol
to a string if a string is what is needed.  The downside to this is that
ITEM can only ever be a single word.

Argument FIELD, a symbol, is the field to check in.  You can specify
any one of:

      Field            Sane or Allowable Content
    description          any single word
    category             `standard' or `mule'
    maintainer           any single word
    build-date           yyyy-mm-dd
    date                 yyyy-mm-dd
    type                 `regular' or `single'
    requires             any package name
    provides             any symbol
    priority             `low', `medium', or `high'

Optional Argument ARG, a prefix arg, insert output at point in the
current buffer." t nil)

(autoload 'package-get "package-get" "\
Fetch PACKAGE from remote site.
Optional arguments VERSION indicates which version to retrieve, nil
means most recent version.  CONFLICT indicates what happens if the
package is already installed.  Valid values for CONFLICT are:
'always	always retrieve the package even if it is already installed
'never	do not retrieve the package if it is installed.
INSTALL-DIR, if non-nil, specifies the package directory where
fetched packages should be installed.

The value of `package-get-base' is used to determine what files should
be retrieved.  The value of `package-get-remote' is used to determine
where a package should be retrieved from.

Once the package is retrieved, its md5 checksum is computed.  If that
sum does not match that stored in `package-get-base' for this version
of the package, an error is signalled.

Returns `t' upon success, the symbol `error' if the package was
successfully installed but errors occurred during initialization, or
`nil' upon error." t nil)

(autoload 'package-get-package-provider "package-get" "\
Search for a package that provides SYM and return the name and
  version.  Searches in `package-get-base' for SYM.   If SYM is a
  consp, then it must match a corresponding (provide (SYM VERSION)) from
  the package.

If FORCE-CURRENT is non-nil make sure the database is up to date. This might
lead to Emacs accessing remote sites." t nil)

;;;***

;;;### (autoloads (package-net-update-installed-db package-net-setup-directory) "package-net" "lisp/package-net.el")

(autoload 'package-net-setup-directory "package-net" nil nil nil)

(autoload 'package-net-update-installed-db "package-net" "\
Write out the installed package index in a net install suitable format.
If DESTDIR is non-nil then use that as the destination directory. 
DESTDIR defaults to the value of `package-net-setup-directory'." nil nil)

;;;***

;;;### (autoloads (pui-list-packages pui-set-local-package-get-directory package-ui-site-release-download-menu package-ui-pre-release-download-menu package-ui-download-menu package-ui-add-site) "package-ui" "lisp/package-ui.el")

(autoload 'package-ui-add-site "package-ui" "\
Add site to package-get-remote and possibly offer to update package list." nil nil)

(autoload 'package-ui-download-menu "package-ui" "\
Build the `Add Download Site' menu." nil nil)

(autoload 'package-ui-pre-release-download-menu "package-ui" "\
Build the 'Pre-Release Download Sites' menu." nil nil)

(autoload 'package-ui-site-release-download-menu "package-ui" "\
Build the 'Site Release Download Sites' menu." nil nil)

(autoload 'pui-set-local-package-get-directory "package-ui" "\
Set a new package binary directory in `package-get-remote'.
Note that no provision is made for saving any changes made by this function.
It exists mainly as a convenience for one-time package installations from
disk." t nil)

(autoload 'pui-list-packages "package-ui" "\
List all packages and package information.
The package name, version, and description are displayed.  From the displayed
buffer, the user can see which packages are installed, which are not, and
which are out-of-date (a newer version is available).  The user can then
select packages for installation via the keyboard or mouse." t nil)

(defalias 'list-packages 'pui-list-packages)

;;;***

;;;### (autoloads (picture-mode) "picture" "lisp/picture.el")

(autoload 'picture-mode "picture" "\
Switch to Picture mode, in which a quarter-plane screen model is used.
Printing characters replace instead of inserting themselves with motion
afterwards settable by these commands:
  C-c <	  Move left after insertion.
  C-c >	  Move right after insertion.
  C-c ^	  Move up after insertion.
  C-c .	  Move down after insertion.
  C-c `	  Move northwest (nw) after insertion.
  C-c '	  Move northeast (ne) after insertion.
  C-c /	  Move southwest (sw) after insertion.
  C-c \\   Move southeast (se) after insertion.
The current direction is displayed in the modeline.  The initial
direction is right.  Whitespace is inserted and tabs are changed to
spaces when required by movement.  You can move around in the buffer
with these commands:
  \\[picture-move-down]	  Move vertically to SAME column in previous line.
  \\[picture-move-up]	  Move vertically to SAME column in next line.
  \\[picture-end-of-line]	  Move to column following last non-whitespace character.
  \\[picture-forward-column]	  Move right inserting spaces if required.
  \\[picture-backward-column]	  Move left changing tabs to spaces if required.
  C-c C-f Move in direction of current picture motion.
  C-c C-b Move in opposite direction of current picture motion.
  Return  Move to beginning of next line.
You can edit tabular text with these commands:
  M-Tab	  Move to column beneath (or at) next interesting character.
	    `Indents' relative to a previous line.
  Tab	  Move to next stop in tab stop list.
  C-c Tab Set tab stops according to context of this line.
	    With ARG resets tab stops to default (global) value.
	    See also documentation of variable	picture-tab-chars
	    which defines \"interesting character\".  You can manually
	    change the tab stop list with command \\[edit-tab-stops].
You can manipulate text with these commands:
  C-d	  Clear (replace) ARG columns after point without moving.
  C-c C-d Delete char at point - the command normally assigned to C-d.
  \\[picture-backward-clear-column]  Clear (replace) ARG columns before point, moving back over them.
  \\[picture-clear-line]	  Clear ARG lines, advancing over them.	 The cleared
	    text is saved in the kill ring.
  \\[picture-open-line]	  Open blank line(s) beneath current line.
You can manipulate rectangles with these commands:
  C-c C-k Clear (or kill) a rectangle and save it.
  C-c C-w Like C-c C-k except rectangle is saved in named register.
  C-c C-y Overlay (or insert) currently saved rectangle at point.
  C-c C-x Like C-c C-y except rectangle is taken from named register.
  \\[copy-rectangle-to-register]   Copies a rectangle to a register.
  \\[advertised-undo]   Can undo effects of rectangle overlay commands
	    commands if invoked soon enough.
You can return to the previous mode with:
  C-c C-c Which also strips trailing whitespace from every line.
	    Stripping is suppressed by supplying an argument.

Entry to this mode calls the value of  picture-mode-hook  if non-nil.

Note that Picture mode commands will work outside of Picture mode, but
they are not defaultly assigned to keys." t nil)

(defalias 'edit-picture 'picture-mode)

;;;***

;;;### (autoloads (clear-rectangle replace-rectangle string-rectangle open-rectangle insert-rectangle yank-rectangle kill-rectangle extract-rectangle delete-extract-rectangle delete-rectangle) "rect" "lisp/rect.el")

(autoload 'delete-rectangle "rect" "\
Delete the text in the region-rectangle without saving it.
The same range of columns is deleted in each line starting with the line
where the region begins and ending with the line where the region ends.

When called from a program, the rectangle's corners are START and END.
With a prefix (or FILL) argument, also fill lines where nothing has to be
deleted." t nil)

(autoload 'delete-extract-rectangle "rect" "\
Delete the contents of the rectangle with corners at START and END, and
return it as a list of strings, one for each line of the rectangle.

With an optional FILL argument, also fill lines where nothing has to be
deleted." nil nil)

(autoload 'extract-rectangle "rect" "\
Return the contents of the rectangle with corners at START and END,
as a list of strings, one for each line of the rectangle." nil nil)

(defvar killed-rectangle nil "\
Rectangle for `yank-rectangle' to insert.")

(autoload 'kill-rectangle "rect" "\
Delete the region-rectangle and save it as the last killed one.
You might prefer to use `delete-extract-rectangle' from a program.

When called from a program, the rectangle's corners are START and END.
With a prefix (or FILL) argument, also fill lines where nothing has to be
deleted." t nil)

(autoload 'yank-rectangle "rect" "\
Yank the last killed rectangle with upper left corner at point." t nil)

(autoload 'insert-rectangle "rect" "\
Insert text of RECTANGLE with upper left corner at point.
RECTANGLE's first line is inserted at point, its second
line is inserted at a point vertically under point, etc.
RECTANGLE should be a list of strings.
After this command, the mark is at the upper left corner
and point is at the lower right corner." nil nil)

(autoload 'open-rectangle "rect" "\
Blank out the region-rectangle, shifting text right.

When called from a program, the rectangle's corners are START and END.
With a prefix (or FILL) argument, fill with blanks even if there is no text
on the right side of the rectangle." t nil)

(autoload 'string-rectangle "rect" "\
Insert STRING on each line of the region-rectangle, shifting text right.
The left edge of the rectangle specifies the column for insertion.

If `pending-delete-mode' is active the string replace the region.
Otherwise this command does not delete or overwrite any existing text.

When called from a program, the rectangle's corners are START and END." t nil)

(autoload 'replace-rectangle "rect" "\
Like `string-rectangle', but unconditionally replace the original region,
as if `pending-delete-mode' were active." t nil)

(autoload 'clear-rectangle "rect" "\
Blank out the region-rectangle.
The text previously in the region is overwritten with blanks.

When called from a program, the rectangle's corners are START and END.
With a prefix (or FILL) argument, also fill with blanks the parts of the
rectangle which were empty." t nil)

;;;***

;;;### (autoloads (list-load-path-shadows) "shadow" "lisp/shadow.el")

(autoload 'list-load-path-shadows "shadow" "\
Display a list of Emacs Lisp files that shadow other files.

This function lists potential load-path problems.  Directories in the
`load-path' variable are searched, in order, for Emacs Lisp
files.  When a previously encountered file name is found again, a
message is displayed indicating that the later file is \"hidden\" by
the earlier.

For example, suppose `load-path' is set to

\(\"/usr/gnu/emacs/site-lisp\" \"/usr/gnu/emacs/share/emacs/19.30/lisp\")

and that each of these directories contains a file called XXX.el.  Then
XXX.el in the site-lisp directory is referred to by all of:
\(require 'XXX), (autoload .... \"XXX\"), (load-library \"XXX\") etc.

The first XXX.el file prevents emacs from seeing the second (unless
the second is loaded explicitly via load-file).

When not intended, such shadowings can be the source of subtle
problems.  For example, the above situation may have arisen because the
XXX package was not distributed with versions of emacs prior to
19.30.  An emacs maintainer downloaded XXX from elsewhere and installed
it.  Later, XXX was updated and included in the emacs distribution.
Unless the emacs maintainer checks for this, the new version of XXX
will be hidden behind the old (which may no longer work with the new
emacs version).

This function performs these checks and flags all possible
shadowings.  Because a .el file may exist without a corresponding .elc
\(or vice-versa), these suffixes are essentially ignored.  A file
XXX.elc in an early directory (that does not contain XXX.el) is
considered to shadow a later file XXX.el, and vice-versa.

When run interactively, the shadowings (if any) are displayed in a
buffer called `*Shadows*'.  Shadowings are located by calling the
\(non-interactive) companion function, `find-emacs-lisp-shadows'." t nil)

;;;***

;;;### (autoloads (load-default-sounds load-sound-file) "sound" "lisp/sound.el")

(or sound-alist (setq sound-alist '((ready nil) (warp nil))))

(autoload 'load-sound-file "sound" "\
Read in an audio-file and add it to the sound-alist.

FILENAME can either be absolute or relative, in which case the file will
be searched in the directories given by `default-sound-directory-list'.
When looking for the file, the extensions given by `sound-extension-list' are
also tried in the given order.

You can only play sound files if you are running on display 0 of the
console of a machine with native sound support or running a NetAudio
server and XEmacs has the necessary sound support compiled in.

The sound file must be in the Sun/NeXT U-LAW format, except on Linux,
where .wav files are also supported by the sound card drivers." t nil)

(autoload 'load-default-sounds "sound" "\
Load and install some sound files as beep-types, using
`load-sound-file'.  This only works if you're on display 0 of the
console of a machine with native sound support or running a NetAudio
server and XEmacs has the necessary sound support compiled in." t nil)

;;;***

;;;### (autoloads (ask-user-about-supersession-threat ask-user-about-lock) "userlock" "lisp/userlock.el")

(autoload 'ask-user-about-lock "userlock" "\
Ask user wanting to edit FILENAME, locked by OTHER-USER, what to do.
This function has a choice of three things to do:
  do (signal 'file-locked (list FILENAME OTHER-USER))
    to refrain from editing the file
  return t (grab the lock on the file)
  return nil (edit the file even though it is locked).
You can rewrite it to use any criteria you like to choose which one to do." nil nil)

(autoload 'ask-user-about-supersession-threat "userlock" "\
Ask user who is about to modify an obsolete buffer what to do.
This function has two choices: it can return, in which case the modification
of the buffer will proceed, or it can (signal 'file-supersession (FILENAME)),
in which case the proposed buffer modification will not be made.

You can rewrite this to use any criteria you like to choose which one to do.
The buffer in question is current when this function is called." nil nil)

;;;***

;;;### (autoloads (toggle-truncate-lines auto-view-mode view-major-mode view-mode view-minor-mode view-buffer-other-window view-file-other-window view-buffer view-file) "view-less" "lisp/view-less.el")

(defvar view-minor-mode-map (let ((map (make-keymap))) (set-keymap-name map 'view-minor-mode-map) (suppress-keymap map) (define-key map "-" 'negative-argument) (define-key map " " 'scroll-up) (define-key map "f" 'scroll-up) (define-key map "b" 'scroll-down) (define-key map 'backspace 'scroll-down) (define-key map 'delete 'scroll-down) (define-key map "" 'view-scroll-lines-up) (define-key map "\n" 'view-scroll-lines-up) (define-key map "e" 'view-scroll-lines-up) (define-key map "j" 'view-scroll-lines-up) (define-key map "y" 'view-scroll-lines-down) (define-key map "k" 'view-scroll-lines-down) (define-key map "d" 'view-scroll-some-lines-up) (define-key map "u" 'view-scroll-some-lines-down) (define-key map "r" 'recenter) (define-key map "t" 'toggle-truncate-lines) (define-key map "N" 'view-buffer) (define-key map "E" 'view-file) (define-key map "P" 'view-buffer) (define-key map "!" 'shell-command) (define-key map "|" 'shell-command-on-region) (define-key map "=" 'what-line) (define-key map "?" 'view-search-backward) (define-key map "h" 'view-mode-describe) (define-key map "s" 'view-repeat-search) (define-key map "n" 'view-repeat-search) (define-key map "/" 'view-search-forward) (define-key map "\\" 'view-search-backward) (define-key map "g" 'view-goto-line) (define-key map "G" 'view-last-windowful) (define-key map "%" 'view-goto-percent) (define-key map "p" 'view-goto-percent) (define-key map "m" 'point-to-register) (define-key map "'" 'register-to-point) (define-key map "C" 'view-cleanup-backspaces) (define-key map "" 'view-quit) (define-key map "" 'view-quit-toggle-ro) (define-key map "q" 'view-quit) map))

(defvar view-mode-map (let ((map (copy-keymap view-minor-mode-map))) (set-keymap-name map 'view-mode-map) map))

(autoload 'view-file "view-less" "\
Find FILENAME, enter view mode.  With prefix arg OTHER-WINDOW-P, use other window." t nil)

(autoload 'view-buffer "view-less" "\
Switch to BUFFER, enter view mode.  With prefix arg use other window." t nil)

(autoload 'view-file-other-window "view-less" "\
Find FILENAME in other window, and enter view mode." t nil)

(autoload 'view-buffer-other-window "view-less" "\
Switch to BUFFER in another window, and enter view mode." t nil)

(autoload 'view-minor-mode "view-less" "\
Minor mode for viewing text, with bindings like `less'.
Commands are:
\\<view-minor-mode-map>
0..9	prefix args
-	prefix minus
\\[scroll-up]	page forward
\\[scroll-down]	page back
\\[view-scroll-lines-up]	scroll prefix-arg lines forward, default 1.
\\[view-scroll-lines-down]	scroll prefix-arg lines backward, default 1.
\\[view-scroll-some-lines-down]	scroll prefix-arg lines backward, default 10.
\\[view-scroll-some-lines-up]	scroll prefix-arg lines forward, default 10.
\\[what-line]	print line number
\\[view-mode-describe]	print this help message
\\[view-search-forward]	regexp search, uses previous string if you just hit RET
\\[view-search-backward]	as above but searches backward
\\[view-repeat-search]	repeat last search
\\[view-goto-line]	goto line prefix-arg, default 1
\\[view-last-windowful]	goto line prefix-arg, default last line
\\[view-goto-percent]	goto a position by percentage
\\[toggle-truncate-lines]	toggle truncate-lines
\\[view-file]	view another file
\\[view-buffer]	view another buffer
\\[view-cleanup-backspaces]	cleanup backspace constructions
\\[shell-command]	execute a shell command
\\[shell-command-on-region]	execute a shell command with the region as input
\\[view-quit]	exit view-mode, and bury the current buffer.

If invoked with the optional (prefix) arg non-nil, view-mode cleans up
backspace constructions.

More precisely:
\\{view-minor-mode-map}" t nil)

(autoload 'view-mode "view-less" "\
View the current buffer using view-minor-mode.  This exists to be 99.9%
compatible with the implementations of `view-mode' in view.el and older
versions of view-less.el." t nil)

(autoload 'view-major-mode "view-less" "\
View the current buffer using view-mode, as a major mode.
This function has a nonstandard name because `view-mode' is wrongly
named but is like this for compatibility reasons." t nil)

(autoload 'auto-view-mode "view-less" "\
If the file of the current buffer is not writable, call view-mode.
This is meant to be added to `find-file-hooks'." nil nil)

(autoload 'toggle-truncate-lines "view-less" "\
Toggles the values of truncate-lines.
Positive prefix arg sets, negative disables." t nil)

;;;***

;;;### (autoloads (widget-minor-mode widget-browse-other-window widget-browse widget-browse-at) "wid-browse" "lisp/wid-browse.el")

(autoload 'widget-browse-at "wid-browse" "\
Browse the widget under point." t nil)

(autoload 'widget-browse "wid-browse" "\
Create a widget browser for WIDGET." t nil)

(autoload 'widget-browse-other-window "wid-browse" "\
Show widget browser for WIDGET in other window." t nil)

(autoload 'widget-minor-mode "wid-browse" "\
Togle minor mode for traversing widgets.
With arg, turn widget mode on if and only if arg is positive." t nil)

;;;***

;;;### (autoloads (widget-delete widget-create widget-prompt-value) "wid-edit" "lisp/wid-edit.el")

(autoload 'widget-prompt-value "wid-edit" "\
Prompt for a value matching WIDGET, using PROMPT.
The current value is assumed to be VALUE, unless UNBOUND is non-nil." nil nil)

(autoload 'widget-create "wid-edit" "\
Create widget of TYPE.
The optional ARGS are additional keyword arguments." nil nil)

(autoload 'widget-delete "wid-edit" "\
Delete WIDGET." nil nil)

;;;***

;;;### (autoloads (x-reset-device-font-menus) "x-font-menu" "lisp/x-font-menu.el")

(autoload 'x-reset-device-font-menus "x-font-menu" "\
Generates the `Font', `Size', and `Weight' submenus for the Options menu.
This is run the first time that a font-menu is needed for each device.
If you don't like the lazy invocation of this function, you can add it to
`create-device-hook' and that will make the font menus respond more quickly
when they are selected for the first time.  If you add fonts to your system, 
or if you change your font path, you can call this to re-initialize the menus." nil nil)

(defun* x-font-menu-font-data (face dcache) (defvar x-font-regexp) (defvar x-font-regexp-foundry-and-family) (let* ((case-fold-search t) (domain (if font-menu-this-frame-only-p (selected-frame) (selected-device))) (name (font-instance-name (face-font-instance face domain))) (truename (font-instance-truename (face-font-instance face domain (if (featurep 'mule) 'ascii)))) family size weight entry slant) (when (string-match x-font-regexp-foundry-and-family name) (setq family (capitalize (match-string 1 name))) (setq entry (vassoc family (aref dcache 0)))) (when (and (null entry) (string-match x-font-regexp-foundry-and-family truename)) (setq family (capitalize (match-string 1 truename))) (setq entry (vassoc family (aref dcache 0)))) (when (null entry) (return-from x-font-menu-font-data (make-vector 5 nil))) (when (string-match x-font-regexp name) (setq weight (capitalize (match-string 1 name))) (setq size (string-to-int (match-string 6 name)))) (when (string-match x-font-regexp truename) (when (not (member weight (aref entry 1))) (setq weight (capitalize (match-string 1 truename)))) (when (not (member size (aref entry 2))) (setq size (string-to-int (match-string 6 truename)))) (setq slant (capitalize (match-string 2 truename)))) (vector entry family size weight slant)))

;;;***

;;;### (autoloads (x-win-init-sun) "x-win-sun" "lisp/x-win-sun.el")

(autoload 'x-win-init-sun "x-win-sun" nil nil nil)

;;;***

;;;### (autoloads (x-win-init-xfree86) "x-win-xfree86" "lisp/x-win-xfree86.el")

(autoload 'x-win-init-xfree86 "x-win-xfree86" nil nil nil)

;;;***

(provide 'lisp-autoloads)
