/* The event_stream interface for X11 with Xt, and/or tty frames.
   Copyright (C) 1991-5, 1997 Free Software Foundation, Inc.
   Copyright (C) 1995 Sun Microsystems, Inc.
   Copyright (C) 1996 Ben Wing.

This file is part of SXEmacs.

SXEmacs is free software; you can redistribute it and/or modify it
under the terms of the GNU General Public License as published by the
Free Software Foundation; either version 2, or (at your option) any
later version.

SXEmacs is distributed in the hope that it will be useful, but WITHOUT
ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
for more details.

You should have received a copy of the GNU General Public License
along with SXEmacs; see the file COPYING.  If not, write to
the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
Boston, MA 02111-1307, USA.  */

/* Synched up with: Not in FSF. */

#include <config.h>
#include "lisp.h"

#include "console-x.h"
#include "../lwlib/lwlib.h"
#include "EmacsFrame.h"

#include "blocktype.h"
#include "buffer.h"
#include "console.h"
#include "console-tty.h"
#include "events.h"
#include "frame.h"
#include "objects-x.h"
#include "process.h"
#include "redisplay.h"
#include "elhash.h"

#include "systime.h"
#include "sysproc.h"		/* for MAXDESC */

#include "xintrinsicp.h"	/* CoreP.h needs this */
#include <X11/CoreP.h>		/* Numerous places access the fields of
				   a core widget directly.  We could
				   use XtGetValues(), but ... */
#include <X11/ShellP.h>

#ifdef HAVE_XIM
#ifdef XIM_MOTIF
#include <Xm/Xm.h>
#endif
#include "lstream.h"
#include "file-coding.h"
#endif

#if defined(HAVE_DRAGNDROP) && SOMEONE_FIXED_THAT_DND_STUFF
#include "dragdrop.h"
#endif

#if defined(HAVE_OFFIX_DND) && SOMEONE_FIXED_THAT_DND_STUFF
#include "offix.h"
#endif

#include "events-mod.h"

void enqueue_focus_event(Widget wants_it, Lisp_Object frame, int in_p);
static void handle_focus_event_1(struct frame *f, int in_p);
static void handle_focus_event_2(Window w, struct frame *f, int in_p);

static struct event_stream *Xt_event_stream;

/* With the new event model, all events go through XtDispatchEvent()
   and are picked up by an event handler that is added to each frame
   widget. (This is how it's supposed to be.) In the old method,
   Emacs sucks out events directly from XtNextEvent() and only
   dispatches the events that it doesn't need to deal with.  This
   old way has lots of corresponding junk that is no longer
   necessary: lwlib extensions, synthetic XAnyEvents, unnecessary
   magic events, etc. */

/* The one and only one application context that Emacs uses. */
XtAppContext Xt_app_con;

/* Do we accept events sent by other clients? */
int x_allow_sendevents;

#ifdef DEBUG_SXEMACS
Fixnum debug_x_events;
#endif

static int process_events_occurred;
static int tty_events_occurred;
static Widget widget_with_focus;

/* Mask of bits indicating the descriptors that we wait for input on */
extern SELECT_TYPE input_wait_mask, process_only_mask, tty_only_mask;

static const String x_fallback_resources[] = {
	/* This file is automatically generated from the app-defaults file
	   in ../etc/Emacs.ad.  These resources are consulted only if no
	   app-defaults file is found at all.
	 */
#include <Emacs.ad.h>
	0
};

static Lisp_Object x_keysym_to_emacs_keysym(KeySym keysym, int simple_p);
void emacs_Xt_mapping_action(Widget w, XEvent * event);
void debug_process_finalization(Lisp_Process * p);
void emacs_Xt_event_handler(Widget wid, XtPointer closure, XEvent * event,
			    Boolean * continue_to_dispatch);

static int last_quit_check_signal_tick_count;

Lisp_Object Qkey_mapping;
Lisp_Object Qsans_modifiers;

/************************************************************************/
/*                            keymap handling                           */
/************************************************************************/

/* X bogusly doesn't define the interpretations of any bits besides
   ModControl, ModShift, and ModLock; so the Interclient Communication
   Conventions Manual says that we have to bend over backwards to figure
   out what the other modifier bits mean.  According to ICCCM:

   - Any keycode which is assigned ModControl is a "control" key.

   - Any modifier bit which is assigned to a keycode which generates Meta_L
     or Meta_R is the modifier bit meaning "meta".  Likewise for Super, Hyper,
     etc.

   - Any keypress event which contains ModControl in its state should be
     interpreted as a "control" character.

   - Any keypress event which contains a modifier bit in its state which is
     generated by a keycode whose corresponding keysym is Meta_L or Meta_R
     should be interpreted as a "meta" character.  Likewise for Super, Hyper,
     etc.

   - It is illegal for a keysym to be associated with more than one modifier
     bit.

   This means that the only thing that emacs can reasonably interpret as a
   "meta" key is a key whose keysym is Meta_L or Meta_R, and which generates
   one of the modifier bits Mod1-Mod5.

   Unfortunately, many keyboards don't have Meta keys in their default
   configuration.  So, if there are no Meta keys, but there are "Alt" keys,
   emacs will interpret Alt as Meta.  If there are both Meta and Alt keys,
   then the Meta keys mean "Meta", and the Alt keys mean "Alt" (it used to
   mean "Symbol," but that just confused the hell out of way too many people).

   This works with the default configurations of the 19 keyboard-types I've
   checked.

   Emacs detects keyboard configurations which violate the above rules, and
   prints an error message on the standard-error-output.  (Perhaps it should
   use a pop-up-window instead.)
 */

/* For every key on the keyboard that has a known character correspondence,
   we define the ascii-character property of the keysym, and make the
   default binding for the key be self-insert-command.

   The following magic is basically intimate knowledge of X11/keysymdef.h.
   The keysym mappings defined by X11 are based on the iso8859 standards,
   except for Cyrillic and Greek.

   In a non-Mule world, a user can still have a multi-lingual editor, by doing
   (set-face-font "...-iso8859-2" (current-buffer))
   for all their Latin-2 buffers, etc.  */

static Lisp_Object x_keysym_to_character(KeySym keysym)
{
#ifdef MULE
	Lisp_Object charset = Qzero;
#define USE_CHARSET(var,cs) \
  ((var) = CHARSET_BY_LEADING_BYTE (LEADING_BYTE_##cs))
#else
#define USE_CHARSET(var,lb)
#endif				/* MULE */
	int code = 0;

	if ((keysym & 0xff) < 0xa0)
		return Qnil;

	switch (keysym >> 8) {
	case 0:		/* ASCII + Latin1 */
		USE_CHARSET(charset, LATIN_ISO8859_1);
		code = keysym & 0x7f;
		break;
	case 1:		/* Latin2 */
		USE_CHARSET(charset, LATIN_ISO8859_2);
		code = keysym & 0x7f;
		break;
	case 2:		/* Latin3 */
		USE_CHARSET(charset, LATIN_ISO8859_3);
		code = keysym & 0x7f;
		break;
	case 3:		/* Latin4 */
		USE_CHARSET(charset, LATIN_ISO8859_4);
		code = keysym & 0x7f;
		break;
	case 4:		/* Katakana */
		USE_CHARSET(charset, KATAKANA_JISX0201);
		if ((keysym & 0xff) > 0xa0)
			code = keysym & 0x7f;
		break;
	case 5:		/* Arabic */
		USE_CHARSET(charset, ARABIC_ISO8859_6);
		code = keysym & 0x7f;
		break;
	case 6:		/* Cyrillic */
		{
			static unsigned char const cyrillic[] =	/* 0x20 - 0x7f */
			{ 0x00, 0x72, 0x73, 0x71, 0x74, 0x75, 0x76, 0x77,
				0x78, 0x79, 0x7a, 0x7b, 0x7c, 0x00, 0x7e, 0x7f,
				0x70, 0x22, 0x23, 0x21, 0x24, 0x25, 0x26, 0x27,
				0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x00, 0x2e, 0x2f,
				0x6e, 0x50, 0x51, 0x66, 0x54, 0x55, 0x64, 0x53,
				0x65, 0x58, 0x59, 0x5a, 0x5b, 0x5c, 0x5d, 0x5e,
				0x5f, 0x6f, 0x60, 0x61, 0x62, 0x63, 0x56, 0x52,
				0x6c, 0x6b, 0x57, 0x68, 0x6d, 0x69, 0x67, 0x6a,
				0x4e, 0x30, 0x31, 0x46, 0x34, 0x35, 0x44, 0x33,
				0x45, 0x38, 0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0x3e,
				0x3f, 0x4f, 0x40, 0x41, 0x42, 0x43, 0x36, 0x32,
				0x4c, 0x4b, 0x37, 0x48, 0x4d, 0x49, 0x47, 0x4a
			};
			USE_CHARSET(charset, CYRILLIC_ISO8859_5);
			code = cyrillic[(keysym & 0x7f) - 0x20];
			break;
		}
	case 7:		/* Greek */
		{
			static unsigned char const greek[] =	/* 0x20 - 0x7f */
			{ 0x00, 0x36, 0x38, 0x39, 0x3a, 0x5a, 0x00, 0x3c,
				0x3e, 0x5b, 0x00, 0x3f, 0x00, 0x00, 0x35, 0x2f,
				0x00, 0x5c, 0x5d, 0x5e, 0x5f, 0x7a, 0x40, 0x7c,
				0x7d, 0x7b, 0x60, 0x7e, 0x00, 0x00, 0x00, 0x00,
				0x00, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47,
				0x48, 0x49, 0x4a, 0x4b, 0x4c, 0x4d, 0x4e, 0x4f,
				0x50, 0x51, 0x53, 0x00, 0x54, 0x55, 0x56, 0x57,
				0x58, 0x59, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
				0x00, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67,
				0x68, 0x69, 0x6a, 0x6b, 0x6c, 0x6d, 0x6e, 0x6f,
				0x70, 0x71, 0x73, 0x72, 0x74, 0x75, 0x76, 0x77,
				0x78, 0x79, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
			};
			USE_CHARSET(charset, GREEK_ISO8859_7);
			code = greek[(keysym & 0x7f) - 0x20];
			break;
		}
	case 8:		/* Technical */
		break;
	case 9:		/* Special */
		break;
	case 10:		/* Publishing */
		break;
	case 11:		/* APL */
		break;
	case 12:		/* Hebrew */
		USE_CHARSET(charset, HEBREW_ISO8859_8);
		code = keysym & 0x7f;
		break;
	case 13:		/* Thai */
		/* #### This needs to deal with character composition. */
		USE_CHARSET(charset, THAI_TIS620);
		code = keysym & 0x7f;
		break;
	case 14:		/* Korean Hangul */
		break;
	case 19:		/* Latin 9 - ISO8859-15 - unsupported charset. */
		break;
	case 32:		/* Currency */
		break;
	default:
		break;
	}

	if (code == 0)
		return Qnil;

#ifdef MULE
	return make_char(MAKE_CHAR(charset, code, 0));
#else
	return make_char(code + 0x80);
#endif
}

/* #### The way that keysym correspondence to characters should work:
   - a Lisp_Event should contain a keysym AND a character slot.
   - keybindings are tried with the keysym.  If no binding can be found,
   and there is a corresponding character, call self-insert-command.

   #### Nuke x-iso8859-1.el.
   #### Nuke the Qascii_character property.
   #### Nuke Vcharacter_set_property.
*/
static void
maybe_define_x_key_as_self_inserting_character(KeySym keysym,
					       Lisp_Object symbol)
{
	Lisp_Object character = x_keysym_to_character(keysym);

	if (CHARP(character)) {
		extern Lisp_Object Vcurrent_global_map;
		extern Lisp_Object Qascii_character;
		if (NILP(Flookup_key(Vcurrent_global_map, symbol, Qnil))) {
			Fput(symbol, Qascii_character, character);
			Fdefine_key(Vcurrent_global_map, symbol,
				    Qself_insert_command);
		}
	}
}

static void
x_has_keysym(KeySym keysym, Lisp_Object hash_table, int with_modifiers)
{
	KeySym upper_lower[2];
	int j;

	if (keysym < 0x80)	/* Optimize for ASCII keysyms */
		return;

	/* If you execute:
	   xmodmap -e 'keysym NN = scaron'
	   and then press (Shift scaron), X11 will return the different
	   keysym `Scaron', but  `xmodmap -pke'  might not even mention `Scaron'.
	   So we "register" both `scaron' and `Scaron'. */
#ifdef HAVE_XCONVERTCASE
	XConvertCase(keysym, &upper_lower[0], &upper_lower[1]);
#else
	upper_lower[0] = upper_lower[1] = keysym;
#endif

	for (j = 0; j < (upper_lower[0] == upper_lower[1] ? 1 : 2); j++) {
		char *name;
		keysym = upper_lower[j];

		name = XKeysymToString(keysym);
		if (name) {
			/* X guarantees NAME to be in the Host Portable Character Encoding */
			Lisp_Object sym = x_keysym_to_emacs_keysym(keysym, 0);
			Lisp_Object new_value =
			    with_modifiers ? Qt : Qsans_modifiers;
			Lisp_Object old_value = Fgethash(sym, hash_table, Qnil);

			if (!EQ(old_value, new_value)
			    && !(EQ(old_value, Qsans_modifiers) &&
				 EQ(new_value, Qt))) {
				maybe_define_x_key_as_self_inserting_character
				    (keysym, sym);
				Fputhash(build_ext_string(name, Qbinary),
					 new_value, hash_table);
				Fputhash(sym, new_value, hash_table);
			}
		}
	}
}

static void x_reset_key_mapping(struct device *d)
{
	Display *display = DEVICE_X_DISPLAY(d);
	struct x_device *xd = DEVICE_X_DATA(d);
	KeySym *keysym, *keysym_end;
	Lisp_Object hash_table;
	int key_code_count, keysyms_per_code;

	if (xd->x_keysym_map)
		XFree((char *)xd->x_keysym_map);
	XDisplayKeycodes(display,
			 &xd->x_keysym_map_min_code,
			 &xd->x_keysym_map_max_code);
	key_code_count =
	    xd->x_keysym_map_max_code - xd->x_keysym_map_min_code + 1;
	xd->x_keysym_map =
	    XGetKeyboardMapping(display, xd->x_keysym_map_min_code,
				key_code_count,
				&xd->x_keysym_map_keysyms_per_code);

	hash_table = xd->x_keysym_map_hash_table;
	if (HASH_TABLEP(hash_table))
		Fclrhash(hash_table);
	else
		xd->x_keysym_map_hash_table = hash_table =
		    make_lisp_hash_table(128, HASH_TABLE_NON_WEAK,
					 HASH_TABLE_EQUAL);

	for (keysym = xd->x_keysym_map,
	     keysyms_per_code = xd->x_keysym_map_keysyms_per_code,
	     keysym_end = keysym + (key_code_count * keysyms_per_code);
	     keysym < keysym_end; keysym += keysyms_per_code) {
		int j;

		if (keysym[0] == NoSymbol)
			continue;

		x_has_keysym(keysym[0], hash_table, 0);

		for (j = 1; j < keysyms_per_code; j++) {
			if (keysym[j] != keysym[0] && keysym[j] != NoSymbol)
				x_has_keysym(keysym[j], hash_table, 1);
		}
	}
}

static const char *index_to_name(int indice)
{
	switch (indice) {
	case ShiftMapIndex:
		return "ModShift";
	case LockMapIndex:
		return "ModLock";
	case ControlMapIndex:
		return "ModControl";
	case Mod1MapIndex:
		return "Mod1";
	case Mod2MapIndex:
		return "Mod2";
	case Mod3MapIndex:
		return "Mod3";
	case Mod4MapIndex:
		return "Mod4";
	case Mod5MapIndex:
		return "Mod5";
	default:
		return "???";
	}
}

/* Boy, I really wish C had local functions... */
struct c_doesnt_have_closures {	/* #### not yet used */
	int warned_about_overlapping_modifiers;
	int warned_about_predefined_modifiers;
	int warned_about_duplicate_modifiers;
	int meta_bit;
	int hyper_bit;
	int super_bit;
	int alt_bit;
	int mode_bit;
};

static void x_reset_modifier_mapping(struct device *d)
{
	Display *display = DEVICE_X_DISPLAY(d);
	struct x_device *xd = DEVICE_X_DATA(d);
	int modifier_index, modifier_key, column, mkpm;
	int warned_about_overlapping_modifiers = 0;
	int warned_about_predefined_modifiers = 0;
	int warned_about_duplicate_modifiers = 0;
	int meta_bit = 0;
	int hyper_bit = 0;
	int super_bit = 0;
	int alt_bit = 0;
	int mode_bit = 0;

	xd->lock_interpretation = 0;

	if (xd->x_modifier_keymap)
		XFreeModifiermap(xd->x_modifier_keymap);

	x_reset_key_mapping(d);

	xd->x_modifier_keymap = XGetModifierMapping(display);

	/* Boy, I really wish C had local functions...
	 */

	/* The call to warn_when_safe must be on the same line as the string or
	   make-msgfile won't pick it up properly (the newline doesn't confuse
	   it, but the backslash does). */

#define modwarn(name,old,other)						\
  warn_when_safe (Qkey_mapping, Qwarning, "SXEmacs:  %s (0x%x) generates %s, which is generated by %s.",	\
		  name, code, index_to_name (old), other),		\
  warned_about_overlapping_modifiers = 1

#define modbarf(name,other)						    \
  warn_when_safe (Qkey_mapping, Qwarning, "SXEmacs:  %s (0x%x) generates %s, which is nonsensical.", \
		  name, code, other),					    \
  warned_about_predefined_modifiers = 1

#define check_modifier(name,mask)					      \
  if ((1<<modifier_index) != mask)					      \
    warn_when_safe (Qkey_mapping, Qwarning, "SXEmacs:  %s (0x%x) generates %s, which is nonsensical.", \
		    name, code, index_to_name (modifier_index)),	      \
    warned_about_predefined_modifiers = 1

#define store_modifier(name,old)					   \
  if (old && old != modifier_index)					   \
    warn_when_safe (Qkey_mapping, Qwarning, "SXEmacs:  %s (0x%x) generates both %s and %s, which is nonsensical.",\
		    name, code, index_to_name (old),			   \
		    index_to_name (modifier_index)),			   \
    warned_about_duplicate_modifiers = 1;				   \
  if (modifier_index == ShiftMapIndex) modbarf (name,"ModShift");	   \
  else if (modifier_index == LockMapIndex) modbarf (name,"ModLock");	   \
  else if (modifier_index == ControlMapIndex) modbarf (name,"ModControl"); \
  else if (sym == XK_Mode_switch)					   \
    mode_bit = modifier_index; /* Mode_switch is special, see below... */  \
  else if (modifier_index == meta_bit && old != meta_bit)		   \
    modwarn (name, meta_bit, "Meta");					   \
  else if (modifier_index == super_bit && old != super_bit)		   \
    modwarn (name, super_bit, "Super");					   \
  else if (modifier_index == hyper_bit && old != hyper_bit)		   \
    modwarn (name, hyper_bit, "Hyper");					   \
  else if (modifier_index == alt_bit && old != alt_bit)			   \
    modwarn (name, alt_bit, "Alt");					   \
  else									   \
    old = modifier_index;

	mkpm = xd->x_modifier_keymap->max_keypermod;
	for (modifier_index = 0; modifier_index < 8; modifier_index++)
		for (modifier_key = 0; modifier_key < mkpm; modifier_key++) {
			KeySym last_sym = 0;
			for (column = 0; column < 4; column += 2) {
				KeyCode code =
				    xd->x_modifier_keymap->
				    modifiermap[modifier_index * mkpm +
						modifier_key];
				KeySym sym =
				    (code ?
				     XKeycodeToKeysym(display, code,
						      column) : 0);
				if (sym == last_sym)
					continue;
				last_sym = sym;
				switch (sym) {
				case XK_Mode_switch:
					store_modifier("Mode_switch", mode_bit);
					break;
				case XK_Meta_L:
					store_modifier("Meta_L", meta_bit);
					break;
				case XK_Meta_R:
					store_modifier("Meta_R", meta_bit);
					break;
				case XK_Super_L:
					store_modifier("Super_L", super_bit);
					break;
				case XK_Super_R:
					store_modifier("Super_R", super_bit);
					break;
				case XK_Hyper_L:
					store_modifier("Hyper_L", hyper_bit);
					break;
				case XK_Hyper_R:
					store_modifier("Hyper_R", hyper_bit);
					break;
				case XK_Alt_L:
					store_modifier("Alt_L", alt_bit);
					break;
				case XK_Alt_R:
					store_modifier("Alt_R", alt_bit);
					break;
				case XK_Control_L:
					check_modifier("Control_L",
						       ControlMask);
					break;
				case XK_Control_R:
					check_modifier("Control_R",
						       ControlMask);
					break;
				case XK_Shift_L:
					check_modifier("Shift_L", ShiftMask);
					break;
				case XK_Shift_R:
					check_modifier("Shift_R", ShiftMask);
					break;
				case XK_Shift_Lock:
					check_modifier("Shift_Lock", LockMask);
					xd->lock_interpretation = XK_Shift_Lock;
					break;
				case XK_Caps_Lock:
					check_modifier("Caps_Lock", LockMask);
					xd->lock_interpretation = XK_Caps_Lock;
					break;

					/* It probably doesn't make any sense for a modifier bit to be
					   assigned to a key that is not one of the above, but OpenWindows
					   assigns modifier bits to a couple of random function keys for
					   no reason that I can discern, so printing a warning here would
					   be annoying. */
				}
			}
		}
#undef store_modifier
#undef check_modifier
#undef modwarn
#undef modbarf

	/* If there was no Meta key, then try using the Alt key instead.
	   If there is both a Meta key and an Alt key, then the Alt key
	   is not disturbed and remains an Alt key. */
	if (!meta_bit && alt_bit)
		meta_bit = alt_bit, alt_bit = 0;

	/* mode_bit overrides everything, since it's processed down inside of
	   XLookupString() instead of by us.  If Meta and Mode_switch both
	   generate the same modifier bit (which is an error), then we don't
	   interpret that bit as Meta, because we can't make XLookupString()
	   not interpret it as Mode_switch; and interpreting it as both would
	   be totally wrong. */
	if (mode_bit) {
		const char *warn = 0;
		if (mode_bit == meta_bit)
			warn = "Meta", meta_bit = 0;
		else if (mode_bit == hyper_bit)
			warn = "Hyper", hyper_bit = 0;
		else if (mode_bit == super_bit)
			warn = "Super", super_bit = 0;
		else if (mode_bit == alt_bit)
			warn = "Alt", alt_bit = 0;
		if (warn) {
			warn_when_safe
			    (Qkey_mapping, Qwarning,
			     "SXEmacs:  %s is being used for both Mode_switch and %s.",
			     index_to_name(mode_bit), warn),
			    warned_about_overlapping_modifiers = 1;
		}
	}
#undef index_to_name

	xd->MetaMask = (meta_bit ? (1 << meta_bit) : 0);
	xd->HyperMask = (hyper_bit ? (1 << hyper_bit) : 0);
	xd->SuperMask = (super_bit ? (1 << super_bit) : 0);
	xd->AltMask = (alt_bit ? (1 << alt_bit) : 0);
	xd->ModeMask = (mode_bit ? (1 << mode_bit) : 0);	/* unused */

	if (warned_about_overlapping_modifiers)
		warn_when_safe(Qkey_mapping, Qwarning, "\n"
			       "	Two distinct modifier keys (such as Meta and Hyper) cannot generate\n"
			       "	the same modifier bit, because Emacs won't be able to tell which\n"
			       "	modifier was actually held down when some other key is pressed.  It\n"
			       "	won't be able to tell Meta-x and Hyper-x apart, for example.  Change\n"
			       "	one of these keys to use some other modifier bit.  If you intend for\n"
			       "	these keys to have the same behavior, then change them to have the\n"
			       "	same keysym as well as the same modifier bit.");

	if (warned_about_predefined_modifiers)
		warn_when_safe(Qkey_mapping, Qwarning, "\n"
			       "	The semantics of the modifier bits ModShift, ModLock, and ModControl\n"
			       "	are predefined.  It does not make sense to assign ModControl to any\n"
			       "	keysym other than Control_L or Control_R, or to assign any modifier\n"
			       "	bits to the \"control\" keysyms other than ModControl.  You can't\n"
			       "	turn a \"control\" key into a \"meta\" key (or vice versa) by simply\n"
			       "	assigning the key a different modifier bit.  You must also make that\n"
			       "	key generate an appropriate keysym (Control_L, Meta_L, etc).");

	/* No need to say anything more for warned_about_duplicate_modifiers. */

	if (warned_about_overlapping_modifiers
	    || warned_about_predefined_modifiers)
		warn_when_safe(Qkey_mapping, Qwarning,
			       "\n"
			       "	The meanings of the modifier bits Mod1 through Mod5 are determined\n"
			       "	by the keysyms used to control those bits.  Mod1 does NOT always\n"
			       "	mean Meta, although some non-ICCCM-compliant programs assume that.");
}

void x_init_modifier_mapping(struct device *d)
{
	struct x_device *xd = DEVICE_X_DATA(d);
	xd->x_keysym_map_hash_table = Qnil;
	xd->x_keysym_map = NULL;
	xd->x_modifier_keymap = NULL;
	x_reset_modifier_mapping(d);
}

static int x_key_is_modifier_p(KeyCode keycode, struct device *d)
{
	struct x_device *xd = DEVICE_X_DATA(d);
	KeySym *syms;
	int i;

	if (keycode < xd->x_keysym_map_min_code ||
	    keycode > xd->x_keysym_map_max_code)
		return 0;

	syms = &xd->x_keysym_map[(keycode - xd->x_keysym_map_min_code) *
				 xd->x_keysym_map_keysyms_per_code];
	for (i = 0; i < xd->x_keysym_map_keysyms_per_code; i++)
		if (IsModifierKey(syms[i]) || syms[i] == XK_Mode_switch)	/* why doesn't IsModifierKey count this? */
			return 1;
	return 0;
}

/* key-handling code is always ugly.  It just ends up working out
   that way.

   Here are some pointers:

   -- DOWN_MASK indicates which modifiers should be treated as "down"
      when the corresponding upstroke happens.  It gets reset for
      a particular modifier when that modifier goes up, and reset
      for all modifiers when a non-modifier key is pressed.  Example:

      I press Control-A-Shift and then release Control-A-Shift.
      I want the Shift key to be sticky but not the Control key.

   -- LAST_DOWNKEY and RELEASE_TIME are used to keep track of
      auto-repeat -- see below.

   -- If a modifier key is sticky, I can unstick it by pressing
      the modifier key again. */

static void x_handle_sticky_modifiers(XEvent * ev, struct device *d)
{
	struct x_device *xd;
	KeyCode keycode;
	int type;

	if (!modifier_keys_are_sticky)	/* Optimize for non-sticky modifiers */
		return;

	xd = DEVICE_X_DATA(d);
	keycode = ev->xkey.keycode;
	type = ev->type;

	if (keycode < xd->x_keysym_map_min_code ||
	    keycode > xd->x_keysym_map_max_code)
		return;

	if (!((type == KeyPress || type == KeyRelease) && x_key_is_modifier_p(keycode, d))) {	/* Not a modifier key */
		Bool key_event_p = (type == KeyPress || type == KeyRelease);

		if (type == ButtonPress
		    || (type == KeyPress
			&& ((xd->last_downkey
			     && ((keycode != xd->last_downkey
				  || ev->xkey.time != xd->release_time)))
			    || (INTP(Vmodifier_keys_sticky_time)
				&& ev->xkey.time
				> (xd->modifier_release_time
				   + XINT(Vmodifier_keys_sticky_time)))))) {
			xd->need_to_add_mask = 0;
			xd->last_downkey = 0;
		} else if (type == KeyPress && !xd->last_downkey)
			xd->last_downkey = keycode;

		if (type == KeyPress)
			xd->release_time = 0;
		if (type == KeyPress || type == ButtonPress) {
			xd->down_mask = 0;
			xd->modifier_release_time = 0;
		}

		if (key_event_p)
			ev->xkey.state |= xd->need_to_add_mask;
		else
			ev->xbutton.state |= xd->need_to_add_mask;

		if (type == KeyRelease && keycode == xd->last_downkey)
			/* If I hold press-and-release the Control key and then press
			   and hold down the right arrow, I want it to auto-repeat
			   Control-Right.  On the other hand, if I do the same but
			   manually press the Right arrow a bunch of times, I want
			   to see one Control-Right and then a bunch of Rights.
			   This means that we need to distinguish between an
			   auto-repeated key and a key pressed and released a bunch
			   of times.

			   Naturally, the designers of the X spec didn't see fit
			   to provide an obvious way to distinguish these cases.
			   So we assume that if the release and the next press
			   occur at the same time, the key was actually auto-
			   repeated.  Under Open-Windows, at least, this works. */
			xd->modifier_release_time = xd->release_time
			    = key_event_p ? ev->xkey.time : ev->xbutton.time;
	} else {		/* Modifier key pressed */

		int i;
		KeySym *syms =
		    &xd->x_keysym_map[(keycode - xd->x_keysym_map_min_code) *
				      xd->x_keysym_map_keysyms_per_code];

		/* If a non-modifier key was pressed in the middle of a bunch
		   of modifiers, then it unsticks all the modifiers that were
		   previously pressed.  We cannot unstick the modifiers until
		   now because we want to check for auto-repeat of the
		   non-modifier key. */

		if (xd->last_downkey) {
			xd->last_downkey = 0;
			xd->need_to_add_mask = 0;
		}

		if (xd->modifier_release_time
		    && INTP(Vmodifier_keys_sticky_time)
		    && (ev->xkey.time
			>
			xd->modifier_release_time +
			XINT(Vmodifier_keys_sticky_time))) {
			xd->need_to_add_mask = 0;
			xd->down_mask = 0;
		}
#define FROB(mask)				\
do {						\
  if (type == KeyPress)				\
    {						\
      /* If modifier key is already sticky,	\
         then unstick it.  Note that we do	\
         not test down_mask to deal with the	\
	 unlikely but possible case that the	\
	 modifier key auto-repeats. */		\
      if (xd->need_to_add_mask & mask)		\
	{					\
	  xd->need_to_add_mask &= ~mask;	\
	  xd->down_mask &= ~mask;		\
	}					\
      else					\
	xd->down_mask |= mask;			\
    }						\
  else						\
    {						\
      if (xd->down_mask & mask)			\
	{					\
	  xd->down_mask &= ~mask;		\
	  xd->need_to_add_mask |= mask;		\
	}					\
    }						\
  xd->modifier_release_time = ev->xkey.time;	\
} while (0)

		for (i = 0; i < xd->x_keysym_map_keysyms_per_code; i++)
			switch (syms[i]) {
			case XK_Control_L:
			case XK_Control_R:
				FROB(ControlMask);
				break;
			case XK_Shift_L:
			case XK_Shift_R:
				FROB(ShiftMask);
				break;
			case XK_Meta_L:
			case XK_Meta_R:
				FROB(xd->MetaMask);
				break;
			case XK_Super_L:
			case XK_Super_R:
				FROB(xd->SuperMask);
				break;
			case XK_Hyper_L:
			case XK_Hyper_R:
				FROB(xd->HyperMask);
				break;
			case XK_Alt_L:
			case XK_Alt_R:
				FROB(xd->AltMask);
				break;
			}
	}
#undef FROB
}

static void clear_sticky_modifiers(struct device *d)
{
	struct x_device *xd = DEVICE_X_DATA(d);

	xd->need_to_add_mask = 0;
	xd->last_downkey = 0;
	xd->release_time = 0;
	xd->down_mask = 0;
}

static int keysym_obeys_caps_lock_p(KeySym sym, struct device *d)
{
	struct x_device *xd = DEVICE_X_DATA(d);
	/* Eeeeevil hack.  Don't apply Caps_Lock to things that aren't alphabetic
	   characters, where "alphabetic" means something more than simply A-Z.
	   That is, if Caps_Lock is down, typing ESC doesn't produce Shift-ESC.
	   But if shift-lock is down, then it does. */
	if (xd->lock_interpretation == XK_Shift_Lock)
		return 1;

	return
	    ((sym >= XK_A) && (sym <= XK_Z)) ||
	    ((sym >= XK_a) && (sym <= XK_z)) ||
	    ((sym >= XK_Agrave) && (sym <= XK_Odiaeresis)) ||
	    ((sym >= XK_agrave) && (sym <= XK_odiaeresis)) ||
	    ((sym >= XK_Ooblique) && (sym <= XK_Thorn)) ||
	    ((sym >= XK_oslash) && (sym <= XK_thorn));
}

/* called from EmacsFrame.c (actually from Xt itself) when a
   MappingNotify event is received.  In its infinite wisdom, Xt
   decided that Xt event handlers never get MappingNotify events.
   O'Reilly Xt Programming Manual 9.1.2 says:

   MappingNotify is automatically handled by Xt, so it isn't passed
   to event handlers and you don't need to worry about it.

   Of course, we DO worry about it, so we need a special translation. */
void emacs_Xt_mapping_action(Widget w, XEvent * event)
{
	struct device *d = get_device_from_display(event->xany.display);

	if (DEVICE_X_BEING_DELETED(d))
		return;
#if 0
	/* nyet.  Now this is handled by Xt. */
	XRefreshKeyboardMapping(&event->xmapping);
#endif
	/* xmodmap generates about a billion MappingKeyboard events, followed
	   by a single MappingModifier event, so it might be worthwhile to
	   take extra MappingKeyboard events out of the queue before requesting
	   the current keymap from the server. */
	switch (event->xmapping.request) {
	case MappingKeyboard:
		x_reset_key_mapping(d);
		break;
	case MappingModifier:
		x_reset_modifier_mapping(d);
		break;
	case MappingPointer:	/* Do something here? */
		break;
	default:
		abort();
	}
}

/************************************************************************/
/*                  X to Emacs event conversion                         */
/************************************************************************/

static Lisp_Object x_keysym_to_emacs_keysym(KeySym keysym, int simple_p)
{
	char *name;
	if (keysym >= XK_exclam && keysym <= XK_asciitilde)
		/* We must assume that the X keysym numbers for the ASCII graphic
		   characters are the same as their ASCII codes.  */
		return make_char(keysym);

	switch (keysym) {
		/* These would be handled correctly by the default case, but by
		   special-casing them here we don't garbage a string or call
		   intern().  */
	case XK_BackSpace:
		return QKbackspace;
	case XK_Tab:
		return QKtab;
	case XK_Linefeed:
		return QKlinefeed;
	case XK_Return:
		return QKreturn;
	case XK_Escape:
		return QKescape;
	case XK_space:
		return QKspace;
	case XK_Delete:
		return QKdelete;
	case 0:
		return Qnil;
	default:
		if (simple_p)
			return Qnil;
		/* !!#### not Mule-ized */
		name = XKeysymToString(keysym);
		if (!name || !name[0])
			/* This happens if there is a mismatch between the Xlib of
			   SXEmacs and the Xlib of the X server...

			   Let's hard-code in some knowledge of common keysyms introduced
			   in recent X11 releases.  Snarfed from X11/keysymdef.h

			   Probably we should add some stuff here for X11R6. */
			switch (keysym) {
			case 0xFF95:
				return KEYSYM("kp-home");
			case 0xFF96:
				return KEYSYM("kp-left");
			case 0xFF97:
				return KEYSYM("kp-up");
			case 0xFF98:
				return KEYSYM("kp-right");
			case 0xFF99:
				return KEYSYM("kp-down");
			case 0xFF9A:
				return KEYSYM("kp-prior");
			case 0xFF9B:
				return KEYSYM("kp-next");
			case 0xFF9C:
				return KEYSYM("kp-end");
			case 0xFF9D:
				return KEYSYM("kp-begin");
			case 0xFF9E:
				return KEYSYM("kp-insert");
			case 0xFF9F:
				return KEYSYM("kp-delete");

			case 0x1005FF10:
				return KEYSYM("SunF36");	/* labeled F11 */
			case 0x1005FF11:
				return KEYSYM("SunF37");	/* labeled F12 */
			default:
				{
					char buf[64];
					sprintf(buf, "unknown-keysym-0x%X",
						(int)keysym);
					return KEYSYM(buf);
				}
			}
		/* If it's got a one-character name, that's good enough. */
		if (!name[1])
			return make_char(name[0]);

		/* If it's in the "Keyboard" character set, downcase it.
		   The case of those keysyms is too totally random for us to
		   force anyone to remember them.
		   The case of the other character sets is significant, however.
		 */
		if ((((unsigned int)keysym) & (~0x1FF)) ==
		    ((unsigned int)0xFE00)) {
			char buf[255];
			char *s1, *s2;
			for (s1 = name, s2 = buf; *s1; s1++, s2++) {
				if (*s1 == '_') {
					*s2 = '-';
				} else {
					*s2 = tolower(*(unsigned char *)s1);
				}
			}
			*s2 = 0;
			return KEYSYM(buf);
		}
		return KEYSYM(name);
	}
}

static Lisp_Object x_to_emacs_keysym(XKeyPressedEvent * event, int simple_p)
     /* simple_p means don't try too hard (ASCII only) */
{
	KeySym keysym = 0;

#ifdef HAVE_XIM
	int len;
	/* Some implementations of XmbLookupString don't return
	   XBufferOverflow correctly, so increase the size of the xim input
	   buffer from 64 to the more reasonable size 513, as Emacs has done.
	   From Kenichi Handa. */
	char buffer[513];
	char *bufptr = buffer;
	int bufsiz = sizeof(buffer);
	Status status;
#ifdef XIM_XLIB
	XIC xic = FRAME_X_XIC(x_any_window_to_frame
			      (get_device_from_display(event->display),
			       event->window));
#endif				/* XIM_XLIB */
#endif				/* HAVE_XIM */

	/* We use XLookupString if we're not using XIM, or are using
	   XIM_XLIB but input context creation failed. */
#if ! (defined (HAVE_XIM) && defined (XIM_MOTIF))
#if defined (HAVE_XIM) && defined (XIM_XLIB)
	if (!xic)
#endif				/* XIM_XLIB */
	{
		/* Apparently it's necessary to specify a dummy here (rather
		   than passing in 0) to avoid crashes on German IRIX */
		char dummy[256];
		XLookupString(event, dummy, 200, &keysym, 0);
		return (IsModifierKey(keysym) || keysym == XK_Mode_switch)
		    ? Qnil : x_keysym_to_emacs_keysym(keysym, simple_p);
	}
#endif				/* ! XIM_MOTIF */

#ifdef HAVE_XIM
      Lookup_String:		/* Come-From XBufferOverflow */
#ifdef XIM_MOTIF
	len =
	    XmImMbLookupString(XtWindowToWidget(event->display, event->window),
			       event, bufptr, bufsiz, &keysym, &status);
#else				/* XIM_XLIB */
	if (xic)
		len =
		    XmbLookupString(xic, event, bufptr, bufsiz, &keysym,
				    &status);
#endif				/* HAVE_XIM */

#ifdef DEBUG_SXEMACS
	if (debug_x_events > 0) {
		stderr_out("   status=");
#define print_status_when(S) if (status == S) stderr_out (#S)
		print_status_when(XLookupKeySym);
		print_status_when(XLookupBoth);
		print_status_when(XLookupChars);
		print_status_when(XLookupNone);
		print_status_when(XBufferOverflow);

		if (status == XLookupKeySym || status == XLookupBoth)
			stderr_out(" keysym=%s", XKeysymToString(keysym));
		if (status == XLookupChars || status == XLookupBoth) {
			if (len != 1) {
				int j;
				stderr_out(" chars=\"");
				for (j = 0; j < len; j++)
					stderr_out("%c", bufptr[j]);
				stderr_out("\"");
			} else if (bufptr[0] <= 32 || bufptr[0] >= 127)
				stderr_out(" char=0x%x", bufptr[0]);
			else
				stderr_out(" char=%c", bufptr[0]);
		}
		stderr_out("\n");
	}
#endif				/* DEBUG_SXEMACS */

	switch (status) {
	case XLookupKeySym:
	case XLookupBoth:
		return (IsModifierKey(keysym) || keysym == XK_Mode_switch)
		    ? Qnil : x_keysym_to_emacs_keysym(keysym, simple_p);

	case XLookupChars:
		{
			/* Generate multiple emacs events */
			struct device *d =
			    get_device_from_display(event->display);
			Emchar ch;
			Lisp_Object instream, fb_instream;
			Lstream *istr;
			struct gcpro gcpro1, gcpro2;

			fb_instream =
			    make_fixed_buffer_input_stream(bufptr, len);

			/* #### Use Fget_coding_system (Vcomposed_input_coding_system) */
			instream =
			    make_decoding_input_stream(XLSTREAM(fb_instream),
						       Fget_coding_system
						       (Qundecided));

			istr = XLSTREAM(instream);

			GCPRO2(instream, fb_instream);
			while ((ch = Lstream_get_emchar(istr)) != EOF) {
				Lisp_Object emacs_event =
				    Fmake_event(Qnil, Qnil);
				Lisp_Event *ev = XEVENT(emacs_event);
				ev->channel = DEVICE_CONSOLE(d);
				ev->event_type = key_press_event;
				ev->timestamp = event->time;
				ev->event.key.modifiers = 0;
				ev->event.key.keysym = make_char(ch);
				enqueue_Xt_dispatch_event(emacs_event);
			}
			Lstream_close(istr);
			UNGCPRO;
			Lstream_delete(istr);
			Lstream_delete(XLSTREAM(fb_instream));
			return Qnil;
		}
	case XLookupNone:
		return Qnil;
	case XBufferOverflow:
		bufptr = (char *)alloca(len + 1);
		bufsiz = len + 1;
		goto Lookup_String;
	}
	return Qnil;		/* not reached */
#endif				/* HAVE_XIM */
}

static void set_last_server_timestamp(struct device *d, XEvent * x_event)
{
	Time t;
	switch (x_event->type) {
	case KeyPress:
	case KeyRelease:
		t = x_event->xkey.time;
		break;
	case ButtonPress:
	case ButtonRelease:
		t = x_event->xbutton.time;
		break;
	case EnterNotify:
	case LeaveNotify:
		t = x_event->xcrossing.time;
		break;
	case MotionNotify:
		t = x_event->xmotion.time;
		break;
	case PropertyNotify:
		t = x_event->xproperty.time;
		break;
	case SelectionClear:
		t = x_event->xselectionclear.time;
		break;
	case SelectionRequest:
		t = x_event->xselectionrequest.time;
		break;
	case SelectionNotify:
		t = x_event->xselection.time;
		break;
	default:
		return;
	}
	DEVICE_X_LAST_SERVER_TIMESTAMP(d) = t;
}

static int x_event_to_emacs_event(XEvent * x_event, Lisp_Event * emacs_event)
{
	Display *display = x_event->xany.display;
	struct device *d = get_device_from_display(display);
	struct x_device *xd = DEVICE_X_DATA(d);

	if (DEVICE_X_BEING_DELETED(d))
		/* #### Uh, is this 0 correct? */
		return 0;

	set_last_server_timestamp(d, x_event);

	switch (x_event->type) {
	case KeyRelease:
		x_handle_sticky_modifiers(x_event, d);
		return 0;

	case KeyPress:
	case ButtonPress:
	case ButtonRelease:
		{
			int modifiers = 0;
			int shift_p, lock_p;
			Bool key_event_p = (x_event->type == KeyPress);
			unsigned int *state =
			    key_event_p ? &x_event->xkey.state : &x_event->
			    xbutton.state;

			/* If this is a synthetic KeyPress or Button event, and the user
			   has expressed a disinterest in this security hole, then drop
			   it on the floor. */
			if ((key_event_p
			     ? x_event->xkey.send_event
			     : x_event->xbutton.send_event)
#ifdef EXTERNAL_WIDGET
			    /* ben: events get sent to an ExternalShell using XSendEvent.
			       This is not a perfect solution. */
			    && !FRAME_X_EXTERNAL_WINDOW_P
			    (x_any_window_to_frame(d, x_event->xany.window))
#endif
			    && !x_allow_sendevents)
				return 0;

			DEVICE_X_MOUSE_TIMESTAMP(d) =
			    DEVICE_X_GLOBAL_MOUSE_TIMESTAMP(d) =
			    key_event_p ? x_event->xkey.time : x_event->xbutton.
			    time;

			x_handle_sticky_modifiers(x_event, d);

			if (*state & ControlMask)
				modifiers |= XEMACS_MOD_CONTROL;
			if (*state & xd->MetaMask)
				modifiers |= XEMACS_MOD_META;
			if (*state & xd->SuperMask)
				modifiers |= XEMACS_MOD_SUPER;
			if (*state & xd->HyperMask)
				modifiers |= XEMACS_MOD_HYPER;
			if (*state & xd->AltMask)
				modifiers |= XEMACS_MOD_ALT;
			{
				int numero_de_botao = -1;

				if (!key_event_p)
					numero_de_botao =
					    x_event->xbutton.button;

				/* the button gets noted either in the button or the modifiers
				   field, but not both. */
				if (numero_de_botao != 1
				    && (*state & Button1Mask))
					modifiers |= XEMACS_MOD_BUTTON1;
				if (numero_de_botao != 2
				    && (*state & Button2Mask))
					modifiers |= XEMACS_MOD_BUTTON2;
				if (numero_de_botao != 3
				    && (*state & Button3Mask))
					modifiers |= XEMACS_MOD_BUTTON3;
				if (numero_de_botao != 4
				    && (*state & Button4Mask))
					modifiers |= XEMACS_MOD_BUTTON4;
				if (numero_de_botao != 5
				    && (*state & Button5Mask))
					modifiers |= XEMACS_MOD_BUTTON5;
			}

			/* Ignore the Caps_Lock key if:
			   - any other modifiers are down, so that Caps_Lock doesn't
			   turn C-x into C-X, which would suck.
			   - the event was a mouse event. */
			if (modifiers || !key_event_p)
				*state &= (~LockMask);

			shift_p = *state & ShiftMask;
			lock_p = *state & LockMask;

			if (shift_p || lock_p)
				modifiers |= XEMACS_MOD_SHIFT;

			if (key_event_p) {
				Lisp_Object keysym;
				XKeyEvent *ev = &x_event->xkey;
				/* This used to compute the frame from the given X window and
				   store it here, but we really don't care about the frame. */
				emacs_event->channel = DEVICE_CONSOLE(d);
				keysym = x_to_emacs_keysym(&x_event->xkey, 0);

				/* If the emacs keysym is nil, then that means that the X
				   keysym was either a Modifier or NoSymbol, which
				   probably means that we're in the midst of reading a
				   Multi_key sequence, or a "dead" key prefix, or XIM
				   input. Ignore it. */
				if (NILP(keysym))
					return 0;

				/* More Caps_Lock garbage: Caps_Lock should *only* add the
				   shift modifier to two-case keys (that is, A-Z and
				   related characters). So at this point (after looking up
				   the keysym) if the keysym isn't a dual-case alphabetic,
				   and if the caps lock key was down but the shift key
				   wasn't, then turn off the shift modifier.  Gag barf */
				/* #### type lossage: assuming equivalence of emacs and
				   X keysyms */
				/* !!#### maybe fix for Mule */
				if (lock_p && !shift_p &&
				    !(CHAR_OR_CHAR_INTP(keysym)
				      && keysym_obeys_caps_lock_p
				      ((KeySym) XCHAR_OR_CHAR_INT(keysym), d)))
					modifiers &= (~XEMACS_MOD_SHIFT);

				/* If this key contains two distinct keysyms, that is,
				   "shift" generates a different keysym than the
				   non-shifted key, then don't apply the shift modifier
				   bit: it's implicit.  Otherwise, if there would be no
				   other way to tell the difference between the shifted
				   and unshifted version of this key, apply the shift bit.
				   Non-graphics, like Backspace and F1 get the shift bit
				   in the modifiers slot.  Neither the characters "a",
				   "A", "2", nor "@" normally have the shift bit set.
				   However, "F1" normally does. */
				if (modifiers & XEMACS_MOD_SHIFT) {
					int Mode_switch_p =
					    *state & xd->ModeMask;
					KeySym bot =
					    XLookupKeysym(ev,
							  Mode_switch_p ? 2 :
							  0);
					KeySym top =
					    XLookupKeysym(ev,
							  Mode_switch_p ? 3 :
							  1);
					if (top && bot && top != bot)
						modifiers &= ~XEMACS_MOD_SHIFT;
				}
				emacs_event->event_type = key_press_event;
				emacs_event->timestamp = ev->time;
				emacs_event->event.key.modifiers = modifiers;
				emacs_event->event.key.keysym = keysym;
			} else {	/* Mouse press/release event */

				XButtonEvent *ev = &x_event->xbutton;
				struct frame *frame =
				    x_window_to_frame(d, ev->window);

				if (!frame)
					return 0;	/* not for us */
				XSETFRAME(emacs_event->channel, frame);

				emacs_event->event_type =
				    (x_event->type ==
				     ButtonPress) ? button_press_event :
				    button_release_event;

				emacs_event->event.button.modifiers = modifiers;
				emacs_event->timestamp = ev->time;
				emacs_event->event.button.button = ev->button;
				emacs_event->event.button.x = ev->x;
				emacs_event->event.button.y = ev->y;
				/* because we don't seem to get a FocusIn event for button clicks
				   when a widget-glyph is selected we will assume that we want the
				   focus if a button gets pressed. */
				if (x_event->type == ButtonPress)
					handle_focus_event_1(frame, 1);
			}
		}
		break;

	case MotionNotify:
		{
			XMotionEvent *ev = &x_event->xmotion;
			struct frame *frame = x_window_to_frame(d, ev->window);
			int modifiers = 0;
			XMotionEvent event2;

			if (!frame)
				return 0;	/* not for us */

			/* We use MotionHintMask, so we will get only one motion event
			   until the next time we call XQueryPointer or the user
			   clicks the mouse.  So call XQueryPointer now (meaning that
			   the event will be in sync with the server just before
			   Fnext_event() returns).  If the mouse is still in motion,
			   then the server will immediately generate exactly one more
			   motion event, which will be on the queue waiting for us
			   next time around. */
			event2 = *ev;
			if (XQueryPointer(event2.display, event2.window,
					  &event2.root, &event2.subwindow,
					  &event2.x_root, &event2.y_root,
					  &event2.x, &event2.y, &event2.state))
				ev = &event2;	/* only one structure copy */

			DEVICE_X_MOUSE_TIMESTAMP(d) = ev->time;

			XSETFRAME(emacs_event->channel, frame);
			emacs_event->event_type = pointer_motion_event;
			emacs_event->timestamp = ev->time;
			emacs_event->event.motion.x = ev->x;
			emacs_event->event.motion.y = ev->y;
			if (ev->state & ShiftMask)
				modifiers |= XEMACS_MOD_SHIFT;
			if (ev->state & ControlMask)
				modifiers |= XEMACS_MOD_CONTROL;
			if (ev->state & xd->MetaMask)
				modifiers |= XEMACS_MOD_META;
			if (ev->state & xd->SuperMask)
				modifiers |= XEMACS_MOD_SUPER;
			if (ev->state & xd->HyperMask)
				modifiers |= XEMACS_MOD_HYPER;
			if (ev->state & xd->AltMask)
				modifiers |= XEMACS_MOD_ALT;
			if (ev->state & Button1Mask)
				modifiers |= XEMACS_MOD_BUTTON1;
			if (ev->state & Button2Mask)
				modifiers |= XEMACS_MOD_BUTTON2;
			if (ev->state & Button3Mask)
				modifiers |= XEMACS_MOD_BUTTON3;
			if (ev->state & Button4Mask)
				modifiers |= XEMACS_MOD_BUTTON4;
			if (ev->state & Button5Mask)
				modifiers |= XEMACS_MOD_BUTTON5;
			/* Currently ignores Shift_Lock but probably shouldn't
			   (but it definitely should ignore Caps_Lock). */
			emacs_event->event.motion.modifiers = modifiers;
		}
		break;

	case ClientMessage:
		{
			/* Patch bogus TAKE_FOCUS messages from MWM; CurrentTime is
			   passed as the timestamp of the TAKE_FOCUS, which the ICCCM
			   explicitly prohibits. */
			XClientMessageEvent *ev = &x_event->xclient;
#if defined(HAVE_OFFIX_DND) && SOMEONE_FIXED_THAT_DND_STUFF
			if (DndIsDropMessage(x_event)) {
				unsigned int state;
				int modifiers = 0;
				unsigned int button = 0;
				struct frame *frame =
				    x_any_window_to_frame(d, ev->window);
				Extbyte *data;
				unsigned long size, dtype;
				Lisp_Object l_type = Qnil, l_data = Qnil;
				Lisp_Object l_dndlist = Qnil, l_item = Qnil;
				struct gcpro gcpro1, gcpro2, gcpro3, gcpro4;

				if (!frame)
					return 0;	/* not for us */

				GCPRO4(l_type, l_data, l_dndlist, l_item);
				XSETFRAME(emacs_event->channel, frame);

				emacs_event->event_type = misc_user_event;
				emacs_event->timestamp =
				    DEVICE_X_LAST_SERVER_TIMESTAMP(d);

				state = DndDragButtons(x_event);

				if (state & ShiftMask)
					modifiers |= XEMACS_MOD_SHIFT;
				if (state & ControlMask)
					modifiers |= XEMACS_MOD_CONTROL;
				if (state & xd->MetaMask)
					modifiers |= XEMACS_MOD_META;
				if (state & xd->SuperMask)
					modifiers |= XEMACS_MOD_SUPER;
				if (state & xd->HyperMask)
					modifiers |= XEMACS_MOD_HYPER;
				if (state & xd->AltMask)
					modifiers |= XEMACS_MOD_ALT;
				if (state & Button1Mask)
					modifiers |= XEMACS_MOD_BUTTON1;
				if (state & Button2Mask)
					modifiers |= XEMACS_MOD_BUTTON2;
				if (state & Button3Mask)
					modifiers |= XEMACS_MOD_BUTTON3;
				if (state & Button4Mask)
					modifiers |= XEMACS_MOD_BUTTON4;
				if (state & Button5Mask)
					modifiers |= XEMACS_MOD_BUTTON5;

				if (state & Button5Mask)
					button = Button5;
				if (state & Button4Mask)
					button = Button4;
				if (state & Button3Mask)
					button = Button3;
				if (state & Button2Mask)
					button = Button2;
				if (state & Button1Mask)
					button = Button1;

				emacs_event->event.misc.modifiers = modifiers;
				emacs_event->event.misc.button = button;

				DndDropCoordinates(FRAME_X_TEXT_WIDGET(frame),
						   x_event,
						   &(emacs_event->event.misc.x),
						   &(emacs_event->event.misc.
						     y));

				DndGetData(x_event, &data, &size);

				dtype = DndDataType(x_event);
				switch (dtype) {
				case DndFiles:	/* null terminated strings, end null */
					{
						int len;
						char *hurl = NULL;

						while (*data) {
							len =
							    strlen((char *)
								   data);
							hurl =
							    dnd_url_hexify_string
							    ((char *)data,
							     "file:");
							l_item =
							    make_string((Bufbyte
									 *)
									hurl,
									strlen
									(hurl));
							l_dndlist =
							    Fcons(l_item,
								  l_dndlist);
							data += len + 1;
							xfree(hurl);
						}
						l_type = Qdragdrop_URL;
					}
					break;
				case DndText:
					l_type = Qdragdrop_MIME;
					l_dndlist =
					    list1(list3
						  (list1
						   (make_string
						    ((Bufbyte *) "text/plain",
						     10)),
						   make_string((Bufbyte *)
							       "8bit", 4),
						   make_ext_string((Extbyte *)
								   data,
								   strlen((char
									   *)
									  data),
								   Qctext)));
					break;
				case DndMIME:
					/* we have to parse this in some way to extract
					   content-type and params (in the tm way) and
					   content encoding.
					   OR: if data is string, let tm do the job
					   if data is list[2], give the first two
					   to tm...
					 */
					l_type = Qdragdrop_MIME;
					l_dndlist =
					    list1(make_ext_string
						  ((Extbyte *) data,
						   strlen((char *)data),
						   Qbinary));
					break;
				case DndFile:
				case DndDir:
				case DndLink:
				case DndExe:
					{
						char *hurl =
						    dnd_url_hexify_string((char
									   *)
									  data,
									  "file:");

						l_dndlist =
						    list1(make_string
							  ((Bufbyte *) hurl,
							   strlen(hurl)));
						l_type = Qdragdrop_URL;

						xfree(hurl);
					}
					break;
				case DndURL:
					/* as it is a real URL it should already be escaped
					   and escaping again will break them (cause % is unsave) */
					l_dndlist =
					    list1(make_ext_string
						  ((Extbyte *) data,
						   strlen((char *)data),
						   Qfile_name));
					l_type = Qdragdrop_URL;
					break;
				default:	/* Unknown, RawData and any other type */
					l_dndlist =
					    list1(list3
						  (list1
						   (make_string
						    ((Bufbyte *)
						     "application/octet-stream",
						     24)),
						   make_string((Bufbyte *)
							       "8bit", 4),
						   make_ext_string((Extbyte *)
								   data, size,
								   Qbinary)));
					l_type = Qdragdrop_MIME;
					break;
				}

				emacs_event->event.misc.function =
				    Qdragdrop_drop_dispatch;
				emacs_event->event.misc.object =
				    Fcons(l_type, l_dndlist);

				UNGCPRO;

				break;
			}
#endif				/* HAVE_OFFIX_DND */
			if (ev->message_type == DEVICE_XATOM_WM_PROTOCOLS(d)
			    && (Atom) (ev->data.l[0]) ==
			    DEVICE_XATOM_WM_TAKE_FOCUS(d)
			    && (Atom) (ev->data.l[1]) == 0) {
				ev->data.l[1] =
				    DEVICE_X_LAST_SERVER_TIMESTAMP(d);
			}
		}
		/* fall through */

	default:		/* it's a magic event */
		{
			struct frame *frame;
			Window w;
			XEvent *x_event_copy =
			    &emacs_event->event.magic.underlying_x_event;

#define FROB(event_member, window_member) \
	x_event_copy->event_member = x_event->event_member; \
	w = x_event->event_member.window_member

			switch (x_event->type) {
			case SelectionRequest:
				FROB(xselectionrequest, owner);
				break;
			case SelectionClear:
				FROB(xselectionclear, window);
				break;
			case SelectionNotify:
				FROB(xselection, requestor);
				break;
			case PropertyNotify:
				FROB(xproperty, window);
				break;
			case ClientMessage:
				FROB(xclient, window);
				break;
			case ConfigureNotify:
				FROB(xconfigure, window);
				break;
			case Expose:
			case GraphicsExpose:
				FROB(xexpose, window);
				break;
			case MapNotify:
			case UnmapNotify:
				FROB(xmap, window);
				break;
			case EnterNotify:
			case LeaveNotify:
				FROB(xcrossing, window);
				break;
			case FocusIn:
			case FocusOut:
				FROB(xfocus, window);
				break;
			case VisibilityNotify:
				FROB(xvisibility, window);
				break;
			case CreateNotify:
				FROB(xcreatewindow, window);
				break;
			default:
				w = x_event->xany.window;
				*x_event_copy = *x_event;
				break;
			}
#undef FROB
			frame = x_any_window_to_frame(d, w);

			if (!frame)
				return 0;

			emacs_event->event_type = magic_event;
			XSETFRAME(emacs_event->channel, frame);

			break;
		}
	}
	return 1;
}

/************************************************************************/
/*                           magic-event handling                       */
/************************************************************************/

static void handle_focus_event_1(struct frame *f, int in_p)
{
	handle_focus_event_2(XtWindow(FRAME_X_TEXT_WIDGET(f)), f, in_p);
}

static void handle_focus_event_2(Window win, struct frame *f, int in_p)
{
	/* Although this treats focus differently for all widgets (including
	   the frame) it seems to work ok. */
	Widget needs_it = XtWindowToWidget(FRAME_X_DISPLAY(f), win);

#if XtSpecificationRelease > 5
	widget_with_focus = XtGetKeyboardFocusWidget(FRAME_X_TEXT_WIDGET(f));
#endif
#ifdef HAVE_XIM
	XIM_focus_event(f, in_p);
#endif				/* HAVE_XIM */

	/* On focus change, clear all memory of sticky modifiers
	   to avoid non-intuitive behavior. */
	clear_sticky_modifiers(XDEVICE(FRAME_DEVICE(f)));

	/* We don't want to handle the focus change now, because we might
	   be in an accept-process-output, sleep-for, or sit-for.  So
	   we enqueue it.

	   Actually, we half handle it: we handle it as far as changing the
	   box cursor for redisplay, but we don't call any hooks or do any
	   select-frame stuff until after the sit-for.

	   Unfortunately native widgets break the model because they grab
	   the keyboard focus and nothing sets it back again. I cannot find
	   any reasonable way to do this elsewhere so we assert here that
	   the keyboard focus is on the emacs text widget. Menus and dialogs
	   do this in their selection callback, but we don't want that since
	   a button having focus is legitimate. An edit field having focus
	   is mandatory. Weirdly you get a FocusOut event when you click in
	   a widget-glyph but you don't get a corresponding FocusIn when you
	   click in the frame. Why is this?  */
	if (in_p
#if XtSpecificationRelease > 5
	    && needs_it != widget_with_focus
#endif
	    ) {
		lw_set_keyboard_focus(FRAME_X_SHELL_WIDGET(f), needs_it);
	}

	/* If we are focusing on a native widget then record and exit. */
	if (needs_it != FRAME_X_TEXT_WIDGET(f)) {
		widget_with_focus = needs_it;
		return;
	}

	/* We have the focus now. See comment in
	   emacs_Xt_handle_widget_losing_focus (). */
	if (in_p)
		widget_with_focus = NULL;

	/* do the generic event-stream stuff. */
	{
		Lisp_Object frm;
		Lisp_Object conser;
		struct gcpro gcpro1;

		XSETFRAME(frm, f);
		conser = Fcons(frm, Fcons(FRAME_DEVICE(f), in_p ? Qt : Qnil));
		GCPRO1(conser);
		emacs_handle_focus_change_preliminary(conser);
		enqueue_magic_eval_event(emacs_handle_focus_change_final,
					 conser);
		UNGCPRO;
	}
}

/* Create a synthetic X focus event. */
void enqueue_focus_event(Widget wants_it, Lisp_Object frame, int in_p)
{
	Lisp_Object emacs_event = Fmake_event(Qnil, Qnil);
	Lisp_Event *ev = XEVENT(emacs_event);
	XEvent *x_event = &ev->event.magic.underlying_x_event;

	x_event->type = in_p ? FocusIn : FocusOut;
	x_event->xfocus.window = XtWindow(wants_it);

	ev->channel = frame;
	ev->event_type = magic_event;

	enqueue_Xt_dispatch_event(emacs_event);
}

/* The idea here is that when a widget glyph gets unmapped we don't
   want the focus to stay with it if it has focus - because it may
   well just get deleted next and then we have lost the focus until the
   user does something. So handle_focus_event_1 records the widget
   with keyboard focus when FocusOut is processed, and then, when a
   widget gets unmapped, it calls this function to restore focus if
   appropriate. */
void emacs_Xt_handle_widget_losing_focus(struct frame *f, Widget losing_widget);
void emacs_Xt_handle_widget_losing_focus(struct frame *f, Widget losing_widget)
{
	if (losing_widget == widget_with_focus) {
		handle_focus_event_1(f, 1);
	}
}

/* This is called from the external-widget code */

void emacs_Xt_handle_focus_event(XEvent * event);
void emacs_Xt_handle_focus_event(XEvent * event)
{
	struct device *d = get_device_from_display(event->xany.display);
	struct frame *f;

	if (DEVICE_X_BEING_DELETED(d))
		return;

	/*
	 * It's curious that we're using x_any_window_to_frame() instead
	 * of x_window_to_frame().  I don't know what the impact of this is.
	 */
	f = x_any_window_to_frame(d, event->xfocus.window);
	if (!f)
		/* focus events are sometimes generated just before
		   a frame is destroyed. */
		return;
	handle_focus_event_1(f, event->type == FocusIn);
}

/* both MapNotify and VisibilityNotify can cause this
   JV is_visible has the same semantics as f->visible*/
static void change_frame_visibility(struct frame *f, int is_visible)
{
	Lisp_Object frame;

	XSETFRAME(frame, f);

	if (!FRAME_VISIBLE_P(f) && is_visible) {
		FRAME_VISIBLE_P(f) = is_visible;
		/* This improves the double flicker when uniconifying a frame
		   some.  A lot of it is not showing a buffer which has changed
		   while the frame was iconified.  To fix it further requires
		   the good 'ol double redisplay structure. */
		MARK_FRAME_WINDOWS_STRUCTURE_CHANGED(f);
		va_run_hook_with_args(Qmap_frame_hook, 1, frame);
	} else if (FRAME_VISIBLE_P(f) && !is_visible) {
		FRAME_VISIBLE_P(f) = 0;
		va_run_hook_with_args(Qunmap_frame_hook, 1, frame);
	} else if (FRAME_VISIBLE_P(f) * is_visible < 0) {
		FRAME_VISIBLE_P(f) = -FRAME_VISIBLE_P(f);
		if (FRAME_REPAINT_P(f))
			MARK_FRAME_WINDOWS_STRUCTURE_CHANGED(f);
		va_run_hook_with_args(Qmap_frame_hook, 1, frame);
	}
}

static void handle_map_event(struct frame *f, XEvent * event)
{
	Lisp_Object frame;

	XSETFRAME(frame, f);
	if (event->type == MapNotify) {
		XWindowAttributes xwa;

		/* Bleagh!!!!!!  Apparently some window managers (e.g. MWM)
		   send synthetic MapNotify events when a window is first
		   created, EVEN IF IT'S CREATED ICONIFIED OR INVISIBLE.
		   Or something like that.  We initially tried a different
		   solution below, but that ran into a different window-
		   manager bug.

		   It seems that the only reliable way is to treat a
		   MapNotify event as a "hint" that the window might or
		   might not be visible, and check explicitly. */

		XGetWindowAttributes(event->xany.display, event->xmap.window,
				     &xwa);
		if (xwa.map_state != IsViewable) {
			/* Calling Fframe_iconified_p is the only way we have to
			   correctly update FRAME_ICONIFIED_P */
			Fframe_iconified_p(frame);
			return;
		}

		FRAME_X_TOTALLY_VISIBLE_P(f) = 1;
#if 0
		/* Bleagh again!!!!  We initially tried the following hack
		   around the MWM problem, but it turns out that TWM
		   has a race condition when you un-iconify, where it maps
		   the window and then tells the server that the window
		   is un-iconified.  Usually, SXEmacs wakes up between
		   those two occurrences, and thus thinks that un-iconified
		   windows are still iconified.

		   Ah, the joys of X. */

		/* By Emacs definition, a frame that is iconified is not
		   visible.  Marking a frame as visible will automatically cause
		   frame-iconified-p to return nil, regardless of whether the
		   frame is actually iconified.  Therefore, we have to ignore
		   MapNotify events on iconified frames. (It's not obvious
		   to me why these are being sent, but it happens at startup
		   with frames that are initially iconified; perhaps they are
		   synthetic MapNotify events coming from the window manager.)
		   Note that `frame-iconified-p' queries the server
		   to determine whether the frame is currently iconified,
		   rather than consulting some internal (and likely
		   inaccurate) state flag.  Therefore, ignoring the MapNotify
		   is correct. */
		if (!FRAME_VISIBLE_P(f) && NILP(Fframe_iconified_p(frame)))
#endif				/* 0 */
			change_frame_visibility(f, 1);
	} else {
		FRAME_X_TOTALLY_VISIBLE_P(f) = 0;
		change_frame_visibility(f, 0);
		/* Calling Fframe_iconified_p is the only way we have to
		   correctly update FRAME_ICONIFIED_P */
		Fframe_iconified_p(frame);
	}
}

static void handle_client_message(struct frame *f, XEvent * event)
{
	struct device *d = XDEVICE(FRAME_DEVICE(f));
	Lisp_Object frame;

	XSETFRAME(frame, f);

	if (event->xclient.message_type == DEVICE_XATOM_WM_PROTOCOLS(d) &&
	    (Atom) (event->xclient.data.l[0]) ==
	    DEVICE_XATOM_WM_DELETE_WINDOW(d)) {
		/* WM_DELETE_WINDOW is a misc-user event, but other ClientMessages,
		   such as WM_TAKE_FOCUS, are eval events.  That's because delete-window
		   was probably executed with a mouse click, while the others could
		   have been sent as a result of mouse motion or some other implicit
		   action.  (Call this a "heuristic"...)  The reason for caring about
		   this is so that clicking on the close-box will make emacs prompt
		   using a dialog box instead of the minibuffer if there are unsaved
		   buffers.
		 */
		enqueue_misc_user_event(frame, Qeval,
					list3(Qdelete_frame, frame, Qt));
	} else if (event->xclient.message_type == DEVICE_XATOM_WM_PROTOCOLS(d)
		   && (Atom) event->xclient.data.l[0] ==
		   DEVICE_XATOM_WM_TAKE_FOCUS(d)) {
		handle_focus_event_1(f, 1);
#if 0
		/* If there is a dialog box up, focus on it.

		   #### Actually, we're raising it too, which is wrong.  We should
		   #### just focus on it, but lwlib doesn't currently give us an
		   #### easy way to do that.  This should be fixed.
		 */
		unsigned long take_focus_timestamp = event->xclient.data.l[1];
		Widget widget = lw_raise_all_pop_up_widgets();
		if (widget) {
			/* kludge: raise_all returns bottommost widget, but we really
			   want the topmost.  So just raise it for now. */
			XMapRaised(XtDisplay(widget), XtWindow(widget));
			/* Grab the focus with the timestamp of the TAKE_FOCUS. */
			XSetInputFocus(XtDisplay(widget), XtWindow(widget),
				       RevertToParent, take_focus_timestamp);
		}
#endif
	}
}

/* #### I'm struggling to understand how the X event loop really works. 
   Here is the problem:
   
   When widgets get mapped / changed etc the actual display updates
   are done asynchronously via X events being processed - this
   normally happens when XtAppProcessEvent() gets called. However, if
   we are executing lisp code or even doing redisplay we won't
   necessarily process X events for a very long time. This has the
   effect of widgets only getting updated when SXEmacs only goes into
   idle, or some other event causes processing of the X event queue.

   XtAppProcessEvent can get called from the following places:

     emacs_Xt_next_event () - this is normal event processing, almost
     any non-X event will take precedence and this means that we
     cannot rely on it to do the right thing at the right time for
     widget display.

     drain_X_queue () - this happens when SIGIO gets tripped,
     processing the event queue allows C-g to be checked for. It gets
     called from emacs_Xt_event_pending_p ().

   In order to solve this I have tried introducing a list primitive -
   dispatch-non-command-events - which forces processing of X events
   related to display. Unfortunately this has a number of problems,
   one is that it is possible for event_stream_event_pending_p to
   block for ever if there isn't actually an event. I guess this can
   happen if we drop the synthetic event for reason. It also relies on
   SIGIO processing which makes things rather fragile.

   People have seen behaviour whereby SXEmacs blocks until you move the
   mouse. This seems to indicate that dispatch-non-command-events is
   blocking. It may be that in a SIGIO world forcing SIGIO processing
   does the wrong thing.
*/
static void emacs_Xt_force_event_pending(struct frame *f)
{
	XEvent event;

	Display *dpy = DEVICE_X_DISPLAY(XDEVICE(FRAME_DEVICE(f)));
	event.xclient.type = ClientMessage;
	event.xclient.display = dpy;
	event.xclient.message_type = XInternAtom(dpy, "BumpQueue", False);
	event.xclient.format = 32;
	event.xclient.window = 0;

	/* Send the drop message */
	XSendEvent(dpy, XtWindow(FRAME_X_SHELL_WIDGET(f)),
		   True, NoEventMask, &event);
	/* We rely on SIGIO and friends to realise we have generated an
	   event. */
}

static void emacs_Xt_handle_magic_event(Lisp_Event * emacs_event)
{
	/* This function can GC */
	XEvent *event = &emacs_event->event.magic.underlying_x_event;
	struct frame *f = XFRAME(EVENT_CHANNEL(emacs_event));

	if (!FRAME_LIVE_P(f)
	    || DEVICE_X_BEING_DELETED(XDEVICE(FRAME_DEVICE(f))))
		return;

	switch (event->type) {
	case SelectionRequest:
		x_handle_selection_request(&event->xselectionrequest);
		break;

	case SelectionClear:
		x_handle_selection_clear(&event->xselectionclear);
		break;

	case SelectionNotify:
		x_handle_selection_notify(&event->xselection);
		break;

	case PropertyNotify:
		x_handle_property_notify(&event->xproperty);
		break;

	case Expose:
		if (!check_for_ignored_expose
		    (f, event->xexpose.x, event->xexpose.y,
		     event->xexpose.width, event->xexpose.height)
		    && !find_matching_subwindow(f, event->xexpose.x,
						event->xexpose.y,
						event->xexpose.width,
						event->xexpose.height))
			x_redraw_exposed_area(f, event->xexpose.x,
					      event->xexpose.y,
					      event->xexpose.width,
					      event->xexpose.height);
		break;

	case GraphicsExpose:	/* This occurs when an XCopyArea's source area was
				   obscured or not available. */
		x_redraw_exposed_area(f, event->xexpose.x, event->xexpose.y,
				      event->xexpose.width,
				      event->xexpose.height);
		break;

	case MapNotify:
	case UnmapNotify:
		handle_map_event(f, event);
		break;

	case EnterNotify:
		if (event->xcrossing.detail != NotifyInferior) {
			Lisp_Object frame;

			XSETFRAME(frame, f);
			/* FRAME_X_MOUSE_P (f) = 1; */
			va_run_hook_with_args(Qmouse_enter_frame_hook, 1,
					      frame);
		}
		break;

	case LeaveNotify:
		if (event->xcrossing.detail != NotifyInferior) {
			Lisp_Object frame;

			XSETFRAME(frame, f);
			/* FRAME_X_MOUSE_P (f) = 0; */
			va_run_hook_with_args(Qmouse_leave_frame_hook, 1,
					      frame);
		}
		break;

	case FocusIn:
	case FocusOut:

#ifdef EXTERNAL_WIDGET
		/* External widget lossage: Ben said:
		   YUCK.  The only way to make focus changes work properly is to
		   completely ignore all FocusIn/FocusOut events and depend only
		   on notifications from the ExternalClient widget. */
		if (FRAME_X_EXTERNAL_WINDOW_P(f))
			break;
#endif
		handle_focus_event_2(event->xfocus.window, f,
				     event->type == FocusIn);
		break;

	case ClientMessage:
		handle_client_message(f, event);
		break;

	case VisibilityNotify:	/* window visibility has changed */
		if (event->xvisibility.window ==
		    XtWindow(FRAME_X_SHELL_WIDGET(f))) {
			FRAME_X_TOTALLY_VISIBLE_P(f) =
			    (event->xvisibility.state == VisibilityUnobscured);
			/* Note that the fvwm pager only sends VisibilityNotify when
			   changing pages. Is this all we need to do ? JV */
			/* Nope.  We must at least trigger a redisplay here.
			   Since this case seems similar to MapNotify, I've
			   factored out some code to change_frame_visibility().
			   This triggers the necessary redisplay and runs
			   (un)map-frame-hook.  - dkindred@cs.cmu.edu */
			/* Changed it again to support the tristate visibility flag */
			change_frame_visibility(f, (event->xvisibility.state
						    !=
						    VisibilityFullyObscured) ? 1
						: -1);
		}
		break;

	case ConfigureNotify:
#ifdef HAVE_XIM
		XIM_SetGeometry(f);
#endif
		break;

	case CreateNotify:
		break;

	default:
		break;
	}
}

/************************************************************************/
/*				timeout events				*/
/************************************************************************/

static int timeout_id_tick;

/* Xt interval id's might not fit into an int (they're pointers, as it
   happens), so we need to provide a conversion list. */

/* pending_timeouts is a set (unordered), implemented as a stack.
   completed_timeouts* is a queue. */
static struct Xt_timeout {
	int id;
	XtIntervalId interval_id;
	struct Xt_timeout *next;
} *pending_timeouts, *completed_timeouts_head, *completed_timeouts_tail;

static struct Xt_timeout_blocktype {
	Blocktype_declare(struct Xt_timeout);
} *the_Xt_timeout_blocktype;

/* called by XtAppNextEvent() */
static void Xt_timeout_callback(XtPointer closure, XtIntervalId * id)
{
	struct Xt_timeout *timeout = (struct Xt_timeout *)closure;
	struct Xt_timeout *t2 = pending_timeouts;
	/* Remove this one from the set of pending timeouts */
	if (t2 == timeout)
		pending_timeouts = pending_timeouts->next;
	else {
		while (t2->next && t2->next != timeout)
			t2 = t2->next;
		assert(t2->next);
		t2->next = t2->next->next;
	}
	/* Add this one to the queue of completed timeouts */
	timeout->next = NULL;
	if (completed_timeouts_head)
		completed_timeouts_tail->next = timeout;
	else
		completed_timeouts_head = timeout;
	completed_timeouts_tail = timeout;
}

static int emacs_Xt_add_timeout(EMACS_TIME thyme)
{
	struct Xt_timeout *timeout = Blocktype_alloc(the_Xt_timeout_blocktype);
	EMACS_TIME current_time;
	int milliseconds;

	timeout->id = timeout_id_tick++;
	timeout->next = pending_timeouts;
	pending_timeouts = timeout;
	EMACS_GET_TIME(current_time);
	EMACS_SUB_TIME(thyme, thyme, current_time);
	milliseconds = EMACS_SECS(thyme) * 1000 + EMACS_USECS(thyme) / 1000;
	if (milliseconds < 1)
		milliseconds = 1;
	timeout->interval_id = XtAppAddTimeOut(Xt_app_con, milliseconds,
					       Xt_timeout_callback,
					       (XtPointer) timeout);
	return timeout->id;
}

static void emacs_Xt_remove_timeout(int id)
{
	struct Xt_timeout *timeout, *t2;

	timeout = NULL;

	/* Find the timeout on the list of pending ones, if it's still there. */
	if (pending_timeouts) {
		if (id == pending_timeouts->id) {
			timeout = pending_timeouts;
			pending_timeouts = pending_timeouts->next;
		} else {
			t2 = pending_timeouts;
			while (t2->next && t2->next->id != id)
				t2 = t2->next;
			if (t2->next) {	/*found it */
				timeout = t2->next;
				t2->next = t2->next->next;
			}
		}
		/* if it was pending, we have removed it from the list */
		if (timeout)
			XtRemoveTimeOut(timeout->interval_id);
	}

	/* It could be that Xt_timeout_callback was already called but we didn't
	   convert into an Emacs event yet */
	if (!timeout && completed_timeouts_head) {
		/* Thank God for code duplication! */
		if (id == completed_timeouts_head->id) {
			timeout = completed_timeouts_head;
			completed_timeouts_head = completed_timeouts_head->next;
			/* this may not be necessary? */
			if (!completed_timeouts_head)
				completed_timeouts_tail = NULL;
		} else {
			t2 = completed_timeouts_head;
			while (t2->next && t2->next->id != id)
				t2 = t2->next;
			if (t2->next) {	/* found it */
				timeout = t2->next;
				t2->next = t2->next->next;
				if (!t2->next)
					completed_timeouts_tail = t2;
			}
		}
	}

	/* If we found the thing on the lists of timeouts,
	   and removed it, deallocate
	 */
	if (timeout)
		Blocktype_free(the_Xt_timeout_blocktype, timeout);
}

static void Xt_timeout_to_emacs_event(Lisp_Event * emacs_event)
{
	struct Xt_timeout *timeout = completed_timeouts_head;
	assert(timeout);
	completed_timeouts_head = completed_timeouts_head->next;
	/* probably unnecessary */
	if (!completed_timeouts_head)
		completed_timeouts_tail = NULL;
	emacs_event->event_type = timeout_event;
	/* timeout events have nil as channel */
	emacs_event->timestamp = 0;	/* #### wrong!! */
	emacs_event->event.timeout.interval_id = timeout->id;
	emacs_event->event.timeout.function = Qnil;
	emacs_event->event.timeout.object = Qnil;
	Blocktype_free(the_Xt_timeout_blocktype, timeout);
}

/************************************************************************/
/*			process and tty events				*/
/************************************************************************/

struct what_is_ready_closure {
	int fd;
	Lisp_Object what;
	XtInputId id;
};

static Lisp_Object *filedesc_with_input;
static struct what_is_ready_closure **filedesc_to_what_closure;

static void init_what_input_once(void)
{
	int i;

	filedesc_with_input = xnew_array(Lisp_Object, MAXDESC);
	filedesc_to_what_closure =
	    xnew_array(struct what_is_ready_closure *, MAXDESC);

	for (i = 0; i < MAXDESC; i++) {
		filedesc_to_what_closure[i] = 0;
		filedesc_with_input[i] = Qnil;
	}

	process_events_occurred = 0;
	tty_events_occurred = 0;
}

static void mark_what_as_being_ready(struct what_is_ready_closure *closure)
{
	if (NILP(filedesc_with_input[closure->fd])) {
		SELECT_TYPE temp_mask;
		FD_ZERO(&temp_mask);
		FD_SET(closure->fd, &temp_mask);
		/* Check to make sure there's *really* input available.
		   Sometimes things seem to get confused and this gets called
		   for the tty fd when there's really only input available
		   on some process's fd.  (It will subsequently get called
		   for that process's fd, so returning without setting any
		   flags will take care of it.)  To see the problem, uncomment
		   the stderr_out below, turn NORMAL_QUIT_CHECK_TIMEOUT_MSECS
		   down to 25, do sh -c 'sxemacs -nw -q -f shell 2>/tmp/log'
		   and press return repeatedly.  (Seen under AIX & Linux.)
		   -dkindred@cs.cmu.edu */
		if (!poll_fds_for_input(temp_mask)) {
#if 0
			stderr_out
			    ("mark_what_as_being_ready: no input available (fd=%d)\n",
			     closure->fd);
#endif
			return;
		}
		filedesc_with_input[closure->fd] = closure->what;
		if (PROCESSP(closure->what))
			/* Don't increment this if the current process is already marked
			 *  as having input. */
			process_events_occurred++;
		else
			tty_events_occurred++;
	}
}

static void Xt_what_callback(void *closure, int *source, XtInputId * id)
{
	/* If closure is 0, then we got a fake event from a signal handler.
	   The only purpose of this is to make XtAppProcessEvent() stop
	   blocking. */
	if (closure)
		mark_what_as_being_ready((struct what_is_ready_closure *)
					 closure);
	else {
		fake_event_occurred++;
		drain_signal_event_pipe();
	}
}

static void select_filedesc(int fd, Lisp_Object what)
{
	struct what_is_ready_closure *closure;

	/* If somebody is trying to select something that's already selected
	   for, then something went wrong.  The generic routines ought to
	   detect this and error before here. */
	assert(!filedesc_to_what_closure[fd]);

	closure = xnew(struct what_is_ready_closure);
	closure->fd = fd;
	closure->what = what;
	closure->id =
	    XtAppAddInput(Xt_app_con, fd,
			  (XtPointer) (XtInputReadMask /* | XtInputExceptMask */
				       ),
			  Xt_what_callback, closure);
	filedesc_to_what_closure[fd] = closure;
}

static void unselect_filedesc(int fd)
{
	struct what_is_ready_closure *closure = filedesc_to_what_closure[fd];

	assert(closure);
	if (!NILP(filedesc_with_input[fd])) {
		/* We are unselecting this process before we have drained the rest of
		   the input from it, probably from status_notify() in the command loop.
		   This can happen like so:

		   - We are waiting in XtAppNextEvent()
		   - Process generates output
		   - Process is marked as being ready
		   - Process dies, SIGCHLD gets generated before we return (!?)
		   It could happen I guess.
		   - sigchld_handler() marks process as dead
		   - Somehow we end up getting a new KeyPress event on the queue
		   at the same time (I'm really so sure how that happens but I'm
		   not sure it can't either so let's assume it can...).
		   - Key events have priority so we return that instead of the proc.
		   - Before dispatching the lisp key event we call status_notify()
		   - Which deselects the process that SIGCHLD marked as dead.

		   Thus we never remove it from _with_input and turn it into a lisp
		   event, so we need to do it here.  But this does not mean that we're
		   throwing away the last block of output - status_notify() has already
		   taken care of running the proc filter or whatever.
		 */
		filedesc_with_input[fd] = Qnil;
		if (PROCESSP(closure->what)) {
			assert(process_events_occurred > 0);
			process_events_occurred--;
		} else {
			assert(tty_events_occurred > 0);
			tty_events_occurred--;
		}
	}
	XtRemoveInput(closure->id);
	xfree(closure);
	filedesc_to_what_closure[fd] = 0;
}

static void emacs_Xt_select_process(Lisp_Process * p)
{
	Lisp_Object process;
	int infd = event_stream_unixoid_select_process(p);

	XSETPROCESS(process, p);
	select_filedesc(infd, process);
}

static void emacs_Xt_unselect_process(Lisp_Process * p)
{
	int infd = event_stream_unixoid_unselect_process(p);

	unselect_filedesc(infd);
}

static USID
emacs_Xt_create_stream_pair(void *inhandle, void *outhandle,
			    Lisp_Object * instream, Lisp_Object * outstream,
			    int flags)
{
	USID u = event_stream_unixoid_create_stream_pair
	    (inhandle, outhandle, instream, outstream, flags);
	if (u != USID_ERROR)
		u = USID_DONTHASH;
	return u;
}

static USID
emacs_Xt_delete_stream_pair(Lisp_Object instream, Lisp_Object outstream)
{
	event_stream_unixoid_delete_stream_pair(instream, outstream);
	return USID_DONTHASH;
}

/* This is called from GC when a process object is about to be freed.
   If we've still got pointers to it in this file, we're gonna lose hard.
 */
void debug_process_finalization(Lisp_Process * p)
{
#if 0				/* #### */
	int i;
	Lisp_Object instr, outstr;

	get_process_streams(p, &instr, &outstr);
	/* if it still has fds, then it hasn't been killed yet. */
	assert(NILP(instr));
	assert(NILP(outstr));
	/* Better not still be in the "with input" table; we know it's got no fds. */
	for (i = 0; i < MAXDESC; i++) {
		Lisp_Object process = filedesc_fds_with_input[i];
		assert(!PROCESSP(process) || XPROCESS(process) != p);
	}
#endif
}

static void Xt_process_to_emacs_event(Lisp_Event * emacs_event)
{
	int i;

	assert(process_events_occurred > 0);

	for (i = 0; i < MAXDESC; i++) {
		Lisp_Object process = filedesc_with_input[i];
		if (PROCESSP(process)) {
			filedesc_with_input[i] = Qnil;
			process_events_occurred--;
			/* process events have nil as channel */
			emacs_event->event_type = process_event;
			emacs_event->timestamp = 0;	/* #### */
			emacs_event->event.process.process = process;
			return;
		}
	}
	abort();
}

static void emacs_Xt_select_console(struct console *con)
{
	Lisp_Object console;
	int infd;

	if (CONSOLE_X_P(con))
		return;		/* X consoles are automatically selected for when we
				   initialize them in Xt */
	infd = event_stream_unixoid_select_console(con);
	XSETCONSOLE(console, con);
	select_filedesc(infd, console);
}

static void emacs_Xt_unselect_console(struct console *con)
{
	Lisp_Object console;
	int infd;

	if (CONSOLE_X_P(con))
		return;		/* X consoles are automatically selected for when we
				   initialize them in Xt */
	infd = event_stream_unixoid_unselect_console(con);
	XSETCONSOLE(console, con);
	unselect_filedesc(infd);
}

/* read an event from a tty, if one is available.  Returns non-zero
   if an event was available.  Note that when this function is
   called, there should always be a tty marked as ready for input.
   However, the input condition might actually be EOF, so there
   may not really be any input available. (In this case,
   read_event_from_tty_or_stream_desc() will arrange for the TTY device
   to be deleted.) */

static int Xt_tty_to_emacs_event(Lisp_Event * emacs_event)
{
	int i;

	assert(tty_events_occurred > 0);
	for (i = 0; i < MAXDESC; i++) {
		Lisp_Object console = filedesc_with_input[i];
		if (CONSOLEP(console)) {
			assert(tty_events_occurred > 0);
			tty_events_occurred--;
			filedesc_with_input[i] = Qnil;
			if (read_event_from_tty_or_stream_desc
			    (emacs_event, XCONSOLE(console), i))
				return 1;
		}
	}

	return 0;
}

/************************************************************************/
/*		debugging functions to decipher an event		*/
/************************************************************************/

#ifdef DEBUG_SXEMACS
#include "xintrinsicp.h"	/* only describe_event() needs this */
#include <X11/Xproto.h>		/* only describe_event() needs this */

static void describe_event_window(Window window, Display * display)
{
	struct frame *f;
	Widget w;
	stderr_out("   window: 0x%lx", (unsigned long)window);
	w = XtWindowToWidget(display, window);
	if (w)
		stderr_out(" %s", w->core.widget_class->core_class.class_name);
	f = x_any_window_to_frame(get_device_from_display(display), window);
	if (f) {
		char *buf = alloca_array(char, XSTRING_LENGTH(f->name) + 4);
		sprintf(buf, " \"%s\"", XSTRING_DATA(f->name));
		write_string_to_stdio_stream(stderr, 0, (Bufbyte *) buf, 0,
					     strlen(buf), Qterminal, 1);
	}
	stderr_out("\n");
}

static const char *XEvent_mode_to_string(int mode)
{
	switch (mode) {
	case NotifyNormal:
		return "Normal";
	case NotifyGrab:
		return "Grab";
	case NotifyUngrab:
		return "Ungrab";
	case NotifyWhileGrabbed:
		return "WhileGrabbed";
	default:
		return "???";
	}
}

static const char *XEvent_detail_to_string(int detail)
{
	switch (detail) {
	case NotifyAncestor:
		return "Ancestor";
	case NotifyInferior:
		return "Inferior";
	case NotifyNonlinear:
		return "Nonlinear";
	case NotifyNonlinearVirtual:
		return "NonlinearVirtual";
	case NotifyPointer:
		return "Pointer";
	case NotifyPointerRoot:
		return "PointerRoot";
	case NotifyDetailNone:
		return "DetailNone";
	default:
		return "???";
	}
}

static const char *XEvent_visibility_to_string(int state)
{
	switch (state) {
	case VisibilityFullyObscured:
		return "FullyObscured";
	case VisibilityPartiallyObscured:
		return "PartiallyObscured";
	case VisibilityUnobscured:
		return "Unobscured";
	default:
		return "???";
	}
}

static void describe_event(XEvent * event)
{
	char buf[100];
	struct device *d = get_device_from_display(event->xany.display);

	sprintf(buf, "%s%s", x_event_name(event->type),
		event->xany.send_event ? " (send)" : "");
	stderr_out("%-30s", buf);
	switch (event->type) {
	case FocusIn:
	case FocusOut:
		{
			XFocusChangeEvent *ev = &event->xfocus;
			describe_event_window(ev->window, ev->display);
			stderr_out("     mode: %s\n",
				   XEvent_mode_to_string(ev->mode));
			stderr_out("     detail: %s\n",
				   XEvent_detail_to_string(ev->detail));
			break;
		}

	case KeyPress:
		{
			XKeyEvent *ev = &event->xkey;
			unsigned int state = ev->state;

			describe_event_window(ev->window, ev->display);
			stderr_out("   subwindow: %ld\n", ev->subwindow);
			stderr_out("   state: ");
			/* Complete list of modifier key masks */
			if (state & ShiftMask)
				stderr_out("Shift ");
			if (state & LockMask)
				stderr_out("Lock ");
			if (state & ControlMask)
				stderr_out("Control ");
			if (state & Mod1Mask)
				stderr_out("Mod1 ");
			if (state & Mod2Mask)
				stderr_out("Mod2 ");
			if (state & Mod3Mask)
				stderr_out("Mod3 ");
			if (state & Mod4Mask)
				stderr_out("Mod4 ");
			if (state & Mod5Mask)
				stderr_out("Mod5 ");

			if (!state)
				stderr_out("vanilla\n");
			else
				stderr_out("\n");
			if (x_key_is_modifier_p(ev->keycode, d))
				stderr_out("   Modifier key");
			stderr_out("   keycode: 0x%x\n", ev->keycode);
		}
		break;

	case Expose:
		if (debug_x_events > 1) {
			XExposeEvent *ev = &event->xexpose;
			describe_event_window(ev->window, ev->display);
			stderr_out("   region: x=%d y=%d width=%d height=%d\n",
				   ev->x, ev->y, ev->width, ev->height);
			stderr_out("    count: %d\n", ev->count);
		} else
			stderr_out("\n");
		break;

	case GraphicsExpose:
		if (debug_x_events > 1) {
			XGraphicsExposeEvent *ev = &event->xgraphicsexpose;
			describe_event_window(ev->drawable, ev->display);
			stderr_out("    major: %s\n",
				   (ev->major_code == X_CopyArea ? "CopyArea" :
				    (ev->major_code ==
				     X_CopyPlane ? "CopyPlane" : "?")));
			stderr_out("   region: x=%d y=%d width=%d height=%d\n",
				   ev->x, ev->y, ev->width, ev->height);
			stderr_out("    count: %d\n", ev->count);
		} else
			stderr_out("\n");
		break;

	case EnterNotify:
	case LeaveNotify:
		if (debug_x_events > 1) {
			XCrossingEvent *ev = &event->xcrossing;
			describe_event_window(ev->window, ev->display);
#if 0
			stderr_out(" subwindow: 0x%x\n", ev->subwindow);
			stderr_out("      pos: %d %d\n", ev->x, ev->y);
			stderr_out(" root pos: %d %d\n", ev->x_root,
				   ev->y_root);
#endif
			stderr_out("    mode: %s\n",
				   XEvent_mode_to_string(ev->mode));
			stderr_out("    detail: %s\n",
				   XEvent_detail_to_string(ev->detail));
			stderr_out("    focus: %d\n", ev->focus);
#if 0
			stderr_out("    state: 0x%x\n", ev->state);
#endif
		} else
			stderr_out("\n");
		break;

	case ConfigureNotify:
		if (debug_x_events > 1) {
			XConfigureEvent *ev = &event->xconfigure;
			describe_event_window(ev->window, ev->display);
			stderr_out("    above: 0x%lx\n", ev->above);
			stderr_out("     size: %d %d %d %d\n", ev->x, ev->y,
				   ev->width, ev->height);
			stderr_out("  redirect: %d\n", ev->override_redirect);
		} else
			stderr_out("\n");
		break;

	case VisibilityNotify:
		if (debug_x_events > 1) {
			XVisibilityEvent *ev = &event->xvisibility;
			describe_event_window(ev->window, ev->display);
			stderr_out("    state: %s\n",
				   XEvent_visibility_to_string(ev->state));
		} else
			stderr_out("\n");
		break;

	case ClientMessage:
		{
			XClientMessageEvent *ev = &event->xclient;
			char *name =
			    XGetAtomName(ev->display, ev->message_type);
			stderr_out("%s", name);
			if (!strcmp(name, "WM_PROTOCOLS")) {
				char *protname =
				    XGetAtomName(ev->display, ev->data.l[0]);
				stderr_out("(%s)", protname);
				XFree(protname);
			}
			XFree(name);
			stderr_out("\n");
			break;
		}

	default:
		stderr_out("\n");
		break;
	}

	fflush(stdout);
}

#endif				/* include describe_event definition */

/************************************************************************/
/*			get the next event from Xt			*/
/************************************************************************/

static Lisp_Object dispatch_event_queue, dispatch_event_queue_tail;

void enqueue_Xt_dispatch_event(Lisp_Object event)
{
	enqueue_event(event, &dispatch_event_queue, &dispatch_event_queue_tail);
}

static Lisp_Object dequeue_Xt_dispatch_event(void)
{
	return dequeue_event(&dispatch_event_queue, &dispatch_event_queue_tail);
}

/* This business exists because menu events "happen" when
   menubar_selection_callback() is called from somewhere deep
   within XtAppProcessEvent in emacs_Xt_next_event().  The
   callback needs to terminate the modal loop in that function
   or else it will continue waiting until another event is
   received.

   Same business applies to scrollbar events. */

void
signal_special_Xt_user_event(Lisp_Object channel, Lisp_Object function,
			     Lisp_Object object)
{
	Lisp_Object event = Fmake_event(Qnil, Qnil);

	XEVENT(event)->event_type = misc_user_event;
	XEVENT(event)->channel = channel;
	XEVENT(event)->event.eval.function = function;
	XEVENT(event)->event.eval.object = object;

	enqueue_Xt_dispatch_event(event);
}

static void emacs_Xt_next_event(Lisp_Event * emacs_event)
{
      we_didnt_get_an_event:

	while (NILP(dispatch_event_queue) &&
	       !completed_timeouts_head &&
	       !fake_event_occurred &&
	       !process_events_occurred && !tty_events_occurred) {

		/* Stupid logic in XtAppProcessEvent() dictates that, if process
		   events and X events are both available, the process event gets
		   taken first.  This will cause an infinite loop if we're being
		   called from Fdiscard_input().
		 */
		if (XtAppPending(Xt_app_con) & XtIMXEvent)
			XtAppProcessEvent(Xt_app_con, XtIMXEvent);
		else {
			Lisp_Object devcons, concons;

			/* We're about to block.  Xt has a bug in it (big surprise,
			   there) in that it blocks using select() and doesn't
			   flush the Xlib output buffers (XNextEvent() does this
			   automatically before blocking).  So it's necessary
			   for us to do this ourselves.  If we don't do it, then
			   display output may not be seen until the next time
			   an X event is received. (This happens esp. with
			   subprocess output that gets sent to a visible buffer.)

			   #### The above comment may not have any validity. */

			DEVICE_LOOP_NO_BREAK(devcons, concons) {
				struct device *d;
				d = XDEVICE(XCAR(devcons));

				if (DEVICE_X_P(d) && DEVICE_X_DISPLAY(d))
					/* emacs may be exiting */
					XFlush(DEVICE_X_DISPLAY(d));
			}
			XtAppProcessEvent(Xt_app_con, XtIMAll);
		}
	}

	if (!NILP(dispatch_event_queue)) {
		Lisp_Object event, event2;
		XSETEVENT(event2, emacs_event);
		event = dequeue_Xt_dispatch_event();
		Fcopy_event(event, event2);
		Fdeallocate_event(event);
	} else if (tty_events_occurred) {
		if (!Xt_tty_to_emacs_event(emacs_event))
			goto we_didnt_get_an_event;
	} else if (completed_timeouts_head)
		Xt_timeout_to_emacs_event(emacs_event);
	else if (fake_event_occurred) {
		/* A dummy event, so that a cycle of the command loop will occur. */
		fake_event_occurred = 0;
		/* eval events have nil as channel */
		emacs_event->event_type = eval_event;
		emacs_event->event.eval.function = Qidentity;
		emacs_event->event.eval.object = Qnil;
	} else			/* if (process_events_occurred) */
		Xt_process_to_emacs_event(emacs_event);

	/* No need to call XFilterEvent; Xt does it for us */
}

void emacs_Xt_event_handler(Widget wid /* unused */ ,
			    XtPointer closure /* unused */ ,
			    XEvent * event,
			    Boolean * continue_to_dispatch /* unused */ )
{
	Lisp_Object emacs_event = Fmake_event(Qnil, Qnil);

#ifdef DEBUG_SXEMACS
	if (debug_x_events > 0) {
		describe_event(event);
	}
#endif				/* DEBUG_SXEMACS */
	if (x_event_to_emacs_event(event, XEVENT(emacs_event)))
		enqueue_Xt_dispatch_event(emacs_event);
	else
		Fdeallocate_event(emacs_event);
}

/************************************************************************/
/*                      input pending / C-g checking                    */
/************************************************************************/

static Bool
quit_char_predicate(Display * display, XEvent * event, XPointer data)
{
	struct device *d = get_device_from_display(display);
	struct x_device *xd = DEVICE_X_DATA(d);
	char c, quit_char;
	Bool *critical = (Bool *) data;
	Lisp_Object keysym;

	if (critical)
		*critical = False;
	if ((event->type != KeyPress) ||
	    (!x_any_window_to_frame(d, event->xany.window)) ||
	    (event->xkey.state
	     & (xd->MetaMask | xd->HyperMask | xd->SuperMask | xd->AltMask)))
		return 0;

	/* This duplicates some code that exists elsewhere, but it's relatively
	   fast and doesn't cons. */
	keysym = x_to_emacs_keysym(&event->xkey, 1);
	if (NILP(keysym))
		return 0;
	if (CHAR_OR_CHAR_INTP(keysym))
		c = XCHAR_OR_CHAR_INT(keysym);
	/* Highly doubtful that these are the quit character, but... */
	else if (EQ(keysym, QKbackspace))
		c = '\b';
	else if (EQ(keysym, QKtab))
		c = '\t';
	else if (EQ(keysym, QKlinefeed))
		c = '\n';
	else if (EQ(keysym, QKreturn))
		c = '\r';
	else if (EQ(keysym, QKescape))
		c = 27;
	else if (EQ(keysym, QKspace))
		c = ' ';
	else if (EQ(keysym, QKdelete))
		c = 127;
	else
		return 0;

	if (event->xkey.state & xd->MetaMask)
		c |= 0x80;
	if ((event->xkey.state & ControlMask) && !(c >= 'A' && c <= 'Z'))
		c &= 0x1F;	/* unshifted control characters */
	quit_char = CONSOLE_QUIT_CHAR(XCONSOLE(DEVICE_CONSOLE(d)));
	if (c == quit_char)
		return True;
	/* If we've got Control-Shift-G instead of Control-G, that means
	   we have a critical_quit.  Caps_Lock is its own modifier, so it
	   won't cause ^G to act differently than before. */
	if (event->xkey.state & ControlMask)
		c &= 0x1F;
	if (c == quit_char) {
		if (critical)
			*critical = True;
		return True;
	}
	return False;
}

/* This scans the X input queue for a KeyPress event that matches the
   quit character, and sets Vquit_flag.  This is called from the
   QUIT macro to determine whether we should quit.

   In a SIGIO world, this won't be called unless a SIGIO has happened
   since the last time we checked.

   In a non-SIGIO world, this is called from emacs_Xt_event_pending_p
   (which is called from input_pending_p).
 */
static void x_check_for_quit_char(Display * display)
{
	XEvent event;
	int queued;
	Bool critical_quit = False;
	XEventsQueued(display, QueuedAfterReading);
	queued = XCheckIfEvent(display, &event,
			       quit_char_predicate, (char *)&critical_quit);
	if (queued) {
		Vquit_flag = (critical_quit ? Qcritical : Qt);
		/* don't put the event back onto the queue.  Those functions that
		   wanted to read a ^G directly have arranged to do this. */
	}
}

static void check_for_tty_quit_char(struct device *d)
{
	SELECT_TYPE temp_mask;
	int infd = DEVICE_INFD(d);
	struct console *con = XCONSOLE(DEVICE_CONSOLE(d));
	Emchar quit_char = CONSOLE_QUIT_CHAR(con);

	FD_ZERO(&temp_mask);
	FD_SET(infd, &temp_mask);

	while (1) {
		Lisp_Object event;
		Emchar the_char;

		if (!poll_fds_for_input(temp_mask))
			return;

		event = Fmake_event(Qnil, Qnil);
		if (!read_event_from_tty_or_stream_desc
		    (XEVENT(event), con, infd))
			/* EOF, or something ... */
			return;
		/* #### bogus.  quit-char should be allowed to be any sort
		   of event. */
		the_char = event_to_character(XEVENT(event), 1, 0, 0);
		if (the_char >= 0 && the_char == quit_char) {
			Vquit_flag = Qt;
			/* do not queue the C-g.  See above. */
			return;
		}

		/* queue the read event to be read for real later. */
		enqueue_Xt_dispatch_event(event);
	}
}

static void emacs_Xt_quit_p(void)
{
	Lisp_Object devcons, concons;
	CONSOLE_LOOP(concons) {
		struct console *con = XCONSOLE(XCAR(concons));
		if (!con->input_enabled)
			continue;

		CONSOLE_DEVICE_LOOP(devcons, con) {
			struct device *d;
			d = XDEVICE(XCAR(devcons));

			if (DEVICE_X_P(d) && DEVICE_X_DISPLAY(d))
				/* emacs may be exiting */
				x_check_for_quit_char(DEVICE_X_DISPLAY(d));
			else if (DEVICE_TTY_P(d))
				check_for_tty_quit_char(d);
		}
	}
}

static void drain_X_queue(void)
{
	Lisp_Object devcons, concons;
	CONSOLE_LOOP(concons) {
		struct console *con = XCONSOLE(XCAR(concons));
		if (!con->input_enabled)
			continue;

		/* sjt sez: Have you tried the loop over devices with XtAppPending(),
		   not XEventsQueued()?
		   Ben Sigelman sez: No.
		   sjt sez: I'm guessing that the reason that your patch "works" is this:

		   +      struct device* d;
		   +      Display* display;
		   +      d = XDEVICE (XCAR (devcons));
		   +      if (DEVICE_X_P (d) && DEVICE_X_DISPLAY (d)) {

		   Ie, if the device goes down, SXEmacs detects that and deletes it.
		   Then the if() fails (DEVICE_X_DISPLAY(d) is NULL), and we don't go
		   into the Xlib-of-no-return.  If you know different, I'd like to hear
		   about it. ;-)

		   These ideas haven't been tested; the code below works for Ben.
		 */
		CONSOLE_DEVICE_LOOP(devcons, con) {
			struct device *d;
			Display *display;
			d = XDEVICE(XCAR(devcons));
			if (DEVICE_X_P(d) && DEVICE_X_DISPLAY(d)) {
				display = DEVICE_X_DISPLAY(d);
				while (XEventsQueued
				       (display, QueuedAfterReading))
					XtAppProcessEvent(Xt_app_con,
							  XtIMXEvent);
			}
		}
	}
	/* This is the old code, before Ben Sigelman's patch. */
	/*
	   while (XtAppPending (Xt_app_con) & XtIMXEvent)
	   XtAppProcessEvent (Xt_app_con, XtIMXEvent);
	 */
}

static int emacs_Xt_event_pending_p(int user_p)
{
	Lisp_Object event;
	int tick_count_val;

	/* If `user_p' is false, then this function returns whether there are any
	   X, timeout, or fd events pending (that is, whether emacs_Xt_next_event()
	   would return immediately without blocking).

	   if `user_p' is true, then this function returns whether there are any
	   *user generated* events available (that is, whether there are keyboard
	   or mouse-click events ready to be read).  This also implies that
	   emacs_Xt_next_event() would not block.

	   In a non-SIGIO world, this also checks whether the user has typed ^G,
	   since this is a convenient place to do so.  We don't need to do this
	   in a SIGIO world, since input causes an interrupt.
	 */

#if 0
	/* I don't think there's any point to this and it will nullify
	   the speed gains achieved by the sigio_happened checking below.
	   Its only advantage is that it may possibly make C-g response
	   a bit faster.  The C-g will be noticed within 0.25 second, anyway,
	   even without this. */
#ifndef SIGIO
	/* First check for C-g if necessary */
	emacs_Xt_quit_p();
#endif
#endif

	/* This function used to simply check whether there were any X
	   events (or if user_p was 1, it iterated over all the pending
	   X events using XCheckIfEvent(), looking for keystrokes and
	   button events).  That worked in the old cheesoid event loop,
	   which didn't go through XtAppDispatchEvent(), but it doesn't
	   work any more -- X events may not result in anything.  For
	   example, a button press in a blank part of the menubar appears
	   as an X event but will not result in any Emacs events (a
	   button press that activates the menubar results in an Emacs
	   event through the stop_next_event mechanism).

	   The only accurate way of determining whether these X events
	   translate into Emacs events is to go ahead and dispatch them
	   until there's something on the dispatch queue. */

	/* See if there are any user events already on the queue. */
	EVENT_CHAIN_LOOP(event, dispatch_event_queue)
	    if (!user_p || command_event_p(event))
		return 1;

	/* See if there's any TTY input available.
	 */
	if (poll_fds_for_input(tty_only_mask))
		return 1;

	if (!user_p) {
		/* If not user_p and there are any timer or file-desc events
		   pending, we know there will be an event so we're through. */
		XtInputMask pending_value;

		/* Note that formerly we just checked the value of XtAppPending()
		   to determine if there was file-desc input.  This doesn't
		   work any more with the signal_event_pipe; XtAppPending()
		   will says "yes" in this case but there isn't really any
		   input.  Another way of fixing this problem is for the
		   signal_event_pipe to generate actual input in the form
		   of an identity eval event or something. (#### maybe this
		   actually happens?) */

		if (poll_fds_for_input(process_only_mask))
			return 1;

		pending_value = XtAppPending(Xt_app_con);

		if (pending_value & XtIMTimer)
			return 1;
	}

	/* XtAppPending() can be super-slow, esp. over a network connection.
	   Quantify results have indicated that in some cases the
	   call to detect_input_pending() completely dominates the
	   running time of redisplay().  Fortunately, in a SIGIO world
	   we can more quickly determine whether there are any X events:
	   if an event has happened since the last time we checked, then
	   a SIGIO will have happened.  On a machine with broken SIGIO,
	   we'll still be in an OK state -- the sigio_happened flag
	   will get set at least once a second, so we'll be no more than
	   one second behind reality. (In general it's OK if we
	   erroneously report no input pending when input is actually
	   pending() -- preemption is just a bit less efficient, that's
	   all.  It's bad bad bad if you err the other way -- you've
	   promised that `next-event' won't block but it actually will,
	   and some action might get delayed until the next time you
	   hit a key.)
	 */

	/* quit_check_signal_tick_count is volatile so try to avoid race conditions
	   by using a temporary variable */
	tick_count_val = quit_check_signal_tick_count;
	if (last_quit_check_signal_tick_count != tick_count_val
#if !defined (SIGIO) 
	    || (XtIMXEvent & XtAppPending(Xt_app_con))
#endif
	    ) {
		last_quit_check_signal_tick_count = tick_count_val;

		/* We need to drain the entire queue now -- if we only
		   drain part of it, we may later on end up with events
		   actually pending but detect_input_pending() returning
		   false because there wasn't another SIGIO. */
		drain_X_queue();

		EVENT_CHAIN_LOOP(event, dispatch_event_queue)
		    if (!user_p || command_event_p(event))
			return 1;
	}

	return 0;
}

static int emacs_Xt_current_event_timestamp(struct console *c)
{
	/* semi-yuck. */
	Lisp_Object devs = CONSOLE_DEVICE_LIST(c);

	if (NILP(devs))
		return 0;
	else {
		struct device *d = XDEVICE(XCAR(devs));
		return DEVICE_X_LAST_SERVER_TIMESTAMP(d);
	}
}

/************************************************************************/
/*            replacement for standard string-to-pixel converter        */
/************************************************************************/

/* This was constructed by ripping off the standard string-to-pixel
   converter from Converters.c in the Xt source code and modifying
   appropriately. */

#if 0

/* This is exported by the Xt library (at least by mine).  If this
   isn't the case somewhere, rename this appropriately and remove
   the '#if 0'.  Note, however, that I got "unknown structure"
   errors when I tried this. */
XtConvertArgRec Const colorConvertArgs[] = {
	{XtWidgetBaseOffset, (XtPointer) XtOffsetOf(WidgetRec, core.screen),
	 sizeof(Screen *)}
	,
	{XtWidgetBaseOffset, (XtPointer) XtOffsetOf(WidgetRec, core.colormap),
	 sizeof(Colormap)}
};

#endif

#define done(type, value)               \
  if (toVal->addr != NULL) {             \
    if (toVal->size < sizeof(type)) {    \
      toVal->size = sizeof(type);        \
      return False;                      \
    }                                    \
    *(type*)(toVal->addr) = (value);     \
  } else {                               \
    static type static_val;              \
    static_val = (value);                \
    toVal->addr = (XPointer)&static_val; \
  }                                      \
  toVal->size = sizeof(type);            \
  return True			/* Caller supplies `;' */

/* JH: We use this because I think there's a possibility this
   is called before the device is properly set up, in which case
   I don't want to abort. */
extern struct device *get_device_from_display_1(Display * dpy);

static
Boolean EmacsXtCvtStringToPixel(Display * dpy,
				XrmValuePtr args,
				Cardinal * num_args,
				XrmValuePtr fromVal,
				XrmValuePtr toVal, XtPointer * closure_ret)
{
	String str = (String) fromVal->addr;
	XColor screenColor;
	XColor exactColor;
	Screen *screen;
	Colormap colormap;
	Visual *visual;
	struct device *d;
	Status status;
	String params[1];
	Cardinal num_params = 1;
	XtAppContext the_app_con = XtDisplayToApplicationContext(dpy);

	if (*num_args != 2) {
		XtAppWarningMsg(the_app_con, "wrongParameters",
				"cvtStringToPixel", "XtToolkitError",
				"String to pixel conversion needs screen and colormap arguments",
				(String *) NULL, (Cardinal *) NULL);
		return False;
	}

	screen = *((Screen **) args[0].addr);
	colormap = *((Colormap *) args[1].addr);

	/* The original uses the private function CompareISOLatin1().
	   Use XmuCompareISOLatin1() if you want, but I don't think it
	   makes any difference here. */
	if (strcmp(str, XtDefaultBackground) == 0) {
		*closure_ret = False;
		/* This refers to the display's "*reverseVideo" resource.
		   These display resources aren't documented anywhere that
		   I can find, so I'm going to ignore this. */
		/* if (pd->rv) done(Pixel, BlackPixelOfScreen(screen)) else */
		done(Pixel, WhitePixelOfScreen(screen));
	}
	if (strcmp(str, XtDefaultForeground) == 0) {
		*closure_ret = False;
		/* if (pd->rv) done(Pixel, WhitePixelOfScreen(screen)) else */
		done(Pixel, BlackPixelOfScreen(screen));
	}

	/* Originally called XAllocNamedColor() here. */
	if ((d = get_device_from_display_1(dpy))) {
		visual = DEVICE_X_VISUAL(d);
		if (colormap != DEVICE_X_COLORMAP(d)) {
			XtAppWarningMsg(the_app_con, "weirdColormap",
					"cvtStringToPixel", "XtToolkitWarning",
					"The colormap passed to cvtStringToPixel doesn't match the one registered to the device.\n",
					NULL, 0);
			status =
			    XAllocNamedColor(dpy, colormap, (char *)str,
					     &screenColor, &exactColor);
		} else {
			status =
			    XParseColor(dpy, colormap, (char *)str,
					&screenColor);
			if (status) {
				status =
				    allocate_nearest_color(dpy, colormap,
							   visual,
							   &screenColor);
			}
		}
	} else {
		/* We haven't set up this device totally yet, so just punt */
		status =
		    XAllocNamedColor(dpy, colormap, (char *)str, &screenColor,
				     &exactColor);
	}
	if (status == 0) {
		params[0] = str;
		/* Server returns a specific error code but Xlib discards it.  Ugh */
		if (XLookupColor(DisplayOfScreen(screen), colormap, (char *)str,
				 &exactColor, &screenColor)) {
			XtAppWarningMsg(the_app_con, "noColormap",
					"cvtStringToPixel", "XtToolkitError",
					"Cannot allocate colormap entry for \"%s\"",
					params, &num_params);

		} else {
			XtAppWarningMsg(the_app_con, "badValue",
					"cvtStringToPixel", "XtToolkitError",
					"Color name \"%s\" is not defined",
					params, &num_params);
		}

		*closure_ret = False;
		return False;
	} else {
		*closure_ret = (char *)True;
		done(Pixel, screenColor.pixel);
	}
}

/* ARGSUSED */
static void EmacsFreePixel(XtAppContext app,
			   XrmValuePtr toVal,
			   XtPointer closure,
			   XrmValuePtr args, Cardinal * num_args)
{
	if (*num_args != 2) {
		XtAppWarningMsg(app, "wrongParameters", "freePixel",
				"XtToolkitError",
				"Freeing a pixel requires screen and colormap arguments",
				(String *) NULL, (Cardinal *) NULL);
		return;
	}

	if (closure) {
		Screen *screen = *((Screen **) args[0].addr);
		Colormap colormap = *((Colormap *) args[1].addr);
		XFreeColors(DisplayOfScreen(screen), colormap,
			    (unsigned long *)toVal->addr, 1, (unsigned long)0);
	}
}

/************************************************************************/
/*            handle focus changes for native widgets                  */
/************************************************************************/
static void
emacs_Xt_event_widget_focus_in(Widget w,
			       XEvent * event,
			       String * params, Cardinal * num_params)
{
	struct frame *f =
	    x_any_widget_or_parent_to_frame(get_device_from_display
					    (event->xany.display), w);

	XtSetKeyboardFocus(FRAME_X_SHELL_WIDGET(f), w);
}

static void
emacs_Xt_event_widget_focus_out(Widget w,
				XEvent * event,
				String * params, Cardinal * num_params)
{
}

static XtActionsRec widgetActionsList[] = {
	{"widget-focus-in", emacs_Xt_event_widget_focus_in},
	{"widget-focus-out", emacs_Xt_event_widget_focus_out},
};

static void emacs_Xt_event_add_widget_actions(XtAppContext ctx)
{
	XtAppAddActions(ctx, widgetActionsList, 2);
}

/************************************************************************/
/*                            initialization                            */
/************************************************************************/

void syms_of_event_Xt(void)
{
	defsymbol(&Qkey_mapping, "key-mapping");
	defsymbol(&Qsans_modifiers, "sans-modifiers");
	defsymbol(&Qself_insert_command, "self-insert-command");
}

void reinit_vars_of_event_Xt(void)
{
	Xt_event_stream = xnew(struct event_stream);
	Xt_event_stream->event_pending_p = emacs_Xt_event_pending_p;
	Xt_event_stream->force_event_pending = emacs_Xt_force_event_pending;
	Xt_event_stream->next_event_cb = emacs_Xt_next_event;
	Xt_event_stream->handle_magic_event_cb = emacs_Xt_handle_magic_event;
	Xt_event_stream->add_timeout_cb = emacs_Xt_add_timeout;
	Xt_event_stream->remove_timeout_cb = emacs_Xt_remove_timeout;
	Xt_event_stream->select_console_cb = emacs_Xt_select_console;
	Xt_event_stream->unselect_console_cb = emacs_Xt_unselect_console;
	Xt_event_stream->select_process_cb = emacs_Xt_select_process;
	Xt_event_stream->unselect_process_cb = emacs_Xt_unselect_process;
	Xt_event_stream->quit_p_cb = emacs_Xt_quit_p;
	Xt_event_stream->create_stream_pair_cb = emacs_Xt_create_stream_pair;
	Xt_event_stream->delete_stream_pair_cb = emacs_Xt_delete_stream_pair;
	Xt_event_stream->current_event_timestamp_cb =
	    emacs_Xt_current_event_timestamp;

	the_Xt_timeout_blocktype = Blocktype_new(struct Xt_timeout_blocktype);

	last_quit_check_signal_tick_count = 0;

	/* this function only makes safe calls */
	init_what_input_once();
}

void vars_of_event_Xt(void)
{
	reinit_vars_of_event_Xt();

	dispatch_event_queue = Qnil;
	staticpro(&dispatch_event_queue);
	dispatch_event_queue_tail = Qnil;
	dump_add_root_object(&dispatch_event_queue_tail);

	DEFVAR_BOOL("x-allow-sendevents", &x_allow_sendevents	/*
*Non-nil means to allow synthetic events.  Nil means they are ignored.
Beware: allowing emacs to process SendEvents opens a big security hole.
								 */ );
	x_allow_sendevents = 0;

#ifdef DEBUG_SXEMACS
	DEFVAR_INT("debug-x-events", &debug_x_events	/*
If non-zero, display debug information about X events that SXEmacs sees.
Information is displayed on stderr.  Currently defined values are:

  1 == non-verbose output
  2 == verbose output
							 */ );
	debug_x_events = 0;
#endif
}

/* This mess is a hack that patches the shell widget to treat visual inheritance
   the same as colormap and depth inheritance */

static XtInitProc orig_shell_init_proc;

static void ShellVisualPatch(Widget wanted, Widget new,
			     ArgList args, Cardinal * num_args)
{
	Widget p;
	ShellWidget w = (ShellWidget) new;

	/* first, call the original setup */
	(*orig_shell_init_proc) (wanted, new, args, num_args);

	/* if the visual isn't explicitly set, grab it from the nearest shell ancestor */
	if (w->shell.visual == CopyFromParent) {
		p = XtParent(w);
		while (p && !XtIsShell(p))
			p = XtParent(p);
		if (p)
			w->shell.visual = ((ShellWidget) p)->shell.visual;
	}
}

void init_event_Xt_late(void)
{				/* called when already initialized */
	timeout_id_tick = 1;
	pending_timeouts = NULL;
	completed_timeouts_head = NULL;	/* queue is empty */
	completed_timeouts_tail = NULL;	/* just to be picky */

	event_stream = Xt_event_stream;

#if defined(HAVE_XIM) || defined(USE_XFONTSET)
	Initialize_Locale();
#endif				/* HAVE_XIM || USE_XFONTSET */

	XtToolkitInitialize();
	Xt_app_con = XtCreateApplicationContext();
	XtAppSetFallbackResources(Xt_app_con, (String *) x_fallback_resources);

	/* In select-x.c */
	x_selection_timeout = (XtAppGetSelectionTimeout(Xt_app_con) / 1000);
	XSetErrorHandler(x_error_handler);
	XSetIOErrorHandler(x_IO_error_handler);

	XtAppAddInput(Xt_app_con, signal_event_pipe[0],
		      (XtPointer) (XtInputReadMask /* | XtInputExceptMask */ ),
		      Xt_what_callback, 0);

	XtAppSetTypeConverter(Xt_app_con, XtRString, XtRPixel,
			      EmacsXtCvtStringToPixel,
			      (XtConvertArgList) colorConvertArgs,
			      2, XtCacheByDisplay, EmacsFreePixel);

#ifdef XIM_XLIB
	XtAppSetTypeConverter(Xt_app_con, XtRString, XtRXimStyles,
			      EmacsXtCvtStringToXIMStyles,
			      NULL, 0, XtCacheByDisplay, EmacsFreeXIMStyles);
#endif				/* XIM_XLIB */
	/* Add extra actions to native widgets to handle focus and friends. */
	emacs_Xt_event_add_widget_actions(Xt_app_con);

	/* insert the visual inheritance patch/hack described above */
	orig_shell_init_proc = shellClassRec.core_class.initialize;
	shellClassRec.core_class.initialize = ShellVisualPatch;

}
