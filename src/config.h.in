/* SXEmacs site configuration template file.  -*- C -*-
   Copyright (C) 1986, 1991-1994, 1998, 1999 Free Software Foundation, Inc.
   Copyright (C) 2004, 2005, 2006 Steve Youngs.
   Copyright (C) 2006 Sebastian Freundt

This file is part of SXEmacs.

SXEmacs is free software; you can redistribute it and/or modify it
under the terms of the GNU General Public License as published by the
Free Software Foundation; either version 2, or (at your option) any
later version.

SXEmacs is distributed in the hope that it will be useful, but WITHOUT
ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
for more details.

You should have received a copy of the GNU General Public License
along with SXEmacs; see the file COPYING.  If not, write to
the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
Boston, MA 02111-1307, USA.  */

/* Significantly divergent from FSF. */

/* No code in SXEmacs #includes config.h twice, but some of the code
   intended to work with other packages as well (like gmalloc.c)
   think they can include it as many times as they like.  */
#ifndef _SRC_CONFIG_H_
#define _SRC_CONFIG_H_

#ifndef NOT_C_CODE
#if defined (__GNUC__)
#define alloca __builtin_alloca
#elif defined __DECC
#include <alloca.h>
#pragma intrinsic(alloca)
#elif defined __INTEL_COMPILER && defined HAVE_ALLOCA_H
/* defer #include to end of file */
#elif defined HAVE_ALLOCA_H
#include <alloca.h>
#elif defined(_AIX)
#pragma alloca
#elif ! defined (alloca)
void *alloca();
#endif
#endif				/* C code */

/* Use this to add code in a structured way to FSF-maintained source
   files so as to make it obvious where SXEmacs changes are. */
#define XEMACS 1

#include "config.defs.h"

#ifdef HAVE_X_WINDOWS
#ifndef NeedFunctionPrototypes
#define NeedFunctionPrototypes 1
#endif
#ifndef FUNCPROTO
#define FUNCPROTO 15
#endif
#endif				/* HAVE_X_WINDOWS */

/* Define HAVE_WINDOW_SYSTEM if any windowing system is available. */
#if defined (HAVE_GTK) || defined (HAVE_X_WINDOWS)
	/* || defined (HAVE_NEXTSTEP) */
#define HAVE_WINDOW_SYSTEM
#endif

/* Define HAVE_UNIXOID_EVENT_LOOP if we use select() to wait for events. */
#if defined (HAVE_X_WINDOWS) || defined (HAVE_TTY)
#define HAVE_UNIXOID_EVENT_LOOP
#endif

/* USER_FULL_NAME returns a string that is the user's full name.
   It can assume that the variable `pw' points to the password file
   entry for this user.

   At some sites, the pw_gecos field contains the user's full name.
   If neither this nor any other field contains the right thing, use
   pw_name, giving the user's login name, since that is better than
   nothing. */
#define USER_FULL_NAME pw->pw_gecos

/* Make sure that all X... macros are dereferencing the correct type,
   and that all XSET... macros (as much as possible) are setting the
   correct type of structure.  Highly recommended for all
   development work. */
#ifdef ERROR_CHECK_TYPECHECK
#define type_checking_assert(assertion) assert (assertion)
#else
#define type_checking_assert(assertion)
#endif

/* Make sure valid buffer positions are passed to BUF_* macros. */
#ifdef ERROR_CHECK_BUFPOS
#define bufpos_checking_assert(assertion) assert (assertion)
#else
#define bufpos_checking_assert(assertion)
#endif

/* Attempt to catch bugs related to garbage collection (e.g. not GCPRO'ing). */
#ifdef ERROR_CHECK_GC
#define gc_checking_assert(assertion) assert (assertion)
#else
#define gc_checking_assert(assertion)
#endif

#if (defined (QUANTIFY) || defined (PURIFY)) && !defined (XLIB_ILLEGAL_ACCESS)
#define XLIB_ILLEGAL_ACCESS 1
#endif

/* The configuration script may define `opsysfile' to be the name of
   the s/...h file that describes your operating system.
   The file name is chosen based on the configuration name. */

#if defined (__cplusplus) && !defined (NOT_C_CODE)
extern "C" {
#endif

#ifdef config_opsysfile
#include config_opsysfile
#endif

/* The configuration script may define `machfile' to be the name of
   the m/...h file that describes the machine you are using.
   The file name is chosen based on the configuration name. */

#ifdef config_machfile
#include config_machfile
#endif

#if defined (__cplusplus) && !defined (NOT_C_CODE)
}
#endif
#if defined (USE_SYSTEM_MALLOC) && !defined (SYSTEM_MALLOC)
#define SYSTEM_MALLOC
#endif
/* Define the return type of signal handlers if the s/xxx.h file
   did not already do so. */
#define RETSIGTYPE void
/* SIGTYPE is the macro we actually use. */
#ifndef SIGTYPE
#define SIGTYPE RETSIGTYPE
#define SIGRETURN return
#endif


#if defined (HAVE_MENUBARS) || defined (HAVE_DIALOGS)
#define HAVE_POPUPS
#endif
/* If you are using SunOS 4.1.1 and X11r5, then you need this patch.
   There is a stupid bug in the SunOS libc.a: two functions which X11r5
   uses, mbstowcs() and wcstombs(), are unusable when programs are
   statically linked (as SXEmacs must be) because the static version of
   libc.a contains the *dynamic* versions of these functions.  These
   functions don't seem to be called when SXEmacs is running, so it's
   enough to define stubs for them.

   This appears to be fixed in SunOS 4.1.2.

   Also, SunOS 4.1.1 contains buggy versions of strcmp and strcpy that
   sometimes reference memory past the end of the string, which can segv.
   I don't know whether this has been fixed as of 4.1.2 or 4.1.3. */
#if defined (sparc) && !defined (USG)
#define OBJECTS_SYSTEM sunOS-fix.o strcmp.o strcpy.o
#endif

/* basic system calls */
#if defined (INTERRUPTIBLE_IO) || defined (DEBUG_ENCAPSULATION)
# define ENCAPSULATE_READ
# define ENCAPSULATE_WRITE
#endif
#if defined (INTERRUPTIBLE_OPEN) || defined (MULE) || defined (DEBUG_ENCAPSULATION)
# define ENCAPSULATE_OPEN
#endif
#if defined (INTERRUPTIBLE_CLOSE) || defined (DEBUG_ENCAPSULATION)
# define ENCAPSULATE_CLOSE
#endif
/* stdio calls */
#if defined (INTERRUPTIBLE_IO) || defined (DEBUG_ENCAPSULATION)
# define ENCAPSULATE_FREAD
# define ENCAPSULATE_FWRITE
#endif
#if defined (INTERRUPTIBLE_OPEN) || defined (MULE) || defined (DEBUG_ENCAPSULATION)
# define ENCAPSULATE_FOPEN
#endif
#if defined (INTERRUPTIBLE_CLOSE) || defined (DEBUG_ENCAPSULATION)
# define ENCAPSULATE_FCLOSE
#endif
/* directory calls */
#if defined (MULE) || defined (DEBUG_ENCAPSULATION)
# define ENCAPSULATE_CHDIR
# define ENCAPSULATE_MKDIR
# define ENCAPSULATE_OPENDIR
# define ENCAPSULATE_CLOSEDIR
# define ENCAPSULATE_READDIR
# define ENCAPSULATE_RMDIR
/* file-information calls */
#ifdef HAVE_EACCESS
# define ENCAPSULATE_EACCESS
#endif
# define ENCAPSULATE_ACCESS
# define ENCAPSULATE_LSTAT
# define ENCAPSULATE_READLINK
# define ENCAPSULATE_STAT
/* file-manipulation calls */
# define ENCAPSULATE_CHMOD
# define ENCAPSULATE_CREAT
# define ENCAPSULATE_LINK
# define ENCAPSULATE_RENAME
# define ENCAPSULATE_SYMLINK
# define ENCAPSULATE_UNLINK
# define ENCAPSULATE_EXECVP
#endif				/* defined (MULE) || defined (DEBUG_ENCAPSULATION) */
#ifdef HAVE_CANNA
#  define CANNA2
#  define CANNA_MULE
#  define CANNA_PURESIZE 0
#else				/* not CANNA */
#  define CANNA_PURESIZE 0
#endif				/* not CANNA */
#if defined (HAVE_SOCKS) && !defined (DO_NOT_SOCKSIFY)
#define accept Raccept
#define bind Rbind
#define connect Rconnect
#define getsockname Rgetsockname
#define listen Rlisten
#endif				/* HAVE_SOCKS && !DO_NOT_SOCKSIFY */

#ifndef BITS_PER_CHAR
#define BITS_PER_CHAR 8
#endif
#define SHORTBITS (SIZEOF_SHORT * BITS_PER_CHAR)
#define INTBITS (SIZEOF_INT * BITS_PER_CHAR)
#define LONGBITS (SIZEOF_LONG * BITS_PER_CHAR)
#define LONG_LONG_BITS (SIZEOF_LONG_LONG * BITS_PER_CHAR)
#define VOID_P_BITS (SIZEOF_VOID_P * BITS_PER_CHAR)
/* Use `INLINE_HEADER' to define inline functions in .h files.
   Use `inline static' to define inline functions in .c files.
   See the Internals manual for examples and more information. *//* Does the keyword `inline' exist?  */
#if defined (__cplusplus) || ! defined (__GNUC__)
# define INLINE_HEADER inline static
#elif defined (DONT_EXTERN_INLINE_HEADER_FUNCTIONS)
# define INLINE_HEADER inline
#else
# define INLINE_HEADER inline extern
#endif
#ifndef NOT_C_CODE		/* Actually means C or C++ */
# if defined (__cplusplus)
/* Avoid C++ keywords used as ordinary C identifiers */
#  define class c_class
#  define new   c_new
#  define this  c_this
#  define catch c_catch
#  define EXTERN_C extern "C"
# else				/* C code */
#  define EXTERN_C extern
# endif
#endif				/* C or C++ */
/* Strictly speaking, only int or unsigned int are valid types in a
   bitfield.  In practice, we would like to use enums as bitfields.
   The following should just result in warning avoidance:
   warning: nonportable bit-field type */
#ifdef __GNUC__
#define enum_field(enumeration_type) enum enumeration_type
#else
#define enum_field(enumeration_type) unsigned int
#endif
/* We want to avoid saving the signal mask if possible, because
   that necessitates a system call. */
#ifdef HAVE_SIGSETJMP
# define SETJMP(x) sigsetjmp (x, 0)
# define LONGJMP(x, y) siglongjmp (x, y)
# define JMP_BUF sigjmp_buf
#else
# define SETJMP(x) setjmp (x)
# define LONGJMP(x, y) longjmp (x, y)
# define JMP_BUF jmp_buf
#endif

#ifndef NOT_C_CODE
#if defined __INTEL_COMPILER && defined HAVE_ALLOCA_H
/* icc's alloca.h pulls in <features.h>,
   but that must be done after _GNU_SOURCE and friends are defined */
#include <alloca.h>
#endif
#endif				/* C code */
#endif				/* _SRC_CONFIG_H_ */
